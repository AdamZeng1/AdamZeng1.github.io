<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AdamZeng</title>
  
  <subtitle>start from zero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://adamzeng.site/"/>
  <updated>2018-01-09T07:22:54.994Z</updated>
  <id>http://adamzeng.site/</id>
  
  <author>
    <name>AdamZeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据分析之四</title>
    <link href="http://adamzeng.site/2018/01/08/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8B%E5%9B%9B/"/>
    <id>http://adamzeng.site/2018/01/08/数据分析之四/</id>
    <published>2018-01-08T12:17:07.000Z</published>
    <updated>2018-01-09T07:22:54.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Merging-DataFrames"><a href="#Merging-DataFrames" class="headerlink" title="Merging DataFrames"></a>Merging DataFrames</h3><p>上周，我们介绍了Pandas数据处理和分析的程序库。我们看到，是实际上两个非常相似的核心数据结构，一维的列表（series）物件和二维的数据框<a id="more"></a>（DataFrame）物件。查询这两个数据结构以几种不同的方式完成，例如使用iloc或loc属性进行对行（row）的查询，或者使用方括号在物件本身进行对于列（column）的查询。最重要的是，我们看到一个可以查询DataFrame和series物件通过布林遮蔽（boolean masking）。布林遮蔽是一种强大的过滤方法，它允许我们使用广播来确定在我们的分析中应该保留哪些数据。</p><p>在本周的讲课中，我们将详细介绍如何操作DataFrame。我们将探讨如何使用GroupBy和Apply来减少和处理数据，以及如何将多个文件中的数据集合在一起。</p><p>我们还将讨论pandas一些有用的功能，对传统统计分析和机器学习。我们从如何合并数据集开始吧。我们已经看到如何将新数据添加到现有的DataFrame中。只需使用带有新列名称的方括号运算符，只要索引被共用，数据就添加了。如果没有共享索引，并传入一个标量值，那么记住一个纯量只是一个整数或一个字串。添加在列的新值，是以纯量作为预设值。如果我们想为每一行分配一个不同的值呢？那么它变得更棘手。如果我们可以将值，写死程序到列表中，那么pandas将解拆解它们并将它们分配给行。但是，如果我们的列表不够长，那么我们不能这样做，因为pandas不知道丢失的值应该去哪里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">df=pd.DataFrame([&#123;<span class="string">'Name'</span> : <span class="string">'Chris'</span>, <span class="string">'Item Purchased'</span>: <span class="string">'Sponge'</span>,<span class="string">'Cost'</span>:<span class="number">22.50</span>&#125;,</div><div class="line">                &#123;<span class="string">'Name'</span>:<span class="string">'Keyvyn'</span>,<span class="string">'Item Purchased'</span>: <span class="string">'Kitty Litter'</span>,<span class="string">'Cost'</span>:<span class="number">2.50</span>&#125;,</div><div class="line">                &#123;<span class="string">'Name'</span>:<span class="string">'Filip'</span>,<span class="string">'Item Purchased'</span>:<span class="string">'Spoon'</span>,<span class="string">'Cost'</span>:<span class="number">5.00</span>&#125;],</div><div class="line">               index=[<span class="string">'Store 1'</span>,<span class="string">'Store 1'</span>,<span class="string">'Store 2'</span>])</div><div class="line">df</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CostItem PurchasedName</div><div class="line">Store <span class="number">1</span><span class="number">22.5</span>SpongeChris</div><div class="line">Store <span class="number">1</span><span class="number">2.5</span>Kitty LitterKeyvyn</div><div class="line">Store <span class="number">2</span><span class="number">5.0</span>SpoonFilip</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'data'</span>]=[<span class="string">'December 1'</span>,<span class="string">'January'</span>,<span class="string">'mid-May'</span>]</div><div class="line">df</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CostItem PurchasedNamedata</div><div class="line">Store <span class="number">1</span><span class="number">22.5</span>SpongeChrisDecember <span class="number">1</span></div><div class="line">Store <span class="number">1</span><span class="number">2.5</span>Kitty LitterKeyvynJanuary</div><div class="line">Store <span class="number">2</span><span class="number">5.0</span>SpoonFilipmid-May</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Delivered'</span>]=<span class="keyword">True</span></div><div class="line">df</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CostItem PurchasedNamedataDelivered</div><div class="line">Store <span class="number">1</span><span class="number">22.5</span>SpongeChrisDecember <span class="number">1</span><span class="keyword">True</span></div><div class="line">Store <span class="number">1</span><span class="number">2.5</span>Kitty LitterKeyvynJanuary<span class="keyword">True</span></div><div class="line">Store <span class="number">2</span><span class="number">5.0</span>SpoonFilipmid-May<span class="keyword">True</span></div></pre></td></tr></table></figure><p>当我们只添加几个项目时，会出现问题。为了使其工作，我们必须为pandas提供足够长的DataFrame的列表，以便可以填充每一行。这意味着我们必须自己输入none值。如果我们每行都有一个独特的索引，那么我们可以将新的列标识分配给该系列。例如，如果我们在此范例中重置索引，因此DataFrame索引标记为0到2，那么我们使用这些标记创建一个新的系列，我们可引用它。我们得到的结果是我们预期的。这种方法的好方面是，我们可以忽略项目中我们不知道的，Pandas会为我们放进丢失值。所以这是一个非常好的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Feedback'</span>]=[<span class="string">'Positive'</span>,<span class="keyword">None</span>,<span class="string">'Negative'</span>]</div><div class="line">df</div><div class="line"></div><div class="line">CostItem PurchasedNamedataDeliveredFeedback</div><div class="line">Store <span class="number">1</span><span class="number">22.5</span>SpongeChrisDecember <span class="number">1</span><span class="keyword">True</span>Positive</div><div class="line">Store <span class="number">1</span><span class="number">2.5</span>Kitty LitterKeyvynJanuary<span class="keyword">True</span><span class="keyword">None</span></div><div class="line">Store <span class="number">2</span><span class="number">5.0</span>SpoonFilipmid-May<span class="keyword">True</span>Negative</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">adf=df.reset_index()</div><div class="line">adf[<span class="string">'Date'</span>]=pd.Series(&#123;<span class="number">0</span>:<span class="string">'December 1'</span>,<span class="number">2</span>:<span class="string">'mid_May'</span>&#125;)</div><div class="line">adf</div><div class="line"></div><div class="line">indexCostItem PurchasedNamedataDeliveredFeedbackDate</div><div class="line"><span class="number">0</span>Store <span class="number">1</span><span class="number">22.5</span>SpongeChrisDecember <span class="number">1</span><span class="keyword">True</span>PositiveDecember <span class="number">1</span></div><div class="line"><span class="number">1</span>Store <span class="number">1</span><span class="number">2.5</span>Kitty LitterKeyvynJanuary<span class="keyword">True</span><span class="keyword">None</span>NaN</div><div class="line"><span class="number">2</span>Store <span class="number">2</span><span class="number">5.0</span>SpoonFilipmid-May<span class="keyword">True</span>Negativemid_May</div></pre></td></tr></table></figure><p>更常见的是，我们想要结合两个较大的DataFrame在一起，这是一个比较复杂的。在我们跳入程序之前，我们需要解决一点关联理论，并设定一些语言的惯例。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%888.52.55.png" alt="image"></p><p>这是韦恩图。韦恩图通常用于显示集合的关系。例如在左边圆圈的人口是一所大学的学生。在右边圈的人口是一所大学的工作人员。中间的重叠地区是那些也是学生也是工作人员的人。我们可以将这两个人群视为个别的DataFrames中的索引，可能有Person Name的标识。当我们想结合DataFrames时，我们有一些选择。首先，如果我们想要所有人的名单，无论 他们是工作人员还是学生，以及获得所有他们的信息呢？在数据库术语中，这称为完整的外连接（full outer join)。</p><p>在集合中被称为union，在韦恩图中，它代表了任何一个圈子的每个人。很可能，我们只要那些我们拥有最多资料的人，那些既是工作人员又是学生的人。在数据库术语中，这称为内连接（inner join）。或者在集合理论中，交集（intersection）。这在韦恩图中被表示为重叠部分在每个圈中。好的，让我们来看一个我们如何在Pandas中做这个的例子，在那里我们将使用merge函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">staff_df=pd.DataFrame([&#123;<span class="string">'Name'</span>:<span class="string">'Kelly'</span>,<span class="string">'Role'</span>:<span class="string">'Director of HR'</span>&#125;,</div><div class="line">                      &#123;<span class="string">'Name'</span>:<span class="string">'Sally'</span>,<span class="string">'Role'</span>:<span class="string">'Course liaison'</span>&#125;,</div><div class="line">                      &#123;<span class="string">'Name'</span>:<span class="string">'James'</span>,<span class="string">'Role'</span>:<span class="string">'Grader'</span>&#125;])</div><div class="line">staff_df=staff_df.set_index(<span class="string">'Name'</span>)</div><div class="line">student_df=pd.DataFrame([&#123;<span class="string">'Name'</span>:<span class="string">'James'</span>,<span class="string">'School'</span>:<span class="string">'Business'</span>&#125;,</div><div class="line">                        &#123;<span class="string">'Name'</span>:<span class="string">'Mike'</span>,<span class="string">'School'</span>:<span class="string">'Law'</span>&#125;,</div><div class="line">                        &#123;<span class="string">'Name'</span>:<span class="string">'Sally'</span>,<span class="string">'School'</span>:<span class="string">'Engineering'</span>&#125;])</div><div class="line">student_df=student_df.set_index(<span class="string">'Name'</span>)</div><div class="line"></div><div class="line">print(staff_df)</div><div class="line">print()</div><div class="line">print(student_df)</div><div class="line"></div><div class="line">                Role</div><div class="line">Name                 </div><div class="line">Kelly  Director of HR</div><div class="line">Sally  Course liaison</div><div class="line">James          Grader</div><div class="line"></div><div class="line">            School</div><div class="line">Name              </div><div class="line">James     Business</div><div class="line">Mike           Law</div><div class="line">Sally  Engineering</div></pre></td></tr></table></figure><p>如果我们想要这些的union，我们将调用merge，传入在左边的DataFrame和在右边的DataFrame，并且告诉merge我们想要使用外连接（outer join）。我们告诉merge，我们要用左索引和右索引作为结合列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pd.merge(staff_df,student_df,how=<span class="string">'outer'</span>,left_index=<span class="keyword">True</span>,right_index=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">RoleSchool</div><div class="line">Name</div><div class="line">JamesGraderBusiness</div><div class="line">KellyDirector of HRNaN</div><div class="line">MikeNaNLaw</div><div class="line">SallyCourse liaisonEngineering</div></pre></td></tr></table></figure><p>我们在结果的DataFrame中看到每个人都被列出。而且由于Mike没有任何role，而John没有School，那些单元被列为缺失值（NaN)。如果我们想要得到intersection，就是那些也是员工的学生，我们可以将how属性设置为inner。而我们设置的结果DataFrame只有James和Sally。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pd.merge(staff_df,student_df,how=<span class="string">'inner'</span>,left_index=<span class="keyword">True</span>,right_index=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">RoleSchool</div><div class="line">Name</div><div class="line">JamesGraderBusiness</div><div class="line">SallyCourse liaisonEngineering</div></pre></td></tr></table></figure><p>现在，当合并DataFrames时，还有另外两个常见的用例。两个例子都是我们称之为集合加法（set addition）。第一个是当我们想要得到所有员工的名单，不管他们是否是学生。但如果他们是学生，我们想要获得他们的学生细节。为此，我们将使用使用左连接（left join）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pd.merge(staff_df,student_df,how=<span class="string">'left'</span>,left_index=<span class="keyword">True</span>,right_index=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">RoleSchool</div><div class="line">Name</div><div class="line">KellyDirector of HRNaN</div><div class="line">SallyCourse liaisonEngineering</div><div class="line">JamesGraderBusiness</div></pre></td></tr></table></figure><p>你可能猜测到接下来会是什么。我们想要一个所有学生和他们的角色的列表，如果他们也是工作人员。为此，我们将使用右连接（right join）。合并方法有一些其他有趣的参数。首先，您不需要使用索引来加入，也可以使用列。这是一个例子。这里有个例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">staff_df=pd.DataFrame([&#123;<span class="string">'Name'</span>:<span class="string">'Kelly'</span>,<span class="string">'Role'</span>:<span class="string">'Director of HR'</span>,<span class="string">'Location'</span>:<span class="string">'State Street'</span>&#125;,</div><div class="line">                      &#123;<span class="string">'Name'</span>:<span class="string">'Sally'</span>,<span class="string">'Role'</span>:<span class="string">'Course liaison'</span>,<span class="string">'Location'</span>:<span class="string">'Washington Avenue'</span>&#125;,</div><div class="line">                      &#123;<span class="string">'Name'</span>:<span class="string">'James'</span>,<span class="string">'Role'</span>:<span class="string">'Grader'</span>,<span class="string">'Location'</span>:<span class="string">'Washington Avenue'</span>&#125;])</div><div class="line">student_df=pd.DataFrame([&#123;<span class="string">'Name'</span>:<span class="string">'James'</span>,<span class="string">'School'</span>:<span class="string">'Bussiness'</span>,<span class="string">'Location'</span>:<span class="string">'1024 Billiard Avenue'</span>&#125;,</div><div class="line">                        &#123;<span class="string">'Name'</span>:<span class="string">'Mike'</span>,<span class="string">'School'</span>:<span class="string">'Law'</span>,<span class="string">'Location'</span>:<span class="string">'Fraternity House #22'</span>&#125;,</div><div class="line">                        &#123;<span class="string">'Name'</span>:<span class="string">'Sally'</span>,<span class="string">'School'</span>:<span class="string">'Engineering'</span>,<span class="string">'Location'</span>:<span class="string">'512 Wilson Crescent'</span>&#125;])</div><div class="line">pd.merge(staff_df,student_df,how=<span class="string">'left'</span>,left_on=<span class="string">'Name'</span>,right_on=<span class="string">'Name'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Location_xNameRoleLocation_ySchool</div><div class="line"><span class="number">0</span>State StreetKellyDirector of HRNaNNaN</div><div class="line"><span class="number">1</span>Washington AvenueSallyCourse liaison<span class="number">512</span> Wilson CrescentEngineering</div><div class="line"><span class="number">2</span>Washington AvenueJamesGrader<span class="number">1024</span> Billiard AvenueBussiness</div></pre></td></tr></table></figure><p>merge函数保留此资料，但附加_x或 _y以帮助区分哪个索引与哪个列的数据有关。__x始终是左边的DataFrame资料，而y始终是右边的DataFrame资料。</p><p>你可以控制<strong>_</strong>x和y的名字使用附加参数，如果你想。现在你试试看。以下是产品和发票的DataFrame。该产品具有标识符和标价。发票列出了人员，产品，标识符和数量。假设我们要产生总计，我们如何将这两个DataFrames加在一起，以便我们有一个列出我们需要的所有信息？</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Merging-DataFrames&quot;&gt;&lt;a href=&quot;#Merging-DataFrames&quot; class=&quot;headerlink&quot; title=&quot;Merging DataFrames&quot;&gt;&lt;/a&gt;Merging DataFrames&lt;/h3&gt;&lt;p&gt;上周，我们介绍了Pandas数据处理和分析的程序库。我们看到，是实际上两个非常相似的核心数据结构，一维的列表（series）物件和二维的数据框
    
    </summary>
    
      <category term="数据分析" scheme="http://adamzeng.site/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://adamzeng.site/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数据分析第三节</title>
    <link href="http://adamzeng.site/2018/01/05/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%89%E8%8A%82/"/>
    <id>http://adamzeng.site/2018/01/05/数据分析第三节/</id>
    <published>2018-01-05T02:16:51.000Z</published>
    <updated>2018-01-06T04:14:46.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Indexing-Dataframes"><a href="#Indexing-Dataframes" class="headerlink" title="Indexing Dataframes"></a>Indexing Dataframes</h3><p>如我们所见，列表（series）和DataFrames都可以应用索引（index）。索引本质上是行（row)的标识，我们知道行对应于轴零（axis=0）。在我们的奥运数据中，我们用国家的名称对DataFrame进行索引。指数可以被自动推断美丽如当我们创建新列表，没有指定索引时，在这种情况下，我们获得数值索引；或者可以明确设置，比如当我们使用字典（dictionary）创建列表时；或者当我们下载数据时从CSV文件时；指定标头，另一个选项用来设置index是使用set_index函数。此函数使用一个列（column）的名单，并将这些列提升为索引。set_index是个破坏性过程，它不保留当前的索引。如果要保留当前的索引，则需要手动创建一个新的列，并从index属性将其复制到其中。我们回到我们的奥运DataFrame。假设我们不想按照国家来索引DataFrame，而是要按夏季奥运中获得的金牌数量进行索引。首先，我们需要将原来的国家索引保存到新的列（‘country’）。我们可以使用索引操作或具有列标识的字串来执行此操作。然后我们用set_index，使用夏季金牌获得数量column，来设置新的索引。<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'country'</span>] = df.index <span class="comment"># set the old index as country column</span></div><div class="line">df = df.set_index(<span class="string">'Gold'</span>) <span class="comment"># set Gold column as new index</span></div><div class="line">df.head()</div><div class="line"></div><div class="line"><span class="comment"># SummerSilverBronzeTotal# WinterGold.1Silver.1Bronze.1Total.1# GamesGold.2Silver.2Bronze.2Combined totalcountry</span></div><div class="line">Gold</div><div class="line"><span class="number">0</span><span class="number">13</span><span class="number">0</span><span class="number">2</span><span class="number">2</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">13</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">2</span>Afghanistan (AFG)</div><div class="line"><span class="number">5</span><span class="number">12</span><span class="number">2</span><span class="number">8</span><span class="number">15</span><span class="number">3</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">15</span><span class="number">5</span><span class="number">2</span><span class="number">8</span><span class="number">15</span>Algeria (ALG)</div><div class="line"><span class="number">18</span><span class="number">23</span><span class="number">24</span><span class="number">28</span><span class="number">70</span><span class="number">18</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">41</span><span class="number">18</span><span class="number">24</span><span class="number">28</span><span class="number">70</span>Argentina (ARG)</div><div class="line"><span class="number">1</span><span class="number">5</span><span class="number">2</span><span class="number">9</span><span class="number">12</span><span class="number">6</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">11</span><span class="number">1</span><span class="number">2</span><span class="number">9</span><span class="number">12</span>Armenia (ARM)</div><div class="line"><span class="number">3</span><span class="number">2</span><span class="number">4</span><span class="number">5</span><span class="number">12</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span><span class="number">12</span>Australasia (ANZ) [ANZ]</div></pre></td></tr></table></figure><p>Gold列变成了索引列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">df=df.reset_index() <span class="comment"># reset the index and old index become column</span></div><div class="line">df.head()</div><div class="line"></div><div class="line"></div><div class="line">Gold<span class="comment"># SummerSilverBronzeTotal# WinterGold.1Silver.1Bronze.1Total.1# GamesGold.2Silver.2Bronze.2Combined totalcountry</span></div><div class="line"><span class="number">0</span><span class="number">0</span><span class="number">13</span><span class="number">0</span><span class="number">2</span><span class="number">2</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">13</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">2</span>Afghanistan (AFG)</div><div class="line"><span class="number">1</span><span class="number">5</span><span class="number">12</span><span class="number">2</span><span class="number">8</span><span class="number">15</span><span class="number">3</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">15</span><span class="number">5</span><span class="number">2</span><span class="number">8</span><span class="number">15</span>Algeria (ALG)</div><div class="line"><span class="number">2</span><span class="number">18</span><span class="number">23</span><span class="number">24</span><span class="number">28</span><span class="number">70</span><span class="number">18</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">41</span><span class="number">18</span><span class="number">24</span><span class="number">28</span><span class="number">70</span>Argentina (ARG)</div><div class="line"><span class="number">3</span><span class="number">1</span><span class="number">5</span><span class="number">2</span><span class="number">9</span><span class="number">12</span><span class="number">6</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">11</span><span class="number">1</span><span class="number">2</span><span class="number">9</span><span class="number">12</span>Armenia (ARM)</div><div class="line"><span class="number">4</span><span class="number">3</span><span class="number">2</span><span class="number">4</span><span class="number">5</span><span class="number">12</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span><span class="number">12</span>Australasia (ANZ) [ANZ]</div></pre></td></tr></table></figure><p>Pandas的一个很好的功能是可以选择进行多层次索引，这与关联数据库系统中的复合键类似。要创建多层次索引，我们只需要调用set_index,给一个列的列表，包含我们有兴趣提升为索引的。Pandas将按照顺序搜索这些资料，找出不同的数据，并形成综合索引指数。我们经常可以发现很好的例子，在处理地理数据，按区域或人口统计来分类的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df=pd.read_csv(<span class="string">'census.csv'</span>)</div><div class="line">df.head()</div><div class="line"></div><div class="line">SUMLEVREGIONDIVISIONSTATECOUNTYSTNAMECTYNAMECENSUS2010POPESTIMATESBASE2010POPESTIMATE2010...RDOMESTICMIG2011RDOMESTICMIG2012RDOMESTICMIG2013RDOMESTICMIG2014RDOMESTICMIG2015RNETMIG2011RNETMIG2012RNETMIG2013RNETMIG2014RNETMIG2015</div><div class="line"><span class="number">0</span><span class="number">40</span><span class="number">3</span><span class="number">6</span><span class="number">1</span><span class="number">0</span></div></pre></td></tr></table></figure><p>大概是这样的数据表格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'SUMLEV'</span>].unique()<span class="comment"># find the unique number in column SUMLEV</span></div><div class="line"></div><div class="line">array([<span class="number">40</span>, <span class="number">50</span>])</div></pre></td></tr></table></figure><p>在SUMLEV中只有两种数，40和50。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df=df[df[<span class="string">'SUMLEV'</span>]==<span class="number">50</span>]<span class="comment"># get content when SUMLEV==50</span></div><div class="line">df.head()</div></pre></td></tr></table></figure><p>让我们除掉每一行州的摘要数据，只保留县级数据。此外，基于许多不同的原因，这数据集是很有趣味的，让我们将减少我们将要查看的数据，仅包括总人口估计和总出生次数。我们可以这样做，通过创建我们想要保留的列名称的列表，然后对这列表进行投入，并将生成的DataFrame分配给我们的df变量。美国人口普查数据分析人口数据估计按照州和县的方式。我们可以载入数据并将索引设置为州和县的组合，并查看Pandas如何在DataFrame中处理它。我们可以这样做，通过创建列标识的列表，我们想要用来当索引的。然后使用此列表，用set_index并酌情指定输出变量。我们在这里看到我们有一个双重索引，首先是州名，然后是县名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">columns_to_keep=[<span class="string">'STNAME'</span>,</div><div class="line">                <span class="string">'CTYNAME'</span>,</div><div class="line">                <span class="string">'BIRTHS2010'</span>,</div><div class="line">                <span class="string">'BIRTHS2011'</span>,</div><div class="line">                <span class="string">'BIRTHS2012'</span>,</div><div class="line">                <span class="string">'BIRTHS2013'</span>,</div><div class="line">                <span class="string">'BIRTHS2014'</span>,</div><div class="line">                <span class="string">'BIRTHS2015'</span>,</div><div class="line">                <span class="string">'POPESTIMATE2010'</span>,</div><div class="line">                <span class="string">'POPESTIMATE2011'</span>,</div><div class="line">                <span class="string">'POPESTIMATE2012'</span>,</div><div class="line">                <span class="string">'POPESTIMATE2013'</span>,</div><div class="line">                <span class="string">'POPESTIMATE2014'</span>,</div><div class="line">                <span class="string">'POPESTIMATE2015'</span>]</div><div class="line"></div><div class="line">df=df[columns_to_keep]<span class="comment"># put into selected column and make df a new table</span></div><div class="line">df.head(<span class="number">7</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df=df.set_index([<span class="string">'STNAME'</span>,<span class="string">'CTYNAME'</span>])<span class="comment"># set STMAME and CTYNAME as new multi-index </span></div><div class="line">df.head()</div></pre></td></tr></table></figure><p>当您使用Multi-index时，您必须按照要查询的级别顺序提供参数。</p><p>在索引内部，每列称为一个级别，最外面的列为级别零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">df.loc[<span class="string">'Michigan'</span>,<span class="string">'Washtenaw County'</span>]</div><div class="line"></div><div class="line">BIRTHS2010            <span class="number">977</span></div><div class="line">BIRTHS2011           <span class="number">3826</span></div><div class="line">BIRTHS2012           <span class="number">3780</span></div><div class="line">BIRTHS2013           <span class="number">3662</span></div><div class="line">BIRTHS2014           <span class="number">3683</span></div><div class="line">BIRTHS2015           <span class="number">3709</span></div><div class="line">POPESTIMATE2010    <span class="number">345563</span></div><div class="line">POPESTIMATE2011    <span class="number">349048</span></div><div class="line">POPESTIMATE2012    <span class="number">351213</span></div><div class="line">POPESTIMATE2013    <span class="number">354289</span></div><div class="line">POPESTIMATE2014    <span class="number">357029</span></div><div class="line">POPESTIMATE2015    <span class="number">358880</span></div><div class="line">Name: (Michigan, Washtenaw County), dtype: int64</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df.loc[[(<span class="string">'Michigan'</span>,<span class="string">'Washtenaw County'</span>),(<span class="string">'Michigan'</span>,<span class="string">'Wayne County'</span>)]]</div><div class="line"><span class="comment"># put into two state and county names</span></div></pre></td></tr></table></figure><p>当然你可以翻转列表，对列进行索引。</p><h3 id="缺失值讨论"><a href="#缺失值讨论" class="headerlink" title="缺失值讨论"></a>缺失值讨论</h3><p>我们将在本周的讲课中很快的讨论一下缺失的数据。我们已经预先看到了Pandas如何处理缺失值，使用None类型和在Numpy使用NaN。缺失值在数据清理活动中很常见。我们应该讨论几个注意事项和讨论要点。</p><p>第一，在内置的载入函数，从带分隔符号的文件，有提供控制缺失值的几种方法。这些中最有密切关系的是na_values选项名单，来指示可能引用缺失值的一些字串。例如，我的一些社会学家同事经常使用99在二进制类中来表示那里没有数值。所以这很方便。您也可以使用na_filter选项来关闭空白过滤，如果实际上空白对你是有用的。但实际上这是相当少见的。除了控制如何加载缺失值的规则之外，有时候有必要将缺少值视为具有实际信息。我从我自己的研究中给一个例子。我经常处理从网上学习系统的记录。尤其是我已经完成了几个专案，有关课程采集系统中的影片使用。在这些系统中，播放器具常常有心跳（规律传送讯号）功能，将播放统计咨询经常发送到服务器，也许每隔30秒。</p><p>这些活动资料可以变大，因为他们可以承载播放系统的整个状态，例如影片播放头在哪里，影片大小，哪个影片被呈现到荧幕，音量是多大的等等。</p><p>如果我们载入数据文件log.txt，我们可以看到一个这样的例子。在这个数据中，第一列是Unix纪元格式的时间戳。下一列是用户名，后跟他们正在访问的网页和他们正在播放的影片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">df = pd.read_csv(<span class="string">'log.csv'</span>)</div><div class="line">df</div><div class="line"></div><div class="line"></div><div class="line">timeuservideoplayback positionpausedvolume</div><div class="line"><span class="number">0</span><span class="number">1469974424</span>cherylintro.html<span class="number">5</span><span class="keyword">False</span><span class="number">10.0</span></div><div class="line"><span class="number">1</span><span class="number">1469974454</span>cherylintro.html<span class="number">6</span>NaNNaN</div><div class="line"><span class="number">2</span><span class="number">1469974544</span>cherylintro.html<span class="number">9</span>NaNNaN</div><div class="line"><span class="number">3</span><span class="number">1469974574</span>cherylintro.html<span class="number">10</span>NaNNaN</div><div class="line"><span class="number">4</span><span class="number">1469977514</span>bobintro.html<span class="number">1</span>NaNNaN</div><div class="line"><span class="number">5</span><span class="number">1469977544</span>bobintro.html<span class="number">1</span>NaNNaN</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">df=df.reset_index()</div><div class="line">df=df.set_index([<span class="string">'time'</span>,<span class="string">'user'</span>])</div><div class="line">df</div><div class="line"></div><div class="line">indexvideoplayback positionpausedvolume</div><div class="line">timeuser</div><div class="line"><span class="number">1469974424</span>cheryl<span class="number">0</span>intro.html<span class="number">5</span><span class="keyword">False</span><span class="number">10.0</span></div><div class="line"><span class="number">1469974454</span>cheryl<span class="number">1</span>intro.html<span class="number">6</span>NaNNaN</div><div class="line"><span class="number">1469974544</span>cheryl<span class="number">2</span>intro.html<span class="number">9</span>NaNNaN</div><div class="line"><span class="number">1469974574</span>cheryl<span class="number">3</span>intro.html<span class="number">10</span>NaNNaN</div><div class="line"><span class="number">1469977514</span>bob<span class="number">4</span>intro.html<span class="number">1</span>NaNNaN</div><div class="line"><span class="number">1469977544</span>bob<span class="number">5</span>intro.html<span class="number">1</span>NaNNaN</div><div class="line"><span class="number">1469977574</span>bob<span class="number">6</span>intro.html<span class="number">1</span>NaNNaN</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">df=df.fillna(method=<span class="string">'ffill'</span>)</div><div class="line">df.head(<span class="number">20</span>)</div><div class="line"></div><div class="line">indexvideoplayback positionpausedvolume</div><div class="line">timeuser</div><div class="line"><span class="number">1469974424</span>cheryl<span class="number">0</span>intro.html<span class="number">5</span><span class="keyword">False</span><span class="number">10.0</span></div><div class="line"><span class="number">1469974454</span>cheryl<span class="number">1</span>intro.html<span class="number">6</span><span class="keyword">False</span><span class="number">10.0</span></div><div class="line"><span class="number">1469974544</span>cheryl<span class="number">2</span>intro.html<span class="number">9</span><span class="keyword">False</span><span class="number">10.0</span></div><div class="line"><span class="number">1469974574</span>cheryl<span class="number">3</span>intro.html<span class="number">10</span><span class="keyword">False</span><span class="number">10.0</span></div><div class="line"><span class="number">1469977514</span>bob<span class="number">4</span>intro.html<span class="number">1</span><span class="keyword">False</span><span class="number">10.0</span></div><div class="line"><span class="number">1469977544</span>bob<span class="number">5</span>intro.html<span class="number">1</span><span class="keyword">False</span><span class="number">10.0</span></div><div class="line"><span class="number">1469977574</span>bob<span class="number">6</span>intro.html<span class="number">1</span><span class="keyword">False</span><span class="number">10.0</span></div><div class="line"><span class="number">1469977604</span>bob<span class="number">7</span>intro.html<span class="number">1</span><span class="keyword">False</span><span class="number">10.0</span></div><div class="line"><span class="number">1469974604</span>cheryl<span class="number">8</span>intro.html<span class="number">11</span><span class="keyword">False</span><span class="number">10.0</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Indexing-Dataframes&quot;&gt;&lt;a href=&quot;#Indexing-Dataframes&quot; class=&quot;headerlink&quot; title=&quot;Indexing Dataframes&quot;&gt;&lt;/a&gt;Indexing Dataframes&lt;/h3&gt;&lt;p&gt;如我们所见，列表（series）和DataFrames都可以应用索引（index）。索引本质上是行（row)的标识，我们知道行对应于轴零（axis=0）。在我们的奥运数据中，我们用国家的名称对DataFrame进行索引。指数可以被自动推断美丽如当我们创建新列表，没有指定索引时，在这种情况下，我们获得数值索引；或者可以明确设置，比如当我们使用字典（dictionary）创建列表时；或者当我们下载数据时从CSV文件时；指定标头，另一个选项用来设置index是使用set_index函数。此函数使用一个列（column）的名单，并将这些列提升为索引。set_index是个破坏性过程，它不保留当前的索引。如果要保留当前的索引，则需要手动创建一个新的列，并从index属性将其复制到其中。我们回到我们的奥运DataFrame。假设我们不想按照国家来索引DataFrame，而是要按夏季奥运中获得的金牌数量进行索引。首先，我们需要将原来的国家索引保存到新的列（‘country’）。我们可以使用索引操作或具有列标识的字串来执行此操作。然后我们用set_index，使用夏季金牌获得数量column，来设置新的索引。
    
    </summary>
    
      <category term="数据分析" scheme="http://adamzeng.site/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://adamzeng.site/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数据分析DataFrame Data Structure</title>
    <link href="http://adamzeng.site/2018/01/01/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90DataFrame-Data-Structure/"/>
    <id>http://adamzeng.site/2018/01/01/数据分析DataFrame-Data-Structure/</id>
    <published>2018-01-01T03:43:56.000Z</published>
    <updated>2018-01-04T14:00:14.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="The-DataFrame-Data-Structure"><a href="#The-DataFrame-Data-Structure" class="headerlink" title="The DataFrame Data Structure"></a>The DataFrame Data Structure</h3><p>DataFrame数据结构是Pandas的核心，这将是你的主要对象，在处理数据分析和数据清理任务的时候。DataFrame在概念上是一个二维列表series对象，其中有一个索引（index）和多列内容，每列（column）都有一个标识（label）。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-01%20%E4%B8%8B%E5%8D%8812.30.47.png" alt="image"></p><p>你可以将DataFrame本身视为简单的双轴有标识的阵列，你可以以许多不同的方式创建一个DataFrame，其中，你可以使用一组series，其中每个列表代表一行数据。或者你可以使用一组字典（dictionary），<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line">purchase_1=pd.Series(&#123;<span class="string">'Name'</span>:<span class="string">'Chris'</span>,</div><div class="line">                     <span class="string">'Item Purchased'</span>:<span class="string">'Dog Food'</span>,</div><div class="line">                     <span class="string">'Cost'</span>:<span class="number">22.50</span>&#125;)</div><div class="line">purchase_2=pd.Series(&#123;<span class="string">'Name'</span>:<span class="string">'Kevyn'</span>,</div><div class="line">                     <span class="string">'Item Purchased'</span>:<span class="string">'Kitty Litter'</span>,</div><div class="line">                     <span class="string">'Cost'</span>:<span class="number">2.50</span>&#125;)</div><div class="line">purchase_3=pd.Series(&#123;<span class="string">'Name'</span>:<span class="string">'Vinod'</span>,</div><div class="line">                     <span class="string">'Item Purchased'</span>:<span class="string">'Bird Seed'</span>,</div><div class="line">                     <span class="string">'Cost'</span>:<span class="number">5.00</span>&#125;)</div><div class="line">df=pd.DataFrame([purchase_1,purchase_2,purchase_3],index=[<span class="string">'Store 1'</span>,<span class="string">'Store 2'</span>,<span class="string">'Store 3'</span>])</div><div class="line">df.head()</div><div class="line"></div><div class="line"></div><div class="line">Cost  Item Purchased Name</div><div class="line">Store <span class="number">1</span><span class="number">22.5</span>Dog FoodChris</div><div class="line">Store <span class="number">2</span><span class="number">2.5</span>Kitty LitterKevyn</div><div class="line">Store <span class="number">3</span><span class="number">5.0</span>   Bird SeedVinod</div></pre></td></tr></table></figure><p>因为DataFrame是二维的，所以将单一值传递给loc，索引操作将返回一个列表，如果只有一行返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Item Purchased'</span>]</div><div class="line"></div><div class="line">Store <span class="number">1</span>        Dog Food</div><div class="line">Store <span class="number">2</span>    Kitty Litter</div><div class="line">Store <span class="number">3</span>       Bird Seed</div><div class="line">Name: Item Purchased, dtype: object</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df.loc[<span class="string">'Store 1'</span>]</div><div class="line"></div><div class="line">Cost                  <span class="number">22.5</span></div><div class="line">Item Purchased    Dog Food</div><div class="line">Name                 Chris</div><div class="line">Name: Store <span class="number">1</span>, dtype: object</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type(df.loc[<span class="string">'Store 2'</span>])</div><div class="line"></div><div class="line">pandas.core.series.Series</div></pre></td></tr></table></figure><p>Pandas的DataFrame的一个功能，就是可以快速的选择数据，在多重轴上，例如，如果你只想列出Store1的费用，你将提供两个参数给.loc，一个为行（row）索引，一个为列名（column）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df.loc[<span class="string">'Store 1'</span>,<span class="string">'Cost'</span>]</div><div class="line"></div><div class="line"><span class="number">22.5</span></div></pre></td></tr></table></figure><p>如果我们只想做列（row）选择，并且只取所有费用的清单怎么办？那么有几个选择，首先你可以获取DataFrame的转置使用大写T属性，该属性将交换所有列和行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df.T</div><div class="line"></div><div class="line">    Store <span class="number">1</span> Store <span class="number">2</span>Store <span class="number">3</span></div><div class="line">Cost<span class="number">22.5</span><span class="number">2.5</span>     <span class="number">5</span></div><div class="line">Item PurchasedDog FoodKitty LitterBird Seed</div><div class="line">NameChrisKevynVinod</div></pre></td></tr></table></figure><p>这本质上将你的列名称百年城索引index。然后我们可以使用.loc方法。这是有用的，但它很丑陋，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df.T.loc[<span class="string">'Cost'</span>]</div><div class="line"></div><div class="line">Store <span class="number">1</span>    <span class="number">22.5</span></div><div class="line">Store <span class="number">2</span>     <span class="number">2.5</span></div><div class="line">Store <span class="number">3</span>       <span class="number">5</span></div><div class="line">Name: Cost, dtype: object</div></pre></td></tr></table></figure><p>对于iloc和loc用于行（row）的选择，Pandas的开发人员直接在DataFrame上保留索引操作列（column）的选择，在Pandas的DataFrame中，列（column）总是有一个名字，所以这个选择始终是基于标识（label）的，而不是像在列表（series）对象上使用方括号运算符一样混乱。对于那些熟悉关系型数据库的人来说，这个操作类似于列（column）的投影。最后，由于使用索引（indexing）运算的结果，是DataFrame或者series，所以可以将运算连接在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df.loc[<span class="string">'Store 1'</span>][<span class="string">'Cost'</span>]</div><div class="line"></div><div class="line"><span class="number">22.5</span></div></pre></td></tr></table></figure><p>链接往往导致Pandas返回DataFrame的副本，而不是DataFrame的视图。对于选择数据，这没什么大不了，尽管它可能比必要的慢一点，如果你正在更改数据，这是一个重要的区别，可能是错误的根源。</p><p>另一种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df.loc[:,[<span class="string">'Name'</span>,<span class="string">'Cost'</span>]]</div><div class="line"></div><div class="line">  Name   Cost</div><div class="line">Store <span class="number">1</span>Chris<span class="number">22.5</span></div><div class="line">Store <span class="number">2</span>Kevyn<span class="number">2.5</span></div><div class="line">Store <span class="number">3</span>Vinod<span class="number">5.0</span></div></pre></td></tr></table></figure><p>所有商店的名称和费用，使用.loc运算符。</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>正规的情况下，drop函数不会更改DataFrame。相反，返回给你删除了指定行的的DataFrame的副本，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">copy_df=df.copy()</div><div class="line">copy_df=copy_df.drop(<span class="string">'Store 1'</span>)</div><div class="line">copy_df</div><div class="line"></div><div class="line">CostItem PurchasedName</div><div class="line">Store <span class="number">2</span><span class="number">2.5</span>Kitty LitterKevyn</div><div class="line">Store <span class="number">3</span><span class="number">5.0</span>Bird SeedVinod</div></pre></td></tr></table></figure><p>Drop有两个有趣的可选择的参数，第一个是inplace，如果设置为true，则DataFrame将被就地更新，而不是返回副本。第二个参数是axis，表示要删除的。正规的情况下，该值为0，表示row的轴向。但是，如果要删除column，则可以将其更改为1。</p><p>然而，有第二种方法去删除column，直接使用索引操作，使用del关键字，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">del</span>  copy_df[<span class="string">'Name'</span>]</div><div class="line">copy_df</div><div class="line"></div><div class="line">CostItem Purchased</div><div class="line">Store <span class="number">2</span><span class="number">2.5</span>Kitty Litter</div><div class="line">Store <span class="number">3</span><span class="number">5.0</span>Bird Seed</div></pre></td></tr></table></figure><p>立即生效，不返回视图。</p><p>最终，向DataFrame添加一个新column，将其指定某些值一样简单，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Location'</span>]=<span class="keyword">None</span></div><div class="line">df</div><div class="line"></div><div class="line">CostItem PurchasedNameLocation</div><div class="line">Store <span class="number">1</span><span class="number">22.5</span>Dog FoodChris<span class="keyword">None</span></div><div class="line">Store <span class="number">2</span><span class="number">2.5</span>Kitty LitterKevyn<span class="keyword">None</span></div><div class="line">Store <span class="number">3</span><span class="number">5.0</span>Bird SeedVinod<span class="keyword">None</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Cost'</span>]*=<span class="number">0.8</span></div></pre></td></tr></table></figure><p>改变所有Cost列中的值，为原来的80%。</p><p>###DataFrame Indexing and Loading</p><p>常见的工作流程是将数据读入DataFrame，然后将该DataFrame减少到特定的列（column）或行（row），你有兴趣处理的。如您所见，Pandas的工具组试图给你DataFrame的视图。这是比复制资料快得多，和更有效率的使用记忆体。</p><p>但是它的确一位着，如果你正在操作数据，则必须注意，任何更改在你处理的DataFrame，可能会对你最初使用的基本DataFrame产生影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">costs=df[<span class="string">'Cost'</span>]</div><div class="line">costs</div><div class="line"></div><div class="line">Store <span class="number">1</span>    <span class="number">22.5</span></div><div class="line">Store <span class="number">2</span>     <span class="number">2.5</span></div><div class="line">Store <span class="number">3</span>     <span class="number">5.0</span></div><div class="line">Name: Cost, dtype: float64</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">costs += <span class="number">2</span></div><div class="line">costs</div><div class="line"></div><div class="line">Store <span class="number">1</span>    <span class="number">24.5</span></div><div class="line">Store <span class="number">2</span>     <span class="number">4.5</span></div><div class="line">Store <span class="number">3</span>     <span class="number">7.0</span></div><div class="line">Name: Cost, dtype: float64</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df</div><div class="line"></div><div class="line">CostItem PurchasedName</div><div class="line">Store <span class="number">1</span><span class="number">24.5</span>Dog FoodChris</div><div class="line">Store <span class="number">2</span><span class="number">4.5</span>Kitty LitterKevyn</div><div class="line">Store <span class="number">3</span><span class="number">7.0</span>Bird SeedVinod</div></pre></td></tr></table></figure><p>这种更改对原表产生影响，所以必须要使用copy方法。</p><p>通常的工作流程是读取一些外部的文件数据集。我们以前看过如何使用Python，列表（list）和字典（dictionary）来做到这一点。你可以想象如何使用这些dictionary来创建一个Pandas的DataFrame。</p><p>使用惊叹号加上cat 与文件名来查看同级csv文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">!cat olympics.csv <span class="comment"># 这是一个csv数据文件</span></div></pre></td></tr></table></figure><p>这个命令会将其余命令发送到操作系统的shell。</p><p>cat命令可以运行在Linux和Mac平台上.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">df=pd.read_csv(<span class="string">"olympics.csv"</span>)</div><div class="line">df.head()</div><div class="line"></div><div class="line"><span class="number">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span><span class="number">6</span><span class="number">7</span><span class="number">8</span><span class="number">9</span><span class="number">10</span><span class="number">11</span><span class="number">12</span><span class="number">13</span><span class="number">14</span><span class="number">15</span></div><div class="line"><span class="number">0</span>NaN№ Summer<span class="number">01</span> !<span class="number">02</span> !<span class="number">03</span> !Total№ Winter<span class="number">01</span> !<span class="number">02</span> !<span class="number">03</span> !Total№ Games<span class="number">01</span> !<span class="number">02</span> !<span class="number">03</span> !Combined total</div><div class="line"><span class="number">1</span>Afghanistan (AFG)<span class="number">13</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">2</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">13</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">2</span></div><div class="line"><span class="number">2</span>Algeria (ALG)<span class="number">12</span><span class="number">5</span><span class="number">2</span><span class="number">8</span><span class="number">15</span><span class="number">3</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">15</span><span class="number">5</span><span class="number">2</span><span class="number">8</span><span class="number">15</span></div><div class="line"><span class="number">3</span>Argentina (ARG)<span class="number">23</span><span class="number">18</span><span class="number">24</span><span class="number">28</span><span class="number">70</span><span class="number">18</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">41</span><span class="number">18</span><span class="number">24</span><span class="number">28</span><span class="number">70</span></div><div class="line"><span class="number">4</span>Armenia (ARM)<span class="number">5</span><span class="number">1</span><span class="number">2</span><span class="number">9</span><span class="number">12</span><span class="number">6</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">11</span><span class="number">1</span><span class="number">2</span><span class="number">9</span><span class="number">12</span></div></pre></td></tr></table></figure><p>当我们看到DataFrames时，我们看到第一个单元格中有一个NaN，因为它是一个空值，并且这些行已经为我们自动编入索引（index）。</p><p>很明显，    DataFrames中的第一行（row）数据是我们真正希望看到的列名标签，数据中的第一列（column）似乎也是国家的名称，我们相用它来做成索引（index）。</p><p>读取csv有一些阐述，我们可以用它来指示Pandas如何来标记行与列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">df=pd.read_csv(<span class="string">'olympics.csv'</span>,index_col=<span class="number">0</span>,skiprows=<span class="number">1</span>)</div><div class="line">df.head()</div><div class="line"></div><div class="line">№ Summer<span class="number">01</span> !<span class="number">02</span> !<span class="number">03</span> !Total№ Winter<span class="number">01</span> !<span class="number">.1</span><span class="number">02</span> !<span class="number">.1</span><span class="number">03</span> !<span class="number">.1</span>Total<span class="number">.1</span>№ Games<span class="number">01</span> !<span class="number">.2</span><span class="number">02</span> !<span class="number">.2</span><span class="number">03</span> !<span class="number">.2</span>Combined total</div><div class="line">Afghanistan (AFG)<span class="number">13</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">2</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">13</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">2</span></div><div class="line">Algeria (ALG)<span class="number">12</span><span class="number">5</span><span class="number">2</span><span class="number">8</span><span class="number">15</span><span class="number">3</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">15</span><span class="number">5</span><span class="number">2</span><span class="number">8</span><span class="number">15</span></div><div class="line">Argentina (ARG)<span class="number">23</span><span class="number">18</span><span class="number">24</span><span class="number">28</span><span class="number">70</span><span class="number">18</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">41</span><span class="number">18</span><span class="number">24</span><span class="number">28</span><span class="number">70</span></div><div class="line">Armenia (ARM)<span class="number">5</span><span class="number">1</span><span class="number">2</span><span class="number">9</span><span class="number">12</span><span class="number">6</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">11</span><span class="number">1</span><span class="number">2</span><span class="number">9</span><span class="number">12</span></div><div class="line">Australasia (ANZ) [ANZ]<span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span><span class="number">12</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span><span class="number">12</span></div></pre></td></tr></table></figure><p>设置国家为索引值，并跳过第一行数据，从第二行数据开始读取。</p><p>这个数据来自维基百科的所有奥运会奖牌，如果我们来到这个页面，我们可以看到，这些页面没有用金，银和铜牌，而是用一个漂亮的小圆标，加上一个1，一个2，一个3在里面。在我们的csv文件中，它们用字串01！来表示，我们看到列（column）的值被重复，这真的不是很好的做法，Pandas加上了.1和.2，使标示更加独特，但是这个标示并不是很清楚，所以我们应该清理数据文件。我们当然可以直接通过直接编辑CSV文件来实现，但是我们也可以使用Pandas name属性设置列的名称.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</div><div class="line">    <span class="keyword">if</span> col[:<span class="number">2</span>]==<span class="string">'01'</span>:</div><div class="line">        df.rename(columns=&#123;col:<span class="string">'Gold'</span>+col[<span class="number">4</span>:]&#125;,inplace=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">if</span> col[:<span class="number">2</span>]==<span class="string">'02'</span>:</div><div class="line">        df.rename(columns=&#123;col:<span class="string">'Silver'</span>+col[<span class="number">4</span>:]&#125;,inplace=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">if</span> col[:<span class="number">2</span>]==<span class="string">'03'</span>:</div><div class="line">        df.rename(columns=&#123;col:<span class="string">'Bronze'</span>+col[<span class="number">4</span>:]&#125;,inplace=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">if</span> col[:<span class="number">1</span>]==<span class="string">'№'</span>:</div><div class="line">        df.rename(columns=&#123;col:<span class="string">'#'</span>+col[<span class="number">4</span>:]&#125;,inplace=<span class="keyword">True</span>)</div><div class="line">        </div><div class="line">df.head()</div><div class="line"></div><div class="line"><span class="comment">#mmerGoldSilverBronzeTotal#nterGold.1Silver.1Bronze.1Total.1#mesGold.2Silver.2Bronze.2Combined total</span></div><div class="line">Afghanistan (AFG)<span class="number">13</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">2</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">13</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">2</span></div><div class="line">Algeria (ALG)<span class="number">12</span><span class="number">5</span><span class="number">2</span><span class="number">8</span><span class="number">15</span><span class="number">3</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">15</span><span class="number">5</span><span class="number">2</span><span class="number">8</span><span class="number">15</span></div><div class="line">Argentina (ARG)<span class="number">23</span><span class="number">18</span><span class="number">24</span><span class="number">28</span><span class="number">70</span><span class="number">18</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">41</span><span class="number">18</span><span class="number">24</span><span class="number">28</span><span class="number">70</span></div><div class="line">Armenia (ARM)<span class="number">5</span><span class="number">1</span><span class="number">2</span><span class="number">9</span><span class="number">12</span><span class="number">6</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">11</span><span class="number">1</span><span class="number">2</span><span class="number">9</span><span class="number">12</span></div><div class="line">Australasia (ANZ) [ANZ]<span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span><span class="number">12</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">0</span><span class="number">2</span><span class="number">3</span><span class="number">4</span><span class="number">5</span><span class="number">12</span></div></pre></td></tr></table></figure><h3 id="Querying-a-DataFrame"><a href="#Querying-a-DataFrame" class="headerlink" title="Querying a DataFrame"></a>Querying a DataFrame</h3><p>在谈论如何查询DataFrames之前，我们需要谈论布林boolean遮蔽masking。</p><p>布林遮蔽是Numpy快速高效查询的核心，它类似于在其他计算领域使用的遮蔽（masking）。</p><p>布林遮罩是一个阵列（array），它可以是一维度像一个列表（series），或者二维度像DateFrames这样的，阵列中的每个值都是true或false。这个阵列（array</p><p>)基本上覆盖在我们查询的数据结构之上。任何单元格与true都将被允许进入我们的最终结果，任何单元格与false对齐的就不能够。</p><p>布林遮蔽在概念上是强大的，是高效地Numpy和Pandas查询的基石。这种技术在计算机科学中的其他领域被广泛的使用，例如图形学，但是在其他传统的关联数据库中并没有类似的，所以我认为这里值得一提。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-04%20%E4%B8%8B%E5%8D%889.13.10.png" alt="image"></p><p>创建布林遮罩通过将操作符直接应用于Pandas列表或DataFrame对象。例如，在我们的奥运数据集中，您可能只想看到在夏季奥运会上获得金牌的国家。要创建此查询的布林遮罩，我们投影金牌（’GOLD’)列，使用索引运算符，并应用比较值为大于零的运算符。这实际上是广播比较（comparison）运算符，大于（&gt;），其结果为布林（Boolean）系列。所得到的是有索引的系列，每个单元格是True或False，根据一个国家是否赢得了至少一枚金牌，并且索引是国家名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Gold'</span>]&gt;<span class="number">0</span></div><div class="line"></div><div class="line">Afghanistan (AFG)                               <span class="keyword">False</span></div><div class="line">Algeria (ALG)                                    <span class="keyword">True</span></div><div class="line">Argentina (ARG)                                  <span class="keyword">True</span></div><div class="line">Armenia (ARM)                                    <span class="keyword">True</span></div><div class="line">Australasia (ANZ) [ANZ]                          <span class="keyword">True</span></div><div class="line">Australia (AUS) [AUS] [Z]                        <span class="keyword">True</span></div><div class="line">Austria (AUT)                                    <span class="keyword">True</span></div><div class="line">Azerbaijan (AZE)                                 <span class="keyword">True</span></div><div class="line">Bahamas (BAH)                                    <span class="keyword">True</span></div><div class="line">Bahrain (BRN)                                   <span class="keyword">False</span></div><div class="line">Barbados (BAR) [BAR]                            <span class="keyword">False</span></div><div class="line">Belarus (BLR)                                    <span class="keyword">True</span></div><div class="line">Belgium (BEL)                                    <span class="keyword">True</span></div><div class="line">Bermuda (BER)                                   <span class="keyword">False</span></div><div class="line">Bohemia (BOH) [BOH] [Z]                         <span class="keyword">False</span></div><div class="line">Botswana (BOT)                                  <span class="keyword">False</span></div><div class="line">Brazil (BRA)                                     <span class="keyword">True</span></div><div class="line">British West Indies (BWI) [BWI]                 <span class="keyword">False</span></div><div class="line">Bulgaria (BUL) [H]                               <span class="keyword">True</span></div><div class="line">Burundi (BDI)                                    <span class="keyword">True</span></div><div class="line">Cameroon (CMR)                                   <span class="keyword">True</span></div><div class="line">Canada (CAN)                                     <span class="keyword">True</span></div><div class="line">Chile (CHI) [I]                                  <span class="keyword">True</span></div><div class="line">China (CHN) [CHN]                                <span class="keyword">True</span></div><div class="line">Colombia (COL)                                   <span class="keyword">True</span></div><div class="line">Costa Rica (CRC)                                 <span class="keyword">True</span></div><div class="line">Ivory Coast (CIV) [CIV]                         <span class="keyword">False</span></div><div class="line">Croatia (CRO)                                    <span class="keyword">True</span></div><div class="line">Cuba (CUB) [Z]                                   <span class="keyword">True</span></div><div class="line">Cyprus (CYP)                                    <span class="keyword">False</span></div><div class="line">                                                ...  </div><div class="line">Sri Lanka (SRI) [SRI]                           <span class="keyword">False</span></div><div class="line">Sudan (SUD)                                     <span class="keyword">False</span></div><div class="line">Suriname (SUR) [E]                               <span class="keyword">True</span></div><div class="line">Sweden (SWE) [Z]                                 <span class="keyword">True</span></div><div class="line">Switzerland (SUI)                                <span class="keyword">True</span></div><div class="line">Syria (SYR)                                      <span class="keyword">True</span></div><div class="line">Chinese Taipei (TPE) [TPE] [TPE2]                <span class="keyword">True</span></div><div class="line">Tajikistan (TJK)                                <span class="keyword">False</span></div><div class="line">Tanzania (TAN) [TAN]                            <span class="keyword">False</span></div><div class="line">Thailand (THA)                                   <span class="keyword">True</span></div><div class="line">Togo (TOG)                                      <span class="keyword">False</span></div><div class="line">Tonga (TGA)                                     <span class="keyword">False</span></div><div class="line">Trinidad <span class="keyword">and</span> Tobago (TRI) [TRI]                  <span class="keyword">True</span></div><div class="line">Tunisia (TUN)                                    <span class="keyword">True</span></div><div class="line">Turkey (TUR)                                     <span class="keyword">True</span></div><div class="line">Uganda (UGA)                                     <span class="keyword">True</span></div><div class="line">Ukraine (UKR)                                    <span class="keyword">True</span></div><div class="line">United Arab Emirates (UAE)                       <span class="keyword">True</span></div><div class="line">United States (USA) [P] [Q] [R] [Z]              <span class="keyword">True</span></div><div class="line">Uruguay (URU)                                    <span class="keyword">True</span></div><div class="line">Uzbekistan (UZB)                                 <span class="keyword">True</span></div><div class="line">Venezuela (VEN)                                  <span class="keyword">True</span></div><div class="line">Vietnam (VIE)                                   <span class="keyword">False</span></div><div class="line">Virgin Islands (ISV)                            <span class="keyword">False</span></div><div class="line">Yugoslavia (YUG) [YUG]                           <span class="keyword">True</span></div><div class="line">Independent Olympic Participants (IOP) [IOP]    <span class="keyword">False</span></div><div class="line">Zambia (ZAM) [ZAM]                              <span class="keyword">False</span></div><div class="line">Zimbabwe (ZIM) [ZIM]                             <span class="keyword">True</span></div><div class="line">Mixed team (ZZX) [ZZX]                           <span class="keyword">True</span></div><div class="line">Totals                                           <span class="keyword">True</span></div><div class="line">Name: Gold, dtype: bool</div></pre></td></tr></table></figure><p>所以我们建立了布林遮罩，然而这只是一半而已。接下来我们要做的是覆盖该遮罩（mask）在DataFrame上。我们可以使用where函数来做到这一点。where函数将布林遮罩作为条件，将其应用于DataFrame或series，并返回一个相同形状的新DataFrame或series。我们将这个布林遮罩应用于我们的奥运数据，并创建一个DataFrame，只有那些在夏季比赛中赢得金牌的国家。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">only_gold=df.where(df[<span class="string">'Gold'</span>]&gt;<span class="number">0</span>)</div><div class="line">only_gold.head()</div><div class="line"></div><div class="line"><span class="comment">#mmerGoldSilverBronzeTotal#nterGold.1Silver.1Bronze.1Total.1#mesGold.2Silver.2Bronze.2Combined total</span></div><div class="line">Afghanistan (AFG)NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaN</div><div class="line">Algeria (ALG)<span class="number">12.0</span><span class="number">5.0</span><span class="number">2.0</span><span class="number">8.0</span><span class="number">15.0</span><span class="number">3.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">15.0</span><span class="number">5.0</span><span class="number">2.0</span><span class="number">8.0</span><span class="number">15.0</span></div><div class="line">Argentina (ARG)<span class="number">23.0</span><span class="number">18.0</span><span class="number">24.0</span><span class="number">28.0</span><span class="number">70.0</span><span class="number">18.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">41.0</span><span class="number">18.0</span><span class="number">24.0</span><span class="number">28.0</span><span class="number">70.0</span></div><div class="line">Armenia (ARM)<span class="number">5.0</span><span class="number">1.0</span><span class="number">2.0</span><span class="number">9.0</span><span class="number">12.0</span><span class="number">6.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">11.0</span><span class="number">1.0</span><span class="number">2.0</span><span class="number">9.0</span><span class="number">12.0</span></div><div class="line">Australasia (ANZ) [ANZ]<span class="number">2.0</span><span class="number">3.0</span><span class="number">4.0</span><span class="number">5.0</span><span class="number">12.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">2.0</span><span class="number">3.0</span><span class="number">4.0</span><span class="number">5.0</span><span class="number">12.0</span></div></pre></td></tr></table></figure><p>我们看到产生的DataFrame保留了原始的索引，只保留了满足条件的国家/地区的数据。所有不符合条件的国家只有NaN数据。大多数DataFrame内置的统计功能忽略NaN的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">only_gold[<span class="string">'Gold'</span>].count()</div><div class="line"></div><div class="line"><span class="number">100</span></div></pre></td></tr></table></figure><p>我们看到有100个国家在夏季奥运中获得了金牌。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df[<span class="string">'Gold'</span>].count()</div><div class="line"></div><div class="line"><span class="number">147</span></div></pre></td></tr></table></figure><p>如果我们在df上使用count，有147个国家总数。</p><p>如果我们想删除没有数据的行，我们可以使用dropna（）功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">only_gold=only_gold.dropna()</div><div class="line">only_gold.head()</div><div class="line"></div><div class="line"><span class="comment">#mmerGoldSilverBronzeTotal#nterGold.1Silver.1Bronze.1Total.1#mesGold.2Silver.2Bronze.2Combined total</span></div><div class="line">Algeria (ALG)<span class="number">12.0</span><span class="number">5.0</span><span class="number">2.0</span><span class="number">8.0</span><span class="number">15.0</span><span class="number">3.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">15.0</span><span class="number">5.0</span><span class="number">2.0</span><span class="number">8.0</span><span class="number">15.0</span></div><div class="line">Argentina (ARG)<span class="number">23.0</span><span class="number">18.0</span><span class="number">24.0</span><span class="number">28.0</span><span class="number">70.0</span><span class="number">18.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">41.0</span><span class="number">18.0</span><span class="number">24.0</span><span class="number">28.0</span><span class="number">70.0</span></div><div class="line">Armenia (ARM)<span class="number">5.0</span><span class="number">1.0</span><span class="number">2.0</span><span class="number">9.0</span><span class="number">12.0</span><span class="number">6.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">11.0</span><span class="number">1.0</span><span class="number">2.0</span><span class="number">9.0</span><span class="number">12.0</span></div><div class="line">Australasia (ANZ) [ANZ]<span class="number">2.0</span><span class="number">3.0</span><span class="number">4.0</span><span class="number">5.0</span><span class="number">12.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">0.0</span><span class="number">2.0</span><span class="number">3.0</span><span class="number">4.0</span><span class="number">5.0</span><span class="number">12.0</span></div><div class="line">Australia (AUS) [AUS] [Z]<span class="number">25.0</span><span class="number">139.0</span><span class="number">152.0</span><span class="number">177.0</span><span class="number">468.0</span><span class="number">18.0</span><span class="number">5.0</span><span class="number">3.0</span><span class="number">4.0</span><span class="number">12.0</span><span class="number">43.0</span><span class="number">144.0</span><span class="number">155.0</span><span class="number">181.0</span><span class="number">480.0</span></div></pre></td></tr></table></figure><p>当你发现自己在谈论Pandas，说’我常常想要用‘，很可能开发人员已经包含了捷径，为这些常用操作。例如，在这个例子中，我们实际上并不需要明确地使用where函数。Pandas开发人员允许索引运算元使用布林遮罩作为值，而不是列名称列表。语法可能看起来有点混乱，特别是如果您不习惯使用重载（overload）运算符的程序语言，但结果是您可以相对较快地过滤和减少DataFrames。</p><p>要牢记一点，如果你不习惯使用布林（boolean）或位（bit）遮蔽来减少数据两个遮罩，当进行逻辑比较运算，其输出是另一个布林遮罩。这意味着你可以链接一堆and/or语句以创建更复杂的查询，结果仍然是单个布林遮罩。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">len(df[(df[<span class="string">'Gold'</span>]&gt;<span class="number">0</span>) | df[<span class="string">'Gold.1'</span>]&gt;<span class="number">0</span>])</div><div class="line"><span class="number">101</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[(df[<span class="string">'Gold.1'</span>]&gt;<span class="number">0</span>) &amp; (df[<span class="string">'Gold.1'</span>]==<span class="number">0</span>)]</div></pre></td></tr></table></figure><p>这选出了在夏季奥运会没有金牌的国家，但是在秋季奥运会有金牌。</p><p>要记住，每个布林遮罩需要被包含在括号中。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;The-DataFrame-Data-Structure&quot;&gt;&lt;a href=&quot;#The-DataFrame-Data-Structure&quot; class=&quot;headerlink&quot; title=&quot;The DataFrame Data Structure&quot;&gt;&lt;/a&gt;The DataFrame Data Structure&lt;/h3&gt;&lt;p&gt;DataFrame数据结构是Pandas的核心，这将是你的主要对象，在处理数据分析和数据清理任务的时候。DataFrame在概念上是一个二维列表series对象，其中有一个索引（index）和多列内容，每列（column）都有一个标识（label）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-01%20%E4%B8%8B%E5%8D%8812.30.47.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;你可以将DataFrame本身视为简单的双轴有标识的阵列，你可以以许多不同的方式创建一个DataFrame，其中，你可以使用一组series，其中每个列表代表一行数据。或者你可以使用一组字典（dictionary），
    
    </summary>
    
      <category term="数据分析" scheme="http://adamzeng.site/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://adamzeng.site/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>pandas的初步认识</title>
    <link href="http://adamzeng.site/2017/12/31/pandas%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/"/>
    <id>http://adamzeng.site/2017/12/31/pandas的初步认识/</id>
    <published>2017-12-31T09:20:01.000Z</published>
    <updated>2018-01-01T03:42:19.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作、清理和查询资料使用Pandas工具库"><a href="#操作、清理和查询资料使用Pandas工具库" class="headerlink" title="操作、清理和查询资料使用Pandas工具库"></a>操作、清理和查询资料使用Pandas工具库</h3><ul><li><p>Created in 2008 by Wes McKinney</p></li><li><p>Open source New BSD license</p></li><li><p>100 different contributors</p></li><li><p>Heavily used by pandas developers instead of a mailing list</p></li><li><p><a href="http://stackoverflow.com" target="_blank" rel="noopener">http://stackoverflow.com</a> pandas社群使用它来当做第一资源</p></li><li><p>Learning the Pandas Library</p></li><li><p><a href="http://planetpython.org/" target="_blank" rel="noopener">http://planetpython.org/</a></p></li><li><p>Excellent blog aggregator for python related news</p></li><li><p>Significant number of data science and python tutorials are posted</p></li><li><p>Great blend of applied beginner and higher level python postings</p></li><li><p><a href="http://dataskeptic.com/" target="_blank" rel="noopener">http://dataskeptic.com/</a></p></li><li><p>Kyle Polich,created in 2014</p></li><li><p>Covers data science more</p><p>generally,including:</p><ul><li>Mini educational lessons</li><li>Interviews</li><li>Trends</li><li>Shared community project(OpenHourse)<a id="more"></a></li></ul></li></ul><p>Series是Pandas中的核心数据结构之一，你可以想象一下相交于列表（list）和字典（dictionary）之间。这些项目都按照顺序储存，并且有标识可以从中检索。一个简单的方法去想象，它是两列数据。第一栏是特殊的索引，很像字典dictionary的key。而第二栏则是你真实的数据。重要的是注意资料栏位也有自己的标识，可以透过.name来取得，这与dictionary不同，在合并多列数据时很有用，我们稍后再谈谈。你可能会预期，可以透过传入一个list的值来新创一个Series，当你这么做时，Pandas会自动从零开始分配索引，并将该series的名称设置为“None”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">animals=[<span class="string">'Tiger'</span>,<span class="string">'Bear'</span>,<span class="string">'Moose'</span>]</div><div class="line">pd.Series(animals)</div><div class="line"></div><div class="line"><span class="number">0</span>    Tiger</div><div class="line"><span class="number">1</span>     Bear</div><div class="line"><span class="number">2</span>    Moose</div><div class="line">dtype: object</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">pd.Series(numbers)</div><div class="line"></div><div class="line"><span class="number">0</span>    <span class="number">1</span></div><div class="line"><span class="number">1</span>    <span class="number">2</span></div><div class="line"><span class="number">2</span>    <span class="number">3</span></div><div class="line">dtype: int64</div></pre></td></tr></table></figure><p>最重要的是Numpy和Pandas如何处理遗失的资料，在Python中，我们有none type以表示资料缺失。但是我们该怎么做，如果我们想要有一个类型的list，像我们在series object，在内部，pandas会执行一些类型转换.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">animals=[<span class="string">'Tiger'</span>,<span class="string">'Bear'</span>,<span class="keyword">None</span>]</div><div class="line">pd.Series(animals)</div><div class="line"></div><div class="line"><span class="number">0</span>    Tiger</div><div class="line"><span class="number">1</span>     Bear</div><div class="line"><span class="number">2</span>     <span class="keyword">None</span></div><div class="line">dtype: object</div></pre></td></tr></table></figure><p>如果我们创建一个list的strings，而我们有一个元素是None类型，pandas将它作为None，并使用object的类型在内部阵列。如果我们创建一个数字，整数或浮点的列表，并放入None类型，Pandas会自动将其转换为特殊浮点值，指定为NaN,代表它不是一个数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="keyword">None</span>]</div><div class="line">pd.Series(numbers)</div><div class="line"></div><div class="line"><span class="number">0</span>    <span class="number">1.0</span></div><div class="line"><span class="number">1</span>    <span class="number">2.0</span></div><div class="line"><span class="number">2</span>    NaN</div><div class="line">dtype: float64</div></pre></td></tr></table></figure><p>对于那些没有用过Python科学计算的人，这是一个很重要的一点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">np.nan==<span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">np.isnan(np.nan)</div><div class="line"></div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure><p>请记住，当你看到Nan，它意思类似于none，但它是一个数值，它的区别对待是因为效率的原因。</p><p>series可以从dictionary数据来创建，如果这样做，你提供的dictionary的keys将自动指派成索引（index），而不仅仅是递增整数的index。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sports=&#123;<span class="string">'Archery'</span>:<span class="string">'Bhutan'</span>,</div><div class="line">       <span class="string">'Golf'</span>:<span class="string">'Scotland'</span>,</div><div class="line">       <span class="string">'Sumo'</span>:<span class="string">'Japan'</span>,</div><div class="line">       <span class="string">'Taekwondo'</span>:<span class="string">'South Korea'</span>&#125;</div><div class="line">s=pd.Series(sports)</div><div class="line">s</div><div class="line"></div><div class="line">Archery           Bhutan</div><div class="line">Golf            Scotland</div><div class="line">Sumo               Japan</div><div class="line">Taekwondo    South Korea</div><div class="line">dtype: object</div></pre></td></tr></table></figure><p>Pandas的Series（列表）可以查询，使用索引（index）的位置或索引的标记（label），正如我们所看到的，如果你不指派series的index，则位置和标识实际上是相同的值。要利用数位位置查询，从零开始，使用iloc属性。要通过索引标识进行查询，可以使用loc属性，以下是维基百科的全国体育赛事数据，假设我们想要列出所有的运动当我们的索引（index），和国家列表作为值（value）。你可以将这些保留在dictionary中，并按照我们以前讨论的方式创建一个series。</p><p>如果你想查看第四个国家，我们将使用iloc属性和参数，3，如果你想了解哪个国家将高尔夫作为其全国运动，我们将使用loc属性和参数’loc’。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s.iloc[<span class="number">3</span>]</div><div class="line"></div><div class="line"><span class="string">'South Korea'</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s.loc[<span class="string">'Golf'</span>]</div><div class="line"></div><div class="line"><span class="string">'Scotland'</span></div></pre></td></tr></table></figure><p>loc与iloc是属性而不是方法，所以你使用方括号[],而不是使用()来查询它们，我们称之为索引运算符。在Python中，这就叫做获取（get）和设置（set）一个项目的方法，根据其使用的背景来决定。这看起来可能有点困惑的，如果你习惯于语言在哪里封装在里面的，属性、变数和性能是常见的，比如在Java中。Pandas试图使我们的程式更具有可读性，并提供一种智慧语法，使用index操作符直接在series本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s[<span class="number">3</span>]</div><div class="line"></div><div class="line"><span class="string">'South Korea'</span></div></pre></td></tr></table></figure><p>例如，你传入一个整数参数，运算子会表现得好想你想要通过iloc属性来查询。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s[<span class="string">'Golf'</span>]</div><div class="line"></div><div class="line"><span class="string">'Scotland'</span></div></pre></td></tr></table></figure><p>如果你传入一个物件（object），它将认为你想要查询使用根据标识（label）的loc属性。</p><p>如果你的index是整数列表会发生什么呢？</p><p>这有点复杂，pandas无法自动确定你是打算通过索引位置或索引标识进行查询。所以在series本身使用index操作时，你需要小心，而更安全的选择是更加明确，直接使用iloc或loc属性。</p><h3 id="对于计算而言"><a href="#对于计算而言" class="headerlink" title="对于计算而言"></a>对于计算而言</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">total=<span class="number">0</span></div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> s:</div><div class="line">    total+=item</div><div class="line">print(total)</div><div class="line"></div><div class="line"><span class="number">324.0</span></div></pre></td></tr></table></figure><p>现代电脑可以同时执行许多任务，尤其是涉及数学的任务。</p><p>Pandas和基础的Numpy程序库支持一个称为向量化，Vectorization与Numpy库中的大部分功能一起使用，包括sum函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">total=np.sum(s)</div><div class="line">print(total)</div><div class="line"></div><div class="line"></div><div class="line"><span class="number">324.0</span></div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">s=pd.Series(np.random.randint(<span class="number">0</span>,<span class="number">1000</span>,<span class="number">10000</span>))</div><div class="line">print(s)</div><div class="line">s.head(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="number">0</span>       <span class="number">337</span></div><div class="line"><span class="number">1</span>       <span class="number">495</span></div><div class="line"><span class="number">2</span>       <span class="number">871</span></div><div class="line"><span class="number">3</span>       <span class="number">840</span></div><div class="line"><span class="number">4</span>       <span class="number">585</span></div><div class="line"><span class="number">5</span>       <span class="number">435</span></div><div class="line"><span class="number">6</span>       <span class="number">172</span></div><div class="line"><span class="number">7</span>       <span class="number">364</span></div><div class="line"><span class="number">8</span>       <span class="number">807</span></div><div class="line"><span class="number">9</span>       <span class="number">937</span></div><div class="line"><span class="number">10</span>      <span class="number">347</span></div><div class="line"><span class="number">11</span>      <span class="number">271</span></div><div class="line"><span class="number">12</span>       <span class="number">30</span></div><div class="line"><span class="number">13</span>      <span class="number">908</span></div><div class="line"><span class="number">14</span>      <span class="number">525</span></div><div class="line"><span class="number">15</span>      <span class="number">151</span></div><div class="line"><span class="number">16</span>       <span class="number">68</span></div><div class="line"><span class="number">17</span>      <span class="number">189</span></div><div class="line"><span class="number">18</span>      <span class="number">897</span></div><div class="line"><span class="number">19</span>      <span class="number">679</span></div><div class="line"><span class="number">20</span>      <span class="number">683</span></div><div class="line"><span class="number">21</span>      <span class="number">111</span></div><div class="line"><span class="number">22</span>      <span class="number">351</span></div><div class="line"><span class="number">23</span>      <span class="number">228</span></div><div class="line"><span class="number">24</span>      <span class="number">421</span></div><div class="line"><span class="number">25</span>      <span class="number">923</span></div><div class="line"><span class="number">26</span>      <span class="number">597</span></div><div class="line"><span class="number">27</span>      <span class="number">227</span></div><div class="line"><span class="number">28</span>      <span class="number">691</span></div><div class="line"><span class="number">29</span>      <span class="number">306</span></div><div class="line">       ... </div><div class="line"><span class="number">9970</span>    <span class="number">324</span></div><div class="line"><span class="number">9971</span>    <span class="number">124</span></div><div class="line"><span class="number">9972</span>    <span class="number">367</span></div><div class="line"><span class="number">9973</span>    <span class="number">557</span></div><div class="line"><span class="number">9974</span>    <span class="number">392</span></div><div class="line"><span class="number">9975</span>    <span class="number">158</span></div><div class="line"><span class="number">9976</span>    <span class="number">242</span></div><div class="line"><span class="number">9977</span>    <span class="number">437</span></div><div class="line"><span class="number">9978</span>    <span class="number">911</span></div><div class="line"><span class="number">9979</span>    <span class="number">503</span></div><div class="line"><span class="number">9980</span>     <span class="number">56</span></div><div class="line"><span class="number">9981</span>    <span class="number">836</span></div><div class="line"><span class="number">9982</span>    <span class="number">988</span></div><div class="line"><span class="number">9983</span>    <span class="number">796</span></div><div class="line"><span class="number">9984</span>    <span class="number">921</span></div><div class="line"><span class="number">9985</span>    <span class="number">214</span></div><div class="line"><span class="number">9986</span>    <span class="number">593</span></div><div class="line"><span class="number">9987</span>    <span class="number">426</span></div><div class="line"><span class="number">9988</span>    <span class="number">156</span></div><div class="line"><span class="number">9989</span>    <span class="number">509</span></div><div class="line"><span class="number">9990</span>    <span class="number">194</span></div><div class="line"><span class="number">9991</span>    <span class="number">161</span></div><div class="line"><span class="number">9992</span>    <span class="number">695</span></div><div class="line"><span class="number">9993</span>    <span class="number">601</span></div><div class="line"><span class="number">9994</span>     <span class="number">59</span></div><div class="line"><span class="number">9995</span>    <span class="number">965</span></div><div class="line"><span class="number">9996</span>    <span class="number">358</span></div><div class="line"><span class="number">9997</span>    <span class="number">696</span></div><div class="line"><span class="number">9998</span>     <span class="number">72</span></div><div class="line"><span class="number">9999</span>    <span class="number">172</span></div><div class="line">dtype: int64</div><div class="line">Out[<span class="number">18</span>]:</div><div class="line"><span class="number">0</span>    <span class="number">337</span></div><div class="line"><span class="number">1</span>    <span class="number">495</span></div><div class="line">dtype: int64</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">len(s)</div><div class="line"></div><div class="line"><span class="number">10000</span></div></pre></td></tr></table></figure><p>我们会使用所谓的细胞（cellular）魔术函数，这些以两个百分比的符号开始，并修改或包装当前Jupyter单元中的程式。我们要使用的函数称为timeit。你可能已经从名称猜到了，此函数会运行我们的程式几次，来确定，平均而言，他需要多长的时间。</p><p>让我们运行timeit，用我们原来的反复运算程式。你可以给timeit你希望运行的循环次数，在预设情况下，会设定1000次，在这里我要求timeit运行100次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">%%timeit -n <span class="number">100</span></div><div class="line">summary = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> s:</div><div class="line">    summary+=item</div><div class="line">    </div><div class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">4.07</span> ms per loop</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">%%timeit -n <span class="number">100</span></div><div class="line">summary = np.sum(s)</div><div class="line"></div><div class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">187</span> µs per loop</div></pre></td></tr></table></figure><p>速度差异巨大，使用向量化的sum运算功能非常强大。</p><p>在pandas和Numpy的相关的功能称为广播（broadcasting）。通过broadcasting，你可以对series中的每个值应用操作，更改series。</p><p>例如我想要对每一个值进行+2的处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">s += <span class="number">2</span></div><div class="line">s.head()<span class="comment"># check first five numbers</span></div><div class="line"></div><div class="line"><span class="number">0</span>    <span class="number">339</span></div><div class="line"><span class="number">1</span>    <span class="number">497</span></div><div class="line"><span class="number">2</span>    <span class="number">873</span></div><div class="line"><span class="number">3</span>    <span class="number">842</span></div><div class="line"><span class="number">4</span>    <span class="number">587</span></div><div class="line">dtype: int64</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> label, value <span class="keyword">in</span> s.iteritems():</div><div class="line">    s.set_value(label,value+<span class="number">2</span>)</div><div class="line">s.head()</div><div class="line"></div><div class="line"><span class="number">0</span>    <span class="number">341</span></div><div class="line"><span class="number">1</span>    <span class="number">499</span></div><div class="line"><span class="number">2</span>    <span class="number">875</span></div><div class="line"><span class="number">3</span>    <span class="number">844</span></div><div class="line"><span class="number">4</span>    <span class="number">589</span></div><div class="line">dtype: int64</div></pre></td></tr></table></figure><p>这是另外一种方式。</p><p>Pandas确实支持遍历迭代列表项目，很类似与dictionary，让你容易地把数值分拆开。但如果你发现自己反复遍历一列表，你应该质疑你做的方式是否是尽可能最好的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">%%timeit -n <span class="number">10</span></div><div class="line">s=pd.Series(np.random.randint(<span class="number">0</span>,<span class="number">1000</span>,<span class="number">10000</span>))</div><div class="line"><span class="keyword">for</span> label, value <span class="keyword">in</span> s.iteritems():</div><div class="line">    s.loc[label]=value+<span class="number">2</span></div><div class="line">    </div><div class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">2.36</span> s per loop</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%%timeit -n <span class="number">10</span></div><div class="line">s = pd.Series(np.random.randint(<span class="number">0</span>,<span class="number">1000</span>,<span class="number">10000</span>))</div><div class="line">s+=<span class="number">2</span></div><div class="line"></div><div class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">1</span> ms per loop</div></pre></td></tr></table></figure><p>相比而言，不仅是明显的变快，而它是更简洁和甚至更容易去读。你预期的典型数学运算是向量化的，和Numpy文档概述了创建你自己的向量化的函数所需要怎么做。最后一点要注意的，在使用索引运算来存取列表资料。.loc属性（attribute）让你不仅可以修改数据，还可以添加新数据。如果作为索引传入的值不存在，则它会添加一个新条目。请记住，指数可以有混合类型。虽然重要的是，要注意在下面的类型是什么，Pandas会根据需要，自动更改基本的Numpy类型。</p><p>我们可以添加一些新的数值，也许是一种动物，如你所知，我喜欢熊。然后调用.loc索引操作。我们看到数据值或索引标识的混合类型，对于Pandas来说是没有问题的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">s=pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">s.loc[<span class="string">'Animal'</span>]=<span class="string">'Bears'</span></div><div class="line">s</div><div class="line"></div><div class="line"><span class="number">0</span>             <span class="number">1</span></div><div class="line"><span class="number">1</span>             <span class="number">2</span></div><div class="line"><span class="number">2</span>             <span class="number">3</span></div><div class="line">Animal    Bears</div><div class="line">dtype: object</div></pre></td></tr></table></figure><p>到目前为止，我只显示了索引值是唯一的，我想要结束这节课，展示一个索引值不是唯一的例子，这使得dataframe（资料框），从概念上讲，可能不同于关联数据库（database）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">original_sports = pd.Series(&#123;<span class="string">'Archery'</span>: <span class="string">'Bhutan'</span>,</div><div class="line">                             <span class="string">'Golf'</span>: <span class="string">'Scotland'</span>,</div><div class="line">                             <span class="string">'Sumo'</span>: <span class="string">'Japan'</span>,</div><div class="line">                             <span class="string">'Taekwondo'</span>: <span class="string">'South Korea'</span>&#125;)</div><div class="line">cricket_loving_countries = pd.Series([<span class="string">'Australia'</span>,</div><div class="line">                                      <span class="string">'Barbados'</span>,</div><div class="line">                                      <span class="string">'Pakistan'</span>,</div><div class="line">                                      <span class="string">'England'</span>], </div><div class="line">                                   index=[<span class="string">'Cricket'</span>,</div><div class="line">                                          <span class="string">'Cricket'</span>,</div><div class="line">                                          <span class="string">'Cricket'</span>,</div><div class="line">                                          <span class="string">'Cricket'</span>])</div><div class="line">all_countries = original_sports.append(cricket_loving_countries)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">original_sports </div><div class="line">Archery           Bhutan</div><div class="line">Golf            Scotland</div><div class="line">Sumo               Japan</div><div class="line">Taekwondo    South Korea</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cricket_loving_countries</div><div class="line"></div><div class="line">Cricket        Australia</div><div class="line">Cricket         Barbados</div><div class="line">Cricket         Pakistan</div><div class="line">Cricket          England</div><div class="line">dtype: object</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">all_countries</div><div class="line"></div><div class="line">Archery           Bhutan</div><div class="line">Golf            Scotland</div><div class="line">Sumo               Japan</div><div class="line">Taekwondo    South Korea</div><div class="line">Cricket        Australia</div><div class="line">Cricket         Barbados</div><div class="line">Cricket         Pakistan</div><div class="line">Cricket          England</div><div class="line">dtype: object</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;操作、清理和查询资料使用Pandas工具库&quot;&gt;&lt;a href=&quot;#操作、清理和查询资料使用Pandas工具库&quot; class=&quot;headerlink&quot; title=&quot;操作、清理和查询资料使用Pandas工具库&quot;&gt;&lt;/a&gt;操作、清理和查询资料使用Pandas工具库&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Created in 2008 by Wes McKinney&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Open source New BSD license&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;100 different contributors&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Heavily used by pandas developers instead of a mailing list&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://stackoverflow.com&lt;/a&gt; pandas社群使用它来当做第一资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Learning the Pandas Library&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://planetpython.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://planetpython.org/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Excellent blog aggregator for python related news&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Significant number of data science and python tutorials are posted&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Great blend of applied beginner and higher level python postings&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://dataskeptic.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dataskeptic.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Kyle Polich,created in 2014&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Covers data science more&lt;/p&gt;
&lt;p&gt;generally,including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mini educational lessons&lt;/li&gt;
&lt;li&gt;Interviews&lt;/li&gt;
&lt;li&gt;Trends&lt;/li&gt;
&lt;li&gt;Shared community project(OpenHourse)
    
    </summary>
    
      <category term="数据分析" scheme="http://adamzeng.site/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://adamzeng.site/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>关于Python数据分析初解</title>
    <link href="http://adamzeng.site/2017/12/28/%E5%85%B3%E4%BA%8EPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%9D%E8%A7%A3/"/>
    <id>http://adamzeng.site/2017/12/28/关于Python数据分析初解/</id>
    <published>2017-12-28T14:54:21.000Z</published>
    <updated>2017-12-30T15:38:47.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><ul><li><p>Draw Conway perspective on data science:<a id="more"></a></p><ul><li>Hacking Skills</li><li>Math and Statistics Knowledge</li><li>Substantive Expertise</li></ul></li><li><p>Other data science perspectives:</p><ul><li><p>Skepticism,experimentation,</p><p>simulation,and replication</p></li></ul></li></ul><p>Data science:</p><ul><li>Data Exploration and Preparation</li><li>Data Representation and Transformation</li><li>Computing with Data</li><li>Data Modeling</li><li>Data Visualization and Presentation</li><li>Science about Data Science</li></ul><p>在课程中，讲师有一句强调的话，slicing is the core of Python language!也就是说切片是Python语言的核心，它是整个数据科学的基础。特别当你开始进行matrix的操作时。</p><p>插入format版的代码更加易于使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sales_record=&#123;<span class="string">'price'</span>: <span class="number">3.24</span>,</div><div class="line">             <span class="string">'num_items'</span>: <span class="number">4</span>,</div><div class="line">             <span class="string">'person'</span>: <span class="string">'Chris'</span>&#125;</div><div class="line"></div><div class="line">sales_statement=<span class="string">'&#123;&#125; bought &#123;&#125; item(s) at price of &#123;&#125; each for a total of &#123;&#125;'</span></div><div class="line"></div><div class="line">print(sales_statement.format(sales_record[<span class="string">'person'</span>],</div><div class="line">                            sales_record[<span class="string">'num_items'</span>],</div><div class="line">                            sales_record[<span class="string">'price'</span>],</div><div class="line">                            sales_record[<span class="string">'num_items'</span>]*sales_record[<span class="string">'price'</span>]))</div></pre></td></tr></table></figure><h3 id="关于时间与日期"><a href="#关于时间与日期" class="headerlink" title="关于时间与日期"></a>关于时间与日期</h3><p>在一定给定时间，找到销售平均次数，选择产品列表，来做资料数据挖掘，用在特定时期内的购买数据，或试图找到最活跃的时期在线上讨论论坛系统。</p><p>用于存储日期最常用的传统方法之一，时间在网上交易系统是基于从纪元的偏移量，这个纪元是1970年1月1日。这里有很多历史记录，但并不罕见看到系统存储自该日期起的交易时间（用秒或毫秒）。所以如果你看到很大的数字，而你希望看到日期和时间，你需要转换它们，使数据变得有意义。</p><p>在Python中，你可以获得从纪元计算来的目前时间，使用时间模组。然后，可以创建时间戳记，使用‘从时间戳记函数’在日期时间的物件。</p><p>time module 中time.time()返回当前时间的时间戳（1970纪元后经过的浮点秒数）。</p><h3 id="timestamp转换为datetime"><a href="#timestamp转换为datetime" class="headerlink" title="timestamp转换为datetime"></a>timestamp转换为datetime</h3><p>要把timestamp转换为<code>datetime</code>，使用<code>datetime</code>提供的<code>fromtimestamp()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line">t=<span class="number">1429417200.0</span></div><div class="line">print(datetime.fromtimestamp(t))</div><div class="line"></div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></div></pre></td></tr></table></figure><h3 id="Advanced-Python-Objects-map"><a href="#Advanced-Python-Objects-map" class="headerlink" title="Advanced Python Objects,map()"></a>Advanced Python Objects,map()</h3><p>了解map函数的官方定义：</p><p>map(function,iterable,…)</p><p>Return an iterator that applies function to every item of iterable,yielding the results. If additional iterable arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inpits are already arranged into argument tuples, see itertools.starmap().</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">store1=[<span class="number">10.00</span>,<span class="number">11.00</span>,<span class="number">12.34</span>,<span class="number">2.34</span>]</div><div class="line">store2=[<span class="number">9.00</span>,<span class="number">11.10</span>,<span class="number">12.34</span>,<span class="number">2.01</span>]</div><div class="line">cheapest=map(min,store1,store2)</div><div class="line">cheapest</div><div class="line"></div><div class="line"></div><div class="line">&lt;map at <span class="number">0x7faf8c2c7240</span>&gt;</div></pre></td></tr></table></figure><p>map是可以反复运算，就像列表和元组，因此我们可以使用for loop来迭代来查看map中的所有值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">people = [<span class="string">'Dr. Christopher Brooks'</span>, <span class="string">'Dr. Kevyn Collins-Thompson'</span>, <span class="string">'Dr. VG Vinod Vydiswaran'</span>, <span class="string">'Dr. Daniel Romero'</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_title_and_name</span><span class="params">(person)</span>:</span></div><div class="line">    titles=person.split(<span class="string">" "</span>)[<span class="number">0</span>]</div><div class="line">    last_names=person.split(<span class="string">" "</span>)[<span class="number">2</span>]</div><div class="line">    <span class="keyword">return</span> titles,last_names<span class="comment">#Your answer here</span></div><div class="line"></div><div class="line">print(list(map(split_title_and_name,people)))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">[(<span class="string">'Dr.'</span>, <span class="string">'Brooks'</span>), (<span class="string">'Dr.'</span>, <span class="string">'Collins-Thompson'</span>), (<span class="string">'Dr.'</span>, <span class="string">'Vinod'</span>), (<span class="string">'Dr.'</span>, <span class="string">'Romero'</span>)]</div></pre></td></tr></table></figure><h3 id="Advanced-Python-Lambda-and-List-Comprehensions"><a href="#Advanced-Python-Lambda-and-List-Comprehensions" class="headerlink" title="Advanced Python Lambda and List Comprehensions"></a>Advanced Python Lambda and List Comprehensions</h3><p>Lambda是Python的方法创建不具名函数。这些与其他函数相同，但没有名称，意图在于它们很简单或短暂使用，它容易，只需要在一行中就能够写出函数，而不必麻烦的去创建一个有名称函数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">my_function=<span class="keyword">lambda</span> a, b, c : a + b</div><div class="line">my_function(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure><p>相比完善的函数定义，lambda只能用于单个计算式，而且不能设默认值。</p><p>但我认为在简单的小数据清理任务，它们是非常有用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">people = [<span class="string">'Dr. Christopher Brooks'</span>, <span class="string">'Dr. Kevyn Collins-Thompson'</span>, <span class="string">'Dr. VG Vinod Vydiswaran'</span>, <span class="string">'Dr. Daniel Romero'</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_title_and_name</span><span class="params">(person)</span>:</span></div><div class="line">    <span class="keyword">return</span> person.split()[<span class="number">0</span>] + <span class="string">' '</span> + person.split()[<span class="number">-1</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># option 1</span></div><div class="line"><span class="keyword">for</span> person <span class="keyword">in</span> people:</div><div class="line">    print(split_title_and_name(person) == (<span class="keyword">lambda</span> x: x.split()[<span class="number">0</span>] + <span class="string">' '</span> + x.split()[<span class="number">-1</span>])(person))</div><div class="line"></div><div class="line">    <span class="comment"># option 2</span></div><div class="line">    <span class="comment"># list(map(split_title_and_name, people)) == list(map(???))</span></div><div class="line">print(list(map(split_title_and_name,people))==list(map(<span class="keyword">lambda</span> x: x.split()[<span class="number">0</span>]+<span class="string">' '</span>+x.split()[<span class="number">-1</span>],people)))</div><div class="line"></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure><p>sequence(序列)是我们可以遍历的结构和往往我们创建这些经由loop或从一个文件当中读取数据资料。</p><p>list comprehensions是类似lambda的浓缩格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my_list=[]</div><div class="line"><span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">1000</span>):</div><div class="line">    <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span>:</div><div class="line">        my_list.append(number)</div><div class="line">    </div><div class="line">my_list</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my_list=[number <span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">1000</span>) <span class="keyword">if</span> number % <span class="number">2</span> ==<span class="number">0</span>]</div><div class="line">my_list</div></pre></td></tr></table></figure><p>有一个例题：（我认为很有代表性）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lowercase = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></div><div class="line">digits = <span class="string">'0123456789'</span></div><div class="line"></div><div class="line">answer = [a+b+c+d <span class="keyword">for</span> a <span class="keyword">in</span> lowercase <span class="keyword">for</span> b <span class="keyword">in</span> lowercase <span class="keyword">for</span> c <span class="keyword">in</span> digits <span class="keyword">for</span> d <span class="keyword">in</span> digits]</div><div class="line"></div><div class="line">print(answer)</div></pre></td></tr></table></figure><h3 id="Advance-Python-Demonstration-The-Numerical-Python-Library-Numpy"><a href="#Advance-Python-Demonstration-The-Numerical-Python-Library-Numpy" class="headerlink" title="Advance Python Demonstration: The Numerical Python Library(Numpy)"></a>Advance Python Demonstration: The Numerical Python Library(Numpy)</h3><p>Numpy使我们能够高效地工作在Python中的阵列（arrays)和矩阵（matrices)当中。</p><p>这部分API通过文档了解更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据分析&quot;&gt;&lt;a href=&quot;#数据分析&quot; class=&quot;headerlink&quot; title=&quot;数据分析&quot;&gt;&lt;/a&gt;数据分析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Draw Conway perspective on data science:
    
    </summary>
    
      <category term="数据分析" scheme="http://adamzeng.site/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://adamzeng.site/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>mysql学习笔记一</title>
    <link href="http://adamzeng.site/2017/12/19/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://adamzeng.site/2017/12/19/mysql学习笔记一/</id>
    <published>2017-12-19T14:28:28.000Z</published>
    <updated>2017-12-28T14:49:56.201Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h4><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，<a id="more"></a></p><p>每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。</p><p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对相对较慢。</p><p>所以，现在我们使用关系型数据库管理系统（RDBMS)来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p><p>RDBMS即关系数据库管理系统（Relational Database Management System）的特点：</p><ol><li>数据以表格的形式出现</li><li>每行为各种记录名称</li><li>每列为记录名称所对应的数据域</li><li>许多的行和列组成一张表单</li><li>若干的表单组成database</li></ol><h4 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h4><p>在我们开始学习MySQL数据库前，让我们先了解一下RDBMS的一些术语：</p><ul><li>数据库：数据库是一些关联表的集合。</li><li>数据表：表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li>列：一行（=元祖，或记录）是一组相关的数据，例如一条用户订阅的数据。</li><li>冗余：存储两倍数据，冗余可以使系统速度更快。</li><li>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li><li>外键：外键用于关联两个表。</li><li>复合键:复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li><li>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li><li>参照完整性：参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li></ul><p>####规范化表格的规则：</p><p><strong>1. 每行都具有相同数量的列。</strong><br>实际上，数据库系统不允许在不同的行里具有不同数量的列。但是如果某些列有时候为空，有时候不为空，或者如果我们将多个值放入一个字段里，我们可以调整下此规则。</p><p>拿动物园数据库中的 <strong>diet</strong> 表格为例。我们将某个物种会吃的多种食物放入多行，而不是放在一行里。这样的话，汇总和比较时就操作简单多了。</p><p><strong>2. 表格存在唯一键，一行里的所有内容都围绕该键展开。</strong><br>键可以是一列或多列。甚至可以是整行内容，就像 <strong>diet</strong> 表格一样。但是一个表格里没有重复的行。</p><p>更重要的是，如果我们要存储不是唯一的内容，例如人们的姓名，我们就使用唯一标识符（例如序列号）区分它们。这样可以确保我们不会将两个姓名相同的人的分数或违规停车罚单汇总到一起。</p><p><strong>3. 与唯一键不相关的内容放在其他表格中。</strong><br>例如 <strong>items</strong> 表格，里面有条目、它们的地点和地点的街道地址。地址不是关于条目的内容，它是关于地点的内容。将地址放到另一表格里可以节省空间，并避免造成混淆，我们始终可以使用 <strong>join</strong> 重新组成原始表格。</p><p><strong>4. 表格不应该暗示不存在的关系。</strong><br>例如 <strong>job_skills</strong> 表格，一行列出某人的技术技能（例如“Linux”）和某个语言技能（例如“法语”）。这样看起来就好像 Linux 技能是特定于法语，反之亦然，但现实中不是这种情况。规范化这一情况需要将技术技能和工作技能放在不同的表格里。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是数据库？&quot;&gt;&lt;a href=&quot;#什么是数据库？&quot; class=&quot;headerlink&quot; title=&quot;什么是数据库？&quot;&gt;&lt;/a&gt;什么是数据库？&lt;/h4&gt;&lt;p&gt;数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，
    
    </summary>
    
      <category term="Mysql" scheme="http://adamzeng.site/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://adamzeng.site/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>命名 统计 字典</title>
    <link href="http://adamzeng.site/2017/12/03/%E5%91%BD%E5%90%8D-%E7%BB%9F%E8%AE%A1-%E5%AD%97%E5%85%B8/"/>
    <id>http://adamzeng.site/2017/12/03/命名-统计-字典/</id>
    <published>2017-12-03T13:34:31.000Z</published>
    <updated>2017-12-03T14:59:22.970Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何为元组中的每个元素命名，提高程序可读性？"><a href="#如何为元组中的每个元素命名，提高程序可读性？" class="headerlink" title="如何为元组中的每个元素命名，提高程序可读性？"></a>如何为元组中的每个元素命名，提高程序可读性？</h3><p>学生信息系统中数据为固定格式：<a id="more"></a><br>（姓名，年龄，性别，邮箱地址，…）</p><p>学生数量很大为了减小存储开销，对每个学生信息用元组表示：</p><p>(‘Jim’,16,’male’,’jim8721@gmail.com’)</p><p>(‘LiLei’,17,’male’,’leile@qq.com’)</p><p>(‘Lucy’,16,’female’,’lucy123@yahoo.com’)</p><p>….</p><p>访问时，我们使用引索（index）访问，大量引索降低程序可读性，如何解决这个问题？</p><p>第一种方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">NAME,AGE,SEX,EMAIL=xrange(<span class="number">4</span>) <span class="comment">#将0，1，2，3赋给NAME,AGE,SEX,EMAIL这四个变量</span></div><div class="line"></div><div class="line">student=(<span class="string">'Jim'</span>,<span class="number">16</span>,<span class="string">'male'</span>,<span class="string">'jim8721@gmail.com'</span>)</div><div class="line"></div><div class="line"><span class="comment">#name</span></div><div class="line"><span class="comment">#print(student[0])</span></div><div class="line">print(student[NAME])</div><div class="line"></div><div class="line"><span class="comment">#age</span></div><div class="line"><span class="comment">#if student[1]&gt;18:</span></div><div class="line"><span class="comment">#if student[AGE]&gt;=18:</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#sex</span></div><div class="line"><span class="comment">#if student[3]=='male':</span></div><div class="line"><span class="comment">#if student[SEX]=='male':</span></div></pre></td></tr></table></figure><p>第二种方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</div><div class="line"></div><div class="line">Student=namedtuple(<span class="string">'Student'</span>,[<span class="string">'name'</span>,<span class="string">'age'</span>,<span class="string">'sex'</span>,<span class="string">'email'</span>])</div><div class="line">s=Student(<span class="string">'Jim'</span>,<span class="number">16</span>,<span class="string">'male'</span>,<span class="string">'jim8721@gmail.com'</span>)</div><div class="line"></div><div class="line">print(s)</div><div class="line">s2=Student(name=<span class="string">'Jim'</span>, age=<span class="number">16</span>, sex=<span class="string">'male'</span>, email=<span class="string">'jim8721@gmail.com'</span>)</div><div class="line">print(s2)</div><div class="line"></div><div class="line">print(s.name)</div><div class="line">print(s.age)</div><div class="line">print(s.sex)</div><div class="line"></div><div class="line">print(isinstance(s,tuple))</div><div class="line"></div><div class="line">-----------------------------------------------</div><div class="line"></div><div class="line">Student(name=<span class="string">'Jim'</span>, age=<span class="number">16</span>, sex=<span class="string">'male'</span>, email=<span class="string">'jim8721@gmail.com'</span>)</div><div class="line">Student(name=<span class="string">'Jim'</span>, age=<span class="number">16</span>, sex=<span class="string">'male'</span>, email=<span class="string">'jim8721@gmail.com'</span>)</div><div class="line">Jim</div><div class="line"><span class="number">16</span></div><div class="line">male</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure><h3 id="如何统计序列中元素的出现频度？"><a href="#如何统计序列中元素的出现频度？" class="headerlink" title="如何统计序列中元素的出现频度？"></a>如何统计序列中元素的出现频度？</h3><ol><li>某随机序列[12,5,6,4,6,5,5,7,…]中，找到出现次数最高的3个元素，它们出现次数是多少？</li></ol><ol><li>对某英文文章的单词，进行词频统计，找到出现次数最高的10个单词，它们出现次数是多少？</li></ol><p>######这是一种基本方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</div><div class="line"></div><div class="line">data=[randint(<span class="number">0</span>,<span class="number">20</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">30</span>)]</div><div class="line"></div><div class="line">print(data)</div><div class="line">c=dict.fromkeys(data,<span class="number">0</span>)</div><div class="line"></div><div class="line">print(c)</div><div class="line"></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data:</div><div class="line">    c[x]+=<span class="number">1</span></div><div class="line">print(c)</div><div class="line"></div><div class="line">-------------------------</div><div class="line">[<span class="number">2</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">6</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">17</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">18</span>]</div><div class="line">&#123;<span class="number">1</span>: <span class="number">0</span>, <span class="number">2</span>: <span class="number">0</span>, <span class="number">3</span>: <span class="number">0</span>, <span class="number">5</span>: <span class="number">0</span>, <span class="number">6</span>: <span class="number">0</span>, <span class="number">7</span>: <span class="number">0</span>, <span class="number">8</span>: <span class="number">0</span>, <span class="number">9</span>: <span class="number">0</span>, <span class="number">10</span>: <span class="number">0</span>, <span class="number">11</span>: <span class="number">0</span>, <span class="number">12</span>: <span class="number">0</span>, <span class="number">13</span>: <span class="number">0</span>, <span class="number">15</span>: <span class="number">0</span>, <span class="number">17</span>: <span class="number">0</span>, <span class="number">18</span>: <span class="number">0</span>, <span class="number">20</span>: <span class="number">0</span>&#125;</div><div class="line">&#123;<span class="number">1</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">2</span>, <span class="number">5</span>: <span class="number">3</span>, <span class="number">6</span>: <span class="number">3</span>, <span class="number">7</span>: <span class="number">1</span>, <span class="number">8</span>: <span class="number">1</span>, <span class="number">9</span>: <span class="number">1</span>, <span class="number">10</span>: <span class="number">1</span>, <span class="number">11</span>: <span class="number">2</span>, <span class="number">12</span>: <span class="number">2</span>, <span class="number">13</span>: <span class="number">1</span>, <span class="number">15</span>: <span class="number">4</span>, <span class="number">17</span>: <span class="number">3</span>, <span class="number">18</span>: <span class="number">1</span>, <span class="number">20</span>: <span class="number">1</span>&#125;</div></pre></td></tr></table></figure><p>######第二种方法：</p><ul><li>使用collections.Counter对象</li><li>将序列传入Counter的构造器，得到Counter对象是元素频度的字典。</li><li>Counter.most_common(n)方法得到频度最高的n个元素的列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line"></div><div class="line">data=[randint(<span class="number">0</span>,<span class="number">20</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">30</span>)]</div><div class="line">print(data)</div><div class="line"></div><div class="line">c2=Counter(data)</div><div class="line">print(c2[<span class="number">10</span>])</div><div class="line">print(c2[<span class="number">19</span>])</div><div class="line"></div><div class="line">print(c2.most_common(<span class="number">3</span>))</div><div class="line">--------------------------</div><div class="line">[<span class="number">0</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">17</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>]</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">4</span>), (<span class="number">17</span>, <span class="number">3</span>)]</div></pre></td></tr></table></figure><p>针对第二个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">open(<span class="string">'Co'</span>)</div><div class="line"></div><div class="line">txt=open(<span class="string">'CodingStyle'</span>).read()</div><div class="line">c3=Counter(re.split(<span class="string">'\w+'</span>,txt))</div><div class="line"></div><div class="line">print(c3.most_common(<span class="number">10</span>))</div><div class="line">---------------------------</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何为元组中的每个元素命名，提高程序可读性？&quot;&gt;&lt;a href=&quot;#如何为元组中的每个元素命名，提高程序可读性？&quot; class=&quot;headerlink&quot; title=&quot;如何为元组中的每个元素命名，提高程序可读性？&quot;&gt;&lt;/a&gt;如何为元组中的每个元素命名，提高程序可读性？&lt;/h3&gt;&lt;p&gt;学生信息系统中数据为固定格式：
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>列表，字典，集合筛选数据</title>
    <link href="http://adamzeng.site/2017/12/03/%E5%88%97%E8%A1%A8%EF%BC%8C%E5%AD%97%E5%85%B8%EF%BC%8C%E9%9B%86%E5%90%88%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE/"/>
    <id>http://adamzeng.site/2017/12/03/列表，字典，集合筛选数据/</id>
    <published>2017-12-03T12:14:06.000Z</published>
    <updated>2017-12-03T13:31:55.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何在列表，字典，集合中根据条件筛选数据？"><a href="#如何在列表，字典，集合中根据条件筛选数据？" class="headerlink" title="如何在列表，字典，集合中根据条件筛选数据？"></a>如何在列表，字典，集合中根据条件筛选数据？</h2><h4 id="通用做法"><a href="#通用做法" class="headerlink" title="通用做法"></a>通用做法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">data=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">6</span>,<span class="number">8</span>]</div><div class="line"></div><div class="line">res=[]</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data:</div><div class="line">    <span class="keyword">if</span> x&gt;=<span class="number">0</span>:</div><div class="line">        res.append(x)</div><div class="line"></div><div class="line">print(res)</div></pre></td></tr></table></figure><p>这是最常用的做法，然而还有更加好的解决方案。<a id="more"></a></p><p>解决方案：</p><ul><li><p>列表：</p><p>filter函数，列表解析</p></li><li><p>字典：</p><p>字典解析</p></li><li><p>集合：</p><p>集合解析</p></li></ul><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="这是过滤器的写法："><a href="#这是过滤器的写法：" class="headerlink" title="这是过滤器的写法："></a>这是过滤器的写法：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>filter(<span class="keyword">lambda</span> x:x&gt;=<span class="number">0</span>,data)</div></pre></td></tr></table></figure><p>#####这是列表解析的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> data <span class="keyword">if</span> x&gt;=<span class="number">0</span>]</div></pre></td></tr></table></figure><p>这两种方式都远快于迭代的方案。</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">d=&#123;x:randint(<span class="number">60</span>,<span class="number">100</span>) <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">21</span>)&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">&#123;<span class="number">1</span>: <span class="number">76</span>, <span class="number">2</span>: <span class="number">84</span>, <span class="number">3</span>: <span class="number">79</span>, <span class="number">4</span>: <span class="number">93</span>, <span class="number">5</span>: <span class="number">63</span>, <span class="number">6</span>: <span class="number">62</span>, <span class="number">7</span>: <span class="number">72</span>, <span class="number">8</span>: <span class="number">96</span>, <span class="number">9</span>: <span class="number">71</span>, <span class="number">10</span>: <span class="number">85</span>, <span class="number">11</span>: <span class="number">60</span>, <span class="number">12</span>: <span class="number">100</span>, <span class="number">13</span>: <span class="number">76</span>, <span class="number">14</span>: <span class="number">64</span>, <span class="number">15</span>: <span class="number">79</span>, <span class="number">16</span>: <span class="number">89</span>, <span class="number">17</span>: <span class="number">75</span>, <span class="number">18</span>: <span class="number">88</span>, <span class="number">19</span>: <span class="number">91</span>, <span class="number">20</span>: <span class="number">97</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;k: v <span class="keyword">for</span> k,v <span class="keyword">in</span> d.iteritems()<span class="keyword">if</span> v&gt;<span class="number">90</span>&#125;</div><div class="line">&#123;<span class="number">8</span>: <span class="number">96</span>, <span class="number">12</span>: <span class="number">100</span>, <span class="number">19</span>: <span class="number">91</span>, <span class="number">4</span>: <span class="number">93</span>, <span class="number">20</span>: <span class="number">97</span>&#125;</div></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>data</div><div class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">-10</span>, <span class="number">3</span>, <span class="number">-8</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">-2</span>, <span class="number">1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s=set(data)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">-10</span>, <span class="number">-8</span>, <span class="number">-2</span>]) <span class="comment">#其实与&#123;-5，-3，2，5，6，7，8，9&#125;相同</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> s <span class="keyword">if</span> x%<span class="number">3</span>==<span class="number">0</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>set([<span class="number">3</span>, <span class="number">6</span>])</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何在列表，字典，集合中根据条件筛选数据？&quot;&gt;&lt;a href=&quot;#如何在列表，字典，集合中根据条件筛选数据？&quot; class=&quot;headerlink&quot; title=&quot;如何在列表，字典，集合中根据条件筛选数据？&quot;&gt;&lt;/a&gt;如何在列表，字典，集合中根据条件筛选数据？&lt;/h2&gt;&lt;h4 id=&quot;通用做法&quot;&gt;&lt;a href=&quot;#通用做法&quot; class=&quot;headerlink&quot; title=&quot;通用做法&quot;&gt;&lt;/a&gt;通用做法&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;data=[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;-3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;res=[]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; data:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        res.append(x)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;print(res)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是最常用的做法，然而还有更加好的解决方案。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python中的*arg和**kwarg</title>
    <link href="http://adamzeng.site/2017/11/25/Python%E4%B8%AD%E7%9A%84-arg%E5%92%8C-kwarg/"/>
    <id>http://adamzeng.site/2017/11/25/Python中的-arg和-kwarg/</id>
    <published>2017-11-25T09:05:32.000Z</published>
    <updated>2017-11-25T09:12:06.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个简单的函数"><a href="#一个简单的函数" class="headerlink" title="一个简单的函数"></a>一个简单的函数</h1><p>首先我们可以定一个简单的函数, 函数内部只考虑<code>required_arg</code>这一个形参(<strong>位置参数</strong>)<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">exmaple</span><span class="params">(required_arg)</span>:</span></div><div class="line">    <span class="keyword">print</span> required_arg</div><div class="line"></div><div class="line">exmaple(<span class="string">"Hello, World!"</span>)</div><div class="line"></div><div class="line">&gt;&gt; Hello, World!</div></pre></td></tr></table></figure><p>那么，如果我们调用函数式传入了<strong>不止一个位置参数</strong>会出现什么情况？当然是会报错！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exmaple(<span class="string">"Hello, World!"</span>, <span class="string">"another string"</span>)</div><div class="line"></div><div class="line">&gt;&gt; TypeError: exmaple() takes exactly <span class="number">1</span> argument (<span class="number">2</span> given)</div></pre></td></tr></table></figure><h1 id="定义函数时，使用arg和-kwarg"><a href="#定义函数时，使用arg和-kwarg" class="headerlink" title="定义函数时，使用arg和*kwarg"></a>定义函数时，使用<em>arg和*</em>kwarg</h1><p><em>arg和*</em>kwarg 可以帮助我们处理上面这种情况，允许我们在调用函数的时候传入多个实参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">exmaple2</span><span class="params">(required_arg, *arg, **kwarg)</span>:</span></div><div class="line">    <span class="keyword">if</span> arg:</div><div class="line">        <span class="keyword">print</span> <span class="string">"arg: "</span>, arg</div><div class="line"></div><div class="line">    <span class="keyword">if</span> kwarg:</div><div class="line">        <span class="keyword">print</span> <span class="string">"kwarg: "</span>, kwarg</div><div class="line"></div><div class="line">exmaple2(<span class="string">"Hi"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, keyword1 = <span class="string">"bar"</span>, keyword2 = <span class="string">"foo"</span>)</div><div class="line"></div><div class="line">&gt;&gt; arg:  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">&gt;&gt; kwarg:  &#123;<span class="string">'keyword2'</span>: <span class="string">'foo'</span>, <span class="string">'keyword1'</span>: <span class="string">'bar'</span>&#125;</div></pre></td></tr></table></figure><p>从上面的例子可以看到，当我传入了更多实参的时候</p><ul><li>*arg会把多出来的位置参数转化为<code>tuple</code></li><li>**kwarg会把关键字参数转化为<code>dict</code></li></ul><p>再举个例子，一个不设定参数个数的加法函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(*arg)</span>:</span></div><div class="line">    res = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> arg:</div><div class="line">        res += e</div><div class="line">    <span class="keyword">return</span> res</div><div class="line"></div><div class="line"><span class="keyword">print</span> sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="keyword">print</span> sum(<span class="number">1</span>, <span class="number">1</span>)</div><div class="line">&gt;&gt; <span class="number">10</span></div><div class="line">&gt;&gt; <span class="number">2</span></div></pre></td></tr></table></figure><p>当然，如果想控制关键字参数，可以单独使用一个*，作为特殊分隔符号。限于<code>Python 3</code>，下面例子中限定了只能有两个关键字参数，而且参数名为<code>keyword1</code>和<code>keyword2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def person(required_arg, *, keyword1, keyword2):</div><div class="line">    print(required_arg, keyword1, keyword2)</div><div class="line"></div><div class="line">person(&quot;Hi&quot;, keyword1=&quot;bar&quot;, keyword2=&quot;foo&quot;)</div><div class="line">&gt;&gt; Hi bar foo</div></pre></td></tr></table></figure><p>如果不传入参数名<code>keyword1</code>和<code>keyword2</code>会报错，因为都会看做<strong>位置参数</strong>！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person(&quot;Hi&quot;, &quot;bar&quot;, &quot;foo&quot;)</div><div class="line"></div><div class="line">&gt;&gt; TypeError: person() takes 1 positional argument but 3 were given</div></pre></td></tr></table></figure><h1 id="调用函数时使用arg和-kwarg"><a href="#调用函数时使用arg和-kwarg" class="headerlink" title="调用函数时使用arg和*kwarg"></a>调用函数时使用<em>arg和*</em>kwarg</h1><p>直接上例子，跟上面的情况十分类似。反向思维。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b, c)</span>:</span></div><div class="line">    <span class="keyword">return</span> a + b + c</div><div class="line"></div><div class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"></div><div class="line"><span class="comment"># the * unpack list a </span></div><div class="line"><span class="keyword">print</span> sum(*a)</div><div class="line">&gt;&gt; <span class="number">6</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b, c)</span>:</span></div><div class="line">    <span class="keyword">return</span> a + b + c</div><div class="line"></div><div class="line">a = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</div><div class="line"></div><div class="line"><span class="comment"># the ** unpack dict a</span></div><div class="line"><span class="keyword">print</span> sum(**a)</div><div class="line">&gt;&gt; <span class="number">6</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一个简单的函数&quot;&gt;&lt;a href=&quot;#一个简单的函数&quot; class=&quot;headerlink&quot; title=&quot;一个简单的函数&quot;&gt;&lt;/a&gt;一个简单的函数&lt;/h1&gt;&lt;p&gt;首先我们可以定一个简单的函数, 函数内部只考虑&lt;code&gt;required_arg&lt;/code&gt;这一个形参(&lt;strong&gt;位置参数&lt;/strong&gt;)
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>classmethod和staticmethod</title>
    <link href="http://adamzeng.site/2017/11/25/classmethod%E5%92%8Cstaticmethod/"/>
    <id>http://adamzeng.site/2017/11/25/classmethod和staticmethod/</id>
    <published>2017-11-25T07:49:34.000Z</published>
    <updated>2017-11-25T08:44:45.945Z</updated>
    
    <content type="html"><![CDATA[<p>类中最常用的方法是实例方法，即通过实例作为第一个参数的方法。<a id="more"></a></p><p>举一个例子，一个基本的实例方法就向下面这个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kls</span><span class="params">(object)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data)</span>:</span></div><div class="line">    self.data=data</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printd</span><span class="params">(self)</span>:</span></div><div class="line">    print(self.data)</div><div class="line">ik1=Kls(<span class="string">'arun'</span>)</div><div class="line">ik2=Kls(<span class="string">'seema'</span>)</div><div class="line">ik1.printd()</div><div class="line">ik2.printd()</div></pre></td></tr></table></figure><p>这会给出如下的输出：<br>arun</p><p>seema</p><p><img src="https://pic4.zhimg.com/50/a2173bce20299607befc10abf8c7041b_hd.jpg" alt="image"></p><p>然后看一下代码和示例图片：</p><ul><li>1，2参数传递给方法。</li><li>3 self参数指向当前实例自身。</li><li>4 我们不需要传递实例自身给方法，Python解释器自己会做这些操作。</li></ul><p>如果现在我们想写一些仅仅与类交互而不是和实例交互的方法会怎么样呢？我们可以在类外面写一个简单的方法来做这些，但是这样做就扩散了类代码的关系到类定义的外面。如果像下面这样写就会导致以后代码维护的困难：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_no_of_instances</span><span class="params">(cls_obj)</span>:</span></div><div class="line">  <span class="keyword">return</span> cls_obj.no_inst</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kls</span><span class="params">(object)</span>:</span></div><div class="line">  no_inst=<span class="number">0</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">    Kls.no_inst=Kls.no_inst+<span class="number">1</span></div><div class="line">ik1=Kls()</div><div class="line">ik2=Kls()</div><div class="line">print(get_no_of_instances(Kls))</div></pre></td></tr></table></figure><p>输出：</p><p>2</p><p>@classmethod</p><p>我们要写一个只在类中运行而不在实例中运行的方法。如果我们想让方法不在实例中运行，可以这么做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">iget_no_of_instance</span><span class="params">(ins_obj)</span>:</span></div><div class="line">  <span class="keyword">return</span> ins_obj.__class__.no_inst</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kls</span><span class="params">(object)</span>:</span></div><div class="line">  no_inst=<span class="number">0</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">    Kls.no_inst=Kls.no_inst+<span class="number">1</span></div><div class="line">ik1=Kls()</div><div class="line">ik2=Kls()</div><div class="line"><span class="keyword">print</span> iget_no_of_instance(ik1)</div></pre></td></tr></table></figure><p>输出</p><p>2</p><p>Python2.2以后可以使用@classmethod装饰器来创建类方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kls</span><span class="params">(object)</span>:</span></div><div class="line">  no_inst=<span class="number">0</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">    Kls.no_inst=Kls.no_inst+<span class="number">1</span></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_no_instance</span><span class="params">(cls_obj)</span>:</span></div><div class="line">      <span class="keyword">return</span> cls_obj.no_inst</div><div class="line">ik1=Kls()</div><div class="line">ik2=Kls()</div><div class="line">print(ik1.get_no_of_instance())</div><div class="line">print(Kls.get_no_of_instance())</div></pre></td></tr></table></figure><p>输出：<br>2</p><p>2</p><p>这样的好处是：不管这个方式是从实例调用还是从类调用，它都用第一个参数把类传递过来。</p><p>@staticmethod</p><p>经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法。比如更改环境变量或者修改其他类的属性等能用到静态方法。这种情况可以直接用函数解决，但这样同样会扩散类内部的代码，造成维护困难。</p><p>比如这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">IND=<span class="string">'ON'</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkind</span><span class="params">()</span>:</span></div><div class="line">  <span class="keyword">return</span> (IND==<span class="string">'ON'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kls</span><span class="params">(object)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data)</span>:</span></div><div class="line">    self.data=data</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_reset</span><span class="params">(self)</span>:</span></div><div class="line">  <span class="keyword">if</span> checkind():</div><div class="line">    print(<span class="string">'Reset done for:'</span>,self.data)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_db</span><span class="params">(self)</span>:</span></div><div class="line">  <span class="keyword">if</span> checkind():</div><div class="line">    self.db=<span class="string">'new db connection'</span></div><div class="line">    print(<span class="string">'DB connection made for:'</span>,self.data)</div><div class="line">ik1=Kls(<span class="number">12</span>)</div><div class="line">ik1.do_rest</div><div class="line">ik1.set_db()</div></pre></td></tr></table></figure><p>输出：</p><p>Reset done for:12</p><p>DB connection made for:12</p><p>如果使用@staticmethod就能把相关代码放到对应的位置了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">IND=<span class="string">'ON'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kls</span><span class="params">(object)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data)</span>:</span></div><div class="line">    self.data=data</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkind</span><span class="params">()</span>:</span></div><div class="line">      <span class="keyword">return</span> (IND==<span class="string">'ON'</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">de_reset</span><span class="params">(self)</span>:</span></div><div class="line">      <span class="keyword">if</span> self.checkind():</div><div class="line">        print(<span class="string">'Reset done for:'</span>,self.data)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_db</span><span class="params">(self)</span>:</span></div><div class="line">      <span class="keyword">if</span> self.checkind():</div><div class="line">        self.db=<span class="string">'New db connection'</span></div><div class="line">        print(<span class="string">'DB connection made for:'</span>,self.data)</div><div class="line">ik1=Kls(<span class="number">12</span>)</div><div class="line">ik1.do_reset()</div><div class="line">ik1.set_db()</div></pre></td></tr></table></figure><p>输出：</p><p>Reset done for:12</p><p>DB connection made for:12</p><p>下面这个更全面的代码和图示来展示这两种方法的不同</p><p>@staticmethod和@classmethod的不同</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Kls(object):</div><div class="line">  def __init__(self,data):</div><div class="line">    self.data=data</div><div class="line">  def printd(self):</div><div class="line">    print(self.data)</div><div class="line">  @staticmethod</div><div class="line">  def smethod(*arg):</div><div class="line">    print('Static:',arg)</div><div class="line">  @classmethod</div><div class="line">  def cmethod(*arg):</div><div class="line">    print('Class',arg)</div><div class="line">    </div><div class="line">&gt;&gt;&gt; ik = Kls(23)</div><div class="line">&gt;&gt;&gt; ik.printd()</div><div class="line">23</div><div class="line">&gt;&gt;&gt; ik.smethod()</div><div class="line">Static: ()</div><div class="line">&gt;&gt;&gt; ik.cmethod()</div><div class="line">Class: (&lt;class '__main__.Kls'&gt;,)</div><div class="line">&gt;&gt;&gt; Kls.printd()</div><div class="line">TypeError: unbound method printd() must be called with Kls instance as first argument (got nothing instead)</div><div class="line">&gt;&gt;&gt; Kls.smethod()</div><div class="line">Static: ()</div><div class="line">&gt;&gt;&gt; Kls.cmethod()</div><div class="line">Class: (&lt;class '__main__.Kls'&gt;,)</div></pre></td></tr></table></figure><p>下面这个图解释了以上代码是怎么运行的:<br><img src="https://pic3.zhimg.com/50/8a82a7f295c855c39b0d21f5bb1352c2_hd.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类中最常用的方法是实例方法，即通过实例作为第一个参数的方法。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>scrapy了解</title>
    <link href="http://adamzeng.site/2017/11/24/scrapy%E4%BA%86%E8%A7%A3/"/>
    <id>http://adamzeng.site/2017/11/24/scrapy了解/</id>
    <published>2017-11-24T04:02:44.000Z</published>
    <updated>2017-11-26T11:46:27.609Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Scrapy结构"><a href="#Scrapy结构" class="headerlink" title="Scrapy结构"></a>Scrapy结构<a id="more"></a></h3><p><img src="http://scrapy-chs.readthedocs.io/zh_CN/0.24/_images/scrapy_architecture.png" alt="image"></p><p>上图为scrapy的整个组成结构。</p><p>首先，简单了解一下Scrapy框架中的各个组件，如表2-1所示。</p><table><thead><tr><th>组件</th><th>描述</th><th>类型</th></tr></thead><tbody><tr><td>ENGINE</td><td>引擎，框架的核心，其他所有组件在其控制下协同工作</td><td>内部组件</td></tr><tr><td>SCHEDULER</td><td>调度器，负责对SPIDER提交的下载请求进行调度</td><td>内部组件</td></tr><tr><td>DOWNLOADER</td><td>下载器，负责下载页面（发送HTTP请求/接收HTTP响应）</td><td>内部组件</td></tr><tr><td>SPIDER</td><td>爬虫，负责提取页面中的数据，并产生对新页面的下载请求</td><td>用户实现</td></tr><tr><td>MIDDLEWARE</td><td>中间件，负责对Request对象和Response对象进行处理</td><td>可选组件</td></tr><tr><td>ITEM PIPELINE</td><td>数据管道，负责对爬取到的数据进行处理</td><td>可选组件</td></tr></tbody></table><p>对于用户来说，Spider是最核心的组件，Scrapy爬虫开发是围绕实现Spider展开的。</p><p>接下来，看一下在框架中的数据流，有表2-2所示的3种对象。</p><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>REQUEST</td><td>Scrapy中的HTTP请求对象</td></tr><tr><td>RESPONSE</td><td>Scrapy中的HTTP响应对象</td></tr><tr><td>ITEM</td><td>从页面中爬取的一项数据</td></tr></tbody></table><p>Request和Response是HTTP协议中的术语，即HTTP请求和HTTP响应，Scrapy框架中定义了相应的Request和Response类，这里的Item代表Spider从页面中爬取的一项数据。</p><p>最后，我们来说明以上几种对象在框架中的流动过程。</p><ul><li>当SPIDER要爬取某URL地址的页面时，需使用该URL构建一个Request对象，提交给ENGINE。</li><li>Request对象随后进入SCHEDULER按某种算法进行排队，之后的某个时刻SCHEDULER将其出队，送往DOWNLOADER。</li><li>DOWNLOADER根据Request对象中的URL地址发送依次HTTP请求到网站服务器，之后用服务器返回的HTTP响应构造出一个Response对象，其中包含页面的HTML文本。</li><li>Response对象最终会被递送给SPIDER的页面解析函数（构造Request对象时指定）进行处理，页面解析函数从页面中提取数据，封装成Item后提交给ENGINE，Item之后被送往ITEM PIPELINES进行处理，最终可能由EXPORTER以某种数据格式写入文件（csv，json）；另一方面，页面解析函数还从页面中提取连接（URL），构造出新的Request对象提交给ENGINE。</li></ul><p>理解了框架中的数据流，也就理解了Scrapy爬虫的工作原理。如果把框架中的组件比作人体的各个器官，Request和Response对象便是血液，Item则是代谢产物。</p><h3 id="Request和Response对象"><a href="#Request和Response对象" class="headerlink" title="Request和Response对象"></a>Request和Response对象</h3><p>Request对象用来描述一个HTTP请求，下面是其构造器方法的参数列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Request(url[,callback,method=<span class="string">'GET'</span>,headers,body,cookies,meta,</div><div class="line">           encoding=<span class="string">'utf-8'</span>,priority=<span class="number">0</span>,dont_filter=<span class="keyword">False</span>,errback])</div></pre></td></tr></table></figure><ul><li><p>url(必选)</p><p>请求页面的url地址，bytes或str类型，如’<a href="http://www.python.org/doc" target="_blank" rel="noopener">http://www.python.org/doc</a>‘.</p></li><li><p>callback</p><p>页面解析函数，Callable类型，Request对象请求的页面下载完成后，由该参数指定的页面解析函数被调用。如果未传递该参数，某认调用Spider的parse方法。</p></li><li><p>method</p><p>HTTP的请求方法，默认为’GET’。</p></li><li><p>headers</p><p>HTTP请求1的头部字典，dict类型，例如{‘Accept’:’text/html,’User-Agent’:Mozilla/5.0’}。如果其中某项的值为None，就表示不发送该项HTTP头部，例如{‘Cookie’:None},禁止发送Cookie。</p></li><li><p>body</p><p>HTTP请求的正文，bytes或str类型。</p></li><li><p>cookies</p><p>Cookie信息字典，dict类型，例如{‘currency’:’USD’,’country’:’UY’}。</p></li><li><p>meta</p><p>Request的元数据字典，dict类型，用于给框架中其他组件传递信息，比如中间件ItemPipeline。其他组件可以使用Request对象的meta属性访问该元数据字典（request.meta），也用于给响应处理函数传递信息，详见Response的meta属性。</p></li><li><p>encoding</p><p>url和body参数的编码默认为’utf-8’。如果传入的url或body参数是str类型，就使用该参数进行编码。</p></li><li><p>priority</p><p>请求的优先级默认值为0，优先级高的请求优先下载。</p></li><li><p>dont_filter</p><p>默认情况下，（dont_filter=False),对同一个url地址多次提交下载请求，后面的请求会被去重过滤器过滤（避免重复下载）。如果将该参数置为True，可以使请求避免被过滤，强制下载。例如，在多次爬取一个内容随时间而变化的页面时（每次使用相同的url），可以将该参数置为True。</p></li><li><p>errback</p><p>请求出现异常或者出现HTTP错误时（如404页面不存在）的回调函数。</p><p>虽然参数很多，但除了url参数外，其他都带有默认值。在构造Request对象时，通常我们只需传递一个url参数或再加一个callback参数，其他使用默认值即可。</p></li></ul><h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h3><p>Response对象用来描述一个HTTP响应，Response只是一个基类，根据响应内容的不同有如下子类：</p><ul><li>TextResponse</li><li>HtmlResponse</li><li>XmlResponse</li></ul><p>当一个页面下载完成时，下载器依据HTTP响应头部中的Content-Type信息创建某个Response的子类对象。我们通常爬取的网页，其内容是HTML文本，创建的便是HtmlResponse对象，其中HtmlResponse和XmlResponse是TextResponse的子类。实际上，这3个子类只有细微的差别，这里以HtmlResponse为例进行讲解。</p><p>下面介绍HtmlResponse对象的属性及方法。</p><ul><li>url</li></ul><p>​      HTTP响应的url地址，str类型。</p><ul><li><p>status</p><p>HTTP响应的状态码，int类型，例如200，404。</p></li><li><p>headers</p><p>HTTP响应的头部，类字典类型，可以调用get或getlist方法对其进行访问，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">response.headers.get(<span class="string">'Content-Type'</span>)</div><div class="line">response.headers.getlist(<span class="string">'Set-Cookie'</span>)</div></pre></td></tr></table></figure></li><li><p>body</p><p>HTTP响应正文，bytes类型。</p></li><li><p>text</p><p>文本形式的HTTP响应正文，str类型，它是由response.body使用response.encoding解码得到的，即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.text=response.body.decode(response.encoding)</div></pre></td></tr></table></figure></li><li><p>encoding</p><p>HTTP响应正文的编码，它的值可能是从HTTP响应头部或正文中解析出来的。</p></li><li><p>request</p><p>产生该HTTP响应的Request对象。</p></li><li><p>meta</p><p>即response.request.meta,在构造Request对象时，可将要传递给响应处理函数的信息通过meta参数传入；响应处理函数处理响应时，通过response.meta将信息取出。</p></li><li><p>selector</p><p>Selector对象用于在Response中提取数据（选择器相关话题在后面章节详细讲解）。</p></li><li><p>xpath（query）</p><p>使用XPath选择器在Response中提取数据，实际上它是response.selector.xpath方法的快捷方式。</p></li><li><p>css（query）</p><p>使用CSS选择器在Response中提取数据，实际上它是response.selector.css方法的快捷方式。</p></li><li><p>urljoin(url)</p><p>用于构造绝对url。当传入的url参数是一个相对地址时，根据response.url计算出相应的绝对url。例如，response.url为<a href="http://www.example.com/a，url为b/index.html，调用response.urljoin(url)的结果为http://www.example.com/a/b/index.html。" target="_blank" rel="noopener">http://www.example.com/a，url为b/index.html，调用response.urljoin(url)的结果为http://www.example.com/a/b/index.html。</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Scrapy结构&quot;&gt;&lt;a href=&quot;#Scrapy结构&quot; class=&quot;headerlink&quot; title=&quot;Scrapy结构&quot;&gt;&lt;/a&gt;Scrapy结构
    
    </summary>
    
      <category term="爬虫" scheme="http://adamzeng.site/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://adamzeng.site/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>动态Cookies池</title>
    <link href="http://adamzeng.site/2017/11/22/%E5%8A%A8%E6%80%81Cookies%E6%B1%A0/"/>
    <id>http://adamzeng.site/2017/11/22/动态Cookies池/</id>
    <published>2017-11-22T03:23:54.000Z</published>
    <updated>2017-11-29T11:17:21.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用Cookies池？"><a href="#为什么要用Cookies池？" class="headerlink" title="为什么要用Cookies池？"></a>为什么要用Cookies池？</h1><p>答：网站需要登录才可爬取，例如新浪微博，爬取过程中如果频率过高会导致封号，如果我想要抓取这样的网站，不能够去弄特别多的账号，分别登录去抓取。而是在请求头中加入Cookies完成请求，所以建一个Cookies池。</p><p>Cookies池的要求：</p><ul><li>大量账号，存在数据库当中，拿出来，自动登录更新。</li><li>定时验证筛选，拿出Cookies能够请求页面，就依然放在池子中，已经过时失效了就去除。</li><li>提供外部接口，做到模块的分离。</li></ul><p>Cookies池的架构：账号队列——生成器——Cookies队列（API)——定时检测器</p><p>新浪微博账号存储在redis当中，存储两方面，账号密码，该账号密码的Cookies，</p><ol><li><a href="http://image.so.com/zj?ch=art&amp;sn=30&amp;listtype=new&amp;temp=1" target="_blank" rel="noopener">http://image.so.com/zj?ch=art&amp;sn=30&amp;listtype=new&amp;temp=1</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要用Cookies池？&quot;&gt;&lt;a href=&quot;#为什么要用Cookies池？&quot; class=&quot;headerlink&quot; title=&quot;为什么要用Cookies池？&quot;&gt;&lt;/a&gt;为什么要用Cookies池？&lt;/h1&gt;&lt;p&gt;答：网站需要登录才可爬取，例如新浪微博，爬取
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>未来打算</title>
    <link href="http://adamzeng.site/2017/11/18/%E6%9C%AA%E6%9D%A5%E6%89%93%E7%AE%97/"/>
    <id>http://adamzeng.site/2017/11/18/未来打算/</id>
    <published>2017-11-18T03:35:38.000Z</published>
    <updated>2017-11-20T14:01:07.040Z</updated>
    
    <content type="html"><![CDATA[<p>最近身体很不舒服，博客也有很久没有更新过了。<a id="more"></a>经过这次生病，让我对以后的规划产生了一些想法，首先是对于我的身体，是一个比较弱的身体，很多时候都会为身体的种种毛病而纠结烦恼，但是我仍然希望我能有一个比较好的身体，让我能够没有后顾之忧的开心的钻研自己喜欢的事情，让我也明白一个道理，钱固然很重要，但身体的健康，精神的健康更是可贵，希望奋斗在开发一线的朋友，在面对一个个屏幕时，能够适当的停下脚步，多去注意自己的身体，多去关心自己的家人。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1511196253513&amp;di=aed23efed01d0e1f201cfc710ff4fbbf&amp;imgtype=0&amp;src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2Fa1ec08fa513d26975a1d10b757fbb2fb4216d809.jpg" alt="image"></p><p>一直要注意的是，在面对人生一个个当口的时候，很多时候我们都是很无力的状态，但我们从没想到过放弃，我觉得专注地做一件事非常的难能可贵，能够静下心来思考自己的人生就更不容易了，我只想活得更快乐更自在一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近身体很不舒服，博客也有很久没有更新过了。
    
    </summary>
    
      <category term="生活" scheme="http://adamzeng.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://adamzeng.site/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>最近的生活总结</title>
    <link href="http://adamzeng.site/2017/11/18/%E6%9C%80%E8%BF%91%E7%9A%84%E7%94%9F%E6%B4%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://adamzeng.site/2017/11/18/最近的生活总结/</id>
    <published>2017-11-18T03:34:35.000Z</published>
    <updated>2017-11-20T14:14:41.923Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间里，<a id="more"></a>除了日常工作，我对于Pyquery，beautifulSoup，Requests，有了更深的理解，还有就是IP的代理池的架构，我在很多细节上面都还没有弄懂，但是我会反复的去消化理解其中的精髓的地方，其实在代理池的实现上，用到了很多较为高深的知识，例如元类，当然很多时候去捕捉错误，防止出错导致程序停止，这已经成为了家常便饭，但目前我对redis与MongoDB的理解仅限于能够用Python去连接和使用它们，还没有对这两个数据库有很深的了解，也不清楚这两个数据库应该传什么样的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间里，
    
    </summary>
    
      <category term="生活" scheme="http://adamzeng.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://adamzeng.site/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫动态代理池</title>
    <link href="http://adamzeng.site/2017/11/18/%E7%88%AC%E8%99%AB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%B1%A0/"/>
    <id>http://adamzeng.site/2017/11/18/爬虫动态代理池/</id>
    <published>2017-11-18T03:31:56.000Z</published>
    <updated>2017-11-20T03:22:10.680Z</updated>
    
    <content type="html"><![CDATA[<p>#这是整个代理池的架构：</p><p>##获取器—过滤器—代理队列（API)—定时检测器</p><p>许多网站有专门的反爬虫措施，可能遇到封IP等问题。互联网上公开了大量免费代理，利用好资源。通过定时检测维护同样可以得到多个可用代理。<a id="more"></a></p><p>代理池要求：多站抓取，异步检测，通过代理请求百度页面。定时筛选，持续更新。提供接口，易于提取。</p><ul><li>网上的免费代理很有可能不能够继续使用，这时需要定时检测器，进行测试，将不可用代理剔除，将可用代理存入代理队列。</li><li>实现API，将存在数据库中的可用代理，通过Web，将接口放在网上，方便我们提取使用。</li><li>获取器，从各大网站平台上将代理抓取下来，临时存在一个数据结构当中。</li><li><p>使用过滤器将代理进行筛选，使用代理对网站（例如百度）进行请求，返回正确请求即为可用代理，放置入代理队列中。</p><p>详解大才哥的代理池的源码：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">  print(<span class="string">'Ip processing running'</span>)</div><div class="line"></div><div class="line">  valid_process=Process(target=Schedule.valid_proxy)</div><div class="line"></div><div class="line">  check_process=Process(target=Schedule.check_pool)</div><div class="line"></div><div class="line">  valid_process.start()</div><div class="line"></div><div class="line">  check_process.start()</div></pre></td></tr></table></figure><p>定义了两个process，两个进程，调用start，让这两个进程同时运行。</p><p>valid_proxy为定时检测器，定时检测ip是否有效。在Schedule类下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid_proxy</span><span class="params">(cycle=VALID_CHECK_CYCLE)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Get half of proxies which in redis</div><div class="line">    """</div><div class="line">    conn = RedisClient()<span class="comment">#redis连接的对象</span></div><div class="line">    tester = ValidityTester()</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        print(<span class="string">'Refreshing ip'</span>)</div><div class="line">        count = int(<span class="number">0.5</span> * conn.queue_len)</div><div class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</div><div class="line">            print(<span class="string">'Waiting for adding'</span>)</div><div class="line">            time.sleep(cycle)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        raw_proxies = conn.get(count)</div><div class="line">        tester.set_raw_proxies(raw_proxies)</div><div class="line">        tester.test()</div><div class="line">        time.sleep(cycle)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">db.py</div><div class="line"></div><div class="line"><span class="keyword">import</span> redis</div><div class="line"><span class="keyword">from</span> proxypool.error <span class="keyword">import</span> PoolEmptyError</div><div class="line"><span class="keyword">from</span> proxypool.setting <span class="keyword">import</span> HOST, PORT, PASSWORD</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host=HOST, port=PORT)</span>:</span></div><div class="line">        <span class="keyword">if</span> PASSWORD:</div><div class="line">            self._db = redis.Redis(host=host, port=port, password=PASSWORD)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self._db = redis.Redis(host=host, port=port)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, count=<span class="number">1</span>)</span>:</span><span class="comment">#获取代理从redis</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        get proxies from redis</div><div class="line">        """</div><div class="line">        proxies = self._db.lrange(<span class="string">"proxies"</span>, <span class="number">0</span>, count - <span class="number">1</span>)<span class="comment">#lrange从左侧拿出代理</span></div><div class="line">        self._db.ltrim(<span class="string">"proxies"</span>, count, <span class="number">-1</span>)<span class="comment">#将代理放在右侧</span></div><div class="line">        <span class="keyword">return</span> proxies</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, proxy)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        add proxy to right top</div><div class="line">        """</div><div class="line">        self._db.rpush(<span class="string">"proxies"</span>, proxy)<span class="comment">#将代理放到右侧</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span><span class="comment">#供API使用，将可用代理从右侧拿出。</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        get proxy from right.</div><div class="line">        """</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self._db.rpop(<span class="string">"proxies"</span>).decode(<span class="string">'utf-8'</span>)</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="keyword">raise</span> PoolEmptyError</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">queue_len</span><span class="params">(self)</span>:</span><span class="comment">#整个队列的长度</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        get length from queue.</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> self._db.llen(<span class="string">"proxies"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flush</span><span class="params">(self)</span>:</span><span class="comment">#刷新整个代理队列</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        flush db</div><div class="line">        """</div><div class="line">        self._db.flushall()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    conn = RedisClient()</div><div class="line">    print(conn.pop())</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolAdder</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    add proxy to pool</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threshold)</span>:</span></div><div class="line">        self._threshold = threshold</div><div class="line">        self._conn = RedisClient()</div><div class="line">        self._tester = ValidityTester()</div><div class="line">        self._crawler = FreeProxyGetter()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_over_threshold</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        judge if count is overflow.</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> self._conn.queue_len &gt;= self._threshold:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_to_queue</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'PoolAdder is working'</span>)</div><div class="line">        proxy_count = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.is_over_threshold():</div><div class="line">            <span class="keyword">for</span> callback_label <span class="keyword">in</span> range(self._crawler.__CrawlFuncCount__):</div><div class="line">                callback = self._crawler.__CrawlFunc__[callback_label]</div><div class="line">                raw_proxies = self._crawler.get_raw_proxies(callback)</div><div class="line">                <span class="comment"># test crawled proxies</span></div><div class="line">                self._tester.set_raw_proxies(raw_proxies)</div><div class="line">                self._tester.test()</div><div class="line">                proxy_count += len(raw_proxies)</div><div class="line">                <span class="keyword">if</span> self.is_over_threshold():</div><div class="line">                    print(<span class="string">'IP is enough, waiting to be used'</span>)</div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="keyword">if</span> proxy_count == <span class="number">0</span>:</div><div class="line">                <span class="keyword">raise</span> ResourceDepletionError</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#这是整个代理池的架构：&lt;/p&gt;
&lt;p&gt;##获取器—过滤器—代理队列（API)—定时检测器&lt;/p&gt;
&lt;p&gt;许多网站有专门的反爬虫措施，可能遇到封IP等问题。互联网上公开了大量免费代理，利用好资源。通过定时检测维护同样可以得到多个可用代理。
    
    </summary>
    
      <category term="爬虫" scheme="http://adamzeng.site/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://adamzeng.site/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>BeautifulSoup</title>
    <link href="http://adamzeng.site/2017/11/11/BeautifulSoup/"/>
    <id>http://adamzeng.site/2017/11/11/BeautifulSoup/</id>
    <published>2017-11-11T04:32:37.000Z</published>
    <updated>2017-11-11T07:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><h4 id="解析库"><a href="#解析库" class="headerlink" title="解析库"></a>解析库<a id="more"></a></h4><table><thead><tr><th style="text-align:left">解析器</th><th style="text-align:left">使用方法</th><th style="text-align:left">优势</th><th style="text-align:left">劣势</th></tr></thead><tbody><tr><td style="text-align:left">Python标准库</td><td style="text-align:left">BeautifulSoup(markup,”html.parser”)</td><td style="text-align:left">Python的内置标准库、执行速度适中，文档容错能力强</td><td style="text-align:left">Python2.7.3 or 3.2.2）前版本中文容错能力差</td></tr><tr><td style="text-align:left">lxml HTML 解析器</td><td style="text-align:left">BeautifulSoup(markup，’lxml’)</td><td style="text-align:left">速度快，文档容错能力强</td><td style="text-align:left">需要安装C语言库</td></tr><tr><td style="text-align:left">lxml XML解析器</td><td style="text-align:left">BeautifulSoup(markup,’xml’)</td><td style="text-align:left">速度快，唯一支持XML的解析器</td><td style="text-align:left">需要安装C语言库</td></tr><tr><td style="text-align:left">html5lib</td><td style="text-align:left">BeautifulSoup(markup,’html5lib’)</td><td style="text-align:left">最好的容错性，以浏览器的方式解析文档、生成HTML5格式的文档</td><td style="text-align:left">速度慢，不依赖外部扩展</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>推荐使用lxml解析库，必要时使用html_parser</li><li>标签选择筛选功能弱但是速度快</li><li>建议使用find(),find_all()查询匹配单个结果或者多个结果</li><li>如果对CSS选择器熟悉建议使用select()</li><li>记住常用的获取属性和文本值的方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;BeautifulSoup&quot;&gt;&lt;a href=&quot;#BeautifulSoup&quot; class=&quot;headerlink&quot; title=&quot;BeautifulSoup&quot;&gt;&lt;/a&gt;BeautifulSoup&lt;/h3&gt;&lt;h4 id=&quot;解析库&quot;&gt;&lt;a href=&quot;#解析库&quot; class=&quot;headerlink&quot; title=&quot;解析库&quot;&gt;&lt;/a&gt;解析库
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://adamzeng.site/2017/11/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://adamzeng.site/2017/11/10/正则表达式/</id>
    <published>2017-11-10T09:50:46.000Z</published>
    <updated>2017-11-11T04:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。<a id="more"></a></p><p>非Python独有，re模块实现。</p><p>有一句总结：</p><p><em>尽量使用泛匹配模式，使用括号得到匹配目标，尽量使用非贪婪模式、有换行符就用re.S</em> 。</p><h3 id="正则表达式中常用的字符含义"><a href="#正则表达式中常用的字符含义" class="headerlink" title="正则表达式中常用的字符含义"></a>正则表达式中常用的字符含义</h3><p>####<strong>1、普通字符和11个元字符：</strong></p><table><thead><tr><th>普通字符</th><th>匹配自身</th><th>abc</th><th>abc</th></tr></thead><tbody><tr><td>.</td><td>匹配任意除换行符”\n”外的字符(在DOTALL模式中也能匹配换行符</td><td>a.c</td><td>abc</td></tr><tr><td>\</td><td>转义字符，使后一个字符改变原来的意思</td><td>a.c;a\c</td><td>a.c;a\c</td></tr><tr><td>*</td><td>匹配前一个字符0或多次</td><td>abc*</td><td>ab;abccc</td></tr><tr><td>+</td><td>匹配前一个字符1次或无限次</td><td>abc+</td><td>abc;abccc</td></tr><tr><td>?</td><td>匹配一个字符0次或1次</td><td>abc?</td><td>ab;abc</td></tr><tr><td>^</td><td>匹配字符串开头。在多行模式中匹配每一行的开头</td><td>^abc</td><td>abc</td></tr><tr><td>$</td><td>匹配字符串末尾，在多行模式中匹配每一行的末尾</td><td>abc$</td><td>abc</td></tr><tr><td>\</td><td></td><td>或。匹配\</td><td>左右表达式任意一个，从左到右匹配，如果\</td><td>没有包括在()中，则它的范围是整个正则表达式</td><td>abc\</td><td>def</td><td>abcdef</td></tr><tr><td>{}</td><td>{m}匹配前一个字符m次，{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次</td><td>ab{1,2}c</td><td>abcabbc</td></tr><tr><td>[]</td><td>字符集。对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。[^abc]表示取反，即非abc。所有特殊字符在字符集中都失去其原有的特殊含义。用\反斜杠转义恢复特殊字符的特殊含义。</td><td>a[bcd]e</td><td>abeaceade</td></tr><tr><td>()</td><td>被括起来的表达式将作为分组，从表达式左边开始没遇到一个分组的左括号“（”，编号+1.分组表达式作为一个整体，可以后接数量词。表达式中的\</td><td>仅在该组中有效。</td><td>(abc){2}a(123\</td><td>456)c</td><td>abcabca456c</td></tr></tbody></table><p>这里需要强调一下反斜杠\的作用：</p><ul><li>反斜杠后边跟元字符去除特殊功能；（即将特殊字符转义成普通字符）</li><li>反斜杠后边跟普通字符实现特殊功能；（即预定义字符）</li><li>引用序号对应的字组所匹配的字符串。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a=re.search(<span class="string">r'(tina)(fei)haha\2'</span>,<span class="string">'tinafeihahafei tinafeihahatina'</span>).group()</div><div class="line">print(a)</div><div class="line">结果：</div><div class="line">tinafeihahafei</div></pre></td></tr></table></figure><h4 id="2、预定义字符集（可以写在字符集-…-中）"><a href="#2、预定义字符集（可以写在字符集-…-中）" class="headerlink" title="2、预定义字符集（可以写在字符集[…]中） "></a><strong>2、预定义字符集（可以写在字符集[…]中） </strong></h4><table><thead><tr><th>\d</th><th>数字:[0-9]</th><th>a\bc</th><th>a1c</th></tr></thead><tbody><tr><td>\D</td><td>非数字:[^\d]</td><td>a\Dc</td><td>abc</td></tr><tr><td>\s</td><td>匹配任何空白字符:[&lt;空格&gt;\t\r\n\f\v]</td><td>a\sc</td><td>a c</td></tr><tr><td>\S</td><td>非空白字符:[^\s]</td><td>a\Sc</td><td>abc</td></tr><tr><td>\w</td><td>匹配包括下划线在内的任何字字符:[A-Za-z0-9_]</td><td>a\wc</td><td>abc</td></tr><tr><td>\W</td><td>匹配非字母字符，即匹配特殊字符</td><td>a\Wc</td><td>a c</td></tr><tr><td>\A</td><td>仅匹配字符串开头,同^</td><td>\Aabc</td><td>abc</td></tr><tr><td>\Z</td><td>仅匹配字符串结尾，同$</td><td>abc\Z</td><td>abc</td></tr><tr><td>\b</td><td>匹配\w和\W之间，即匹配单词边界匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td><td>\babc\ba\b!bc</td><td>空格abc空格a!bc</td></tr><tr><td>\B</td><td>[^\b]</td><td>a\Bbc</td><td>abc</td></tr></tbody></table><p><strong>3、特殊分组用法：</strong></p><table><thead><tr><th>(?P<name>)</name></th><th>分组，除了原有的编号外再指定一个额外的别名</th><th>(?P<id>abc){2}</id></th><th>abcabc</th></tr></thead><tbody><tr><td>(?P=name)</td><td>引用别名为<name>的分组匹配到字符串</name></td><td>(?P<id>\d)abc(?P=id)</id></td><td>1abc15abc5</td></tr><tr><td>\<number></number></td><td>引用编号为<number>的分组匹配到字符串</number></td><td>(\d)abc\1</td><td>1abc15abc5</td></tr></tbody></table><p>###Python中re模块</p><p><strong>1、compile()</strong></p><p>编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。）</p><p>格式：</p><p>re.compile(pattern,flags=0)</p><p>pattern: 编译时用的表达式字符串。</p><p>flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等。常用的flags有：</p><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>re.S(DOTALL)</td><td>使.匹配包括换行在内的所有字符</td></tr><tr><td>re.I（IGNORECASE）</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L（LOCALE）</td><td>做本地化识别（locale-aware)匹配，法语等<img src="file:///C:/Users/tina/AppData/Local/YNote/data/heoffer@126.com/15ef610b4afd4cf0aea99402f970595e/19c23298f53f40f1b1d0168871156605.jpg" alt="img"></td></tr><tr><td>re.M(MULTILINE)</td><td>多行匹配，影响^和$</td></tr><tr><td>re.X(VERBOSE)</td><td>该标志通过给予更灵活的格式以便将正则表达式写得更易于理解</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B</td></tr></tbody></table><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">tt = &quot;Tina is a good girl, she is cool, clever, and so on...&quot;</div><div class="line">rr = re.compile(r&apos;\w*oo\w*&apos;)</div><div class="line">print(rr.findall(tt))   #查找所有包含&apos;oo&apos;的单词</div><div class="line">执行结果如下：</div><div class="line">[&apos;good&apos;, &apos;cool&apos;]</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>2、match()</strong></p><p>决定RE是否在字符串刚开始的位置匹配。//注：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’</p><p>格式：</p><p>re.match(pattern, string, flags=0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(re.match(&apos;com&apos;,&apos;comwww.runcomoob&apos;).group())</div><div class="line">print(re.match(&apos;com&apos;,&apos;Comwww.runcomoob&apos;,re.I).group())</div><div class="line">执行结果如下：</div><div class="line">com</div><div class="line">com</div></pre></td></tr></table></figure><p><strong>3、search()</strong></p><p> 格式：</p><p>re.search(pattern, string, flags=0)</p><p>re.search函数会在字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print(re.search(&apos;\dcom&apos;,&apos;www.4comrunoob.5com&apos;).group())</div><div class="line">执行结果如下：</div><div class="line">4com</div></pre></td></tr></table></figure><p>*注：match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法：</p><ul><li>group() 返回被 RE 匹配的字符串</li><li>start() 返回匹配开始的位置</li><li>end() 返回匹配结束的位置</li><li>span() 返回一个元组包含匹配 (开始,结束) 的位置</li><li>group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串。</li></ul><p>a. group（）返回re整体匹配的字符串，<br>b. group (n,m) 返回组号为n，m所匹配的字符串，如果组号不存在，则返回indexError异常<br>c.groups（）groups() 方法返回一个包含正则表达式中所有小组字符串的元组，从 1 到所含的小组号，通常groups()不需要参数，返回一个元组，元组中的元就是正则表达式中定义的组。 </p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">a = &quot;123abc456&quot;</div><div class="line"> print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(0))   #123abc456,返回整体</div><div class="line"> print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(1))   #123</div><div class="line"> print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(2))   #abc</div><div class="line"> print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(3))   #456</div><div class="line">###group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。###</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>4、findall()</strong></p><p>re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。</p><p> 格式：</p><p>re.findall(pattern, string, flags=0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p = re.compile(r&apos;\d+&apos;)</div><div class="line">print(p.findall(&apos;o1n2m3k4&apos;))</div><div class="line">执行结果如下：</div><div class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">tt = &quot;Tina is a good girl, she is cool, clever, and so on...&quot;</div><div class="line">rr = re.compile(r&apos;\w*oo\w*&apos;)</div><div class="line">print(rr.findall(tt))</div><div class="line">print(re.findall(r&apos;(\w)*oo(\w)&apos;,tt))#()表示子表达式 </div><div class="line">执行结果如下：</div><div class="line">[&apos;good&apos;, &apos;cool&apos;]</div><div class="line">[(&apos;g&apos;, &apos;d&apos;), (&apos;c&apos;, &apos;l&apos;)]</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>5、finditer()</strong></p><p> 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。</p><p>格式：</p><p>re.finditer(pattern, string, flags=0)</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">iter = re.finditer(r&apos;\d+&apos;,&apos;12 drumm44ers drumming, 11 ... 10 ...&apos;)</div><div class="line">for i in iter:</div><div class="line">    print(i)</div><div class="line">    print(i.group())</div><div class="line">    print(i.span())</div><div class="line">执行结果如下：</div><div class="line">&lt;_sre.SRE_Match object; span=(0, 2), match=&apos;12&apos;&gt;</div><div class="line">12</div><div class="line">(0, 2)</div><div class="line">&lt;_sre.SRE_Match object; span=(8, 10), match=&apos;44&apos;&gt;</div><div class="line">44</div><div class="line">(8, 10)</div><div class="line">&lt;_sre.SRE_Match object; span=(24, 26), match=&apos;11&apos;&gt;</div><div class="line">11</div><div class="line">(24, 26)</div><div class="line">&lt;_sre.SRE_Match object; span=(31, 33), match=&apos;10&apos;&gt;</div><div class="line">10</div><div class="line">(31, 33)</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>6、split()</strong></p><p>按照能够匹配的子串将string分割后返回列表。</p><p>可以使用re.split来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。</p><p>格式：</p><p>re.split(pattern, string[, maxsplit])</p><p>maxsplit用于指定最大分割次数，不指定将全部分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print(re.split(&apos;\d+&apos;,&apos;one1two2three3four4five5&apos;))</div><div class="line">执行结果如下：</div><div class="line">[&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;, &apos;five&apos;, &apos;&apos;]</div></pre></td></tr></table></figure><p><strong>7、sub()</strong></p><p>使用re替换string中每一个匹配的子串后返回替换后的字符串。</p><p>格式：</p><p>re.sub(pattern, repl, string, count)</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">text = &quot;JGood is a handsome boy, he is cool, clever, and so on...&quot;</div><div class="line">print(re.sub(r&apos;\s+&apos;, &apos;-&apos;, text))</div><div class="line">执行结果如下：</div><div class="line">JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on...</div></pre></td></tr></table></figure><p>其中第二个函数是替换后的字符串；本例中为’-‘</p><p>第四个参数指替换个数。默认为0，表示每个匹配项都替换。</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>re.sub还允许使用函数对匹配项的替换进行复杂的处理。</p><p>如：re.sub(r’\s’, lambda m: ‘[‘ + m.group(0) + ‘]’, text, 0)；将字符串中的空格’ ‘替换为’[ ]’。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">text = &quot;JGood is a handsome boy, he is cool, clever, and so on...&quot;</div><div class="line">print(re.sub(r&apos;\s+&apos;, lambda m:&apos;[&apos;+m.group(0)+&apos;]&apos;, text,0))</div><div class="line">执行结果如下：</div><div class="line">JGood[ ]is[ ]a[ ]handsome[ ]boy,[ ]he[ ]is[ ]cool,[ ]clever,[ ]and[ ]so[ ]on...</div></pre></td></tr></table></figure><p><strong>8、subn()</strong></p><p> 返回替换次数</p><p>格式：</p><p>subn(pattern, repl, string, count=0, flags=0)</p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">print(re.subn(&apos;[1-2]&apos;,&apos;A&apos;,&apos;123456abcdef&apos;))</div><div class="line">print(re.sub(&quot;g.t&quot;,&quot;have&quot;,&apos;I get A,  I got B ,I gut C&apos;))</div><div class="line">print(re.subn(&quot;g.t&quot;,&quot;have&quot;,&apos;I get A,  I got B ,I gut C&apos;))</div><div class="line">执行结果如下：</div><div class="line">(&apos;AA3456abcdef&apos;, 2)</div><div class="line">I have A,  I have B ,I have C</div><div class="line">(&apos;I have A,  I have B ,I have C&apos;, 3)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是正则表达式&quot;&gt;&lt;a href=&quot;#什么是正则表达式&quot; class=&quot;headerlink&quot; title=&quot;什么是正则表达式&quot;&gt;&lt;/a&gt;什么是正则表达式&lt;/h3&gt;&lt;p&gt;正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。
    
    </summary>
    
      <category term="正则表达式" scheme="http://adamzeng.site/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://adamzeng.site/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>__getitem__ and __setitem__</title>
    <link href="http://adamzeng.site/2017/11/09/getitem-and-setitem/"/>
    <id>http://adamzeng.site/2017/11/09/getitem-and-setitem/</id>
    <published>2017-11-09T09:06:28.000Z</published>
    <updated>2017-11-09T09:08:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用一个例子来解释python之 <strong>getattr</strong>、<strong>getattr</strong>、<strong>getitem</strong>、<strong>setitem</strong> 使用：<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__getattr__内置使用点号获取实例属性属性如 s.name，自调用__getattr__</div><div class="line">__setattr__设置类实例属性 如s.name=<span class="string">'tom'</span>，自调用__setattr__</div><div class="line">__getitem__ 使用[]获取实例属性 如s[<span class="string">'name'</span>]，自调用__getitem__</div><div class="line">__setitem__ 使用[]设置实例属性如 s[<span class="string">'name'</span>] = <span class="string">'tom'</span> ，自调用__setitem__</div><div class="line">__dict__ 为参数字典</div></pre></td></tr></table></figure><p>如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></div><div class="line">        <span class="keyword">return</span> item + <span class="string">' is not exits'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        self.__dict__[key] = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.__dict__[item]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        self.__dict__[key] = value</div><div class="line"></div><div class="line"></div><div class="line">s = Student()</div><div class="line">print(s.name)  <span class="comment"># 调用__getattr__方法 输出'name is not exits'</span></div><div class="line">s.age = <span class="number">1</span>  <span class="comment"># 调用__setattr__ 方法</span></div><div class="line">print(s.age)  <span class="comment"># 输出 1</span></div><div class="line">print(s[<span class="string">'age'</span>])  <span class="comment"># 调用 __getitem__方法 输出1</span></div><div class="line">s[<span class="string">'name'</span>] = <span class="string">'tom'</span>  <span class="comment"># 调用 __setitem__ 方法</span></div><div class="line">print(s[<span class="string">'name'</span>])  <span class="comment"># 调用 __getitem__ 方法 输出 'tom'</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用一个例子来解释python之 &lt;strong&gt;getattr&lt;/strong&gt;、&lt;strong&gt;getattr&lt;/strong&gt;、&lt;strong&gt;getitem&lt;/strong&gt;、&lt;strong&gt;setitem&lt;/strong&gt; 使用：
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>排序和搜索</title>
    <link href="http://adamzeng.site/2017/11/07/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/"/>
    <id>http://adamzeng.site/2017/11/07/排序和搜索/</id>
    <published>2017-11-07T07:09:27.000Z</published>
    <updated>2017-11-09T09:12:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>能够解释和实现顺序查找和二分查找<a id="more"></a></li><li>能够解释和实现选择排序，冒泡排序，归并排序，快速排序，插入排序和shell排序</li><li>理解哈希作为搜索技术的思想</li><li>引入映射数据类型</li><li>使用哈希实现Map抽象数据类型</li></ul><p>我们现在把注意力转向计算中经常出现的一些问题，即搜索和排序问题。在本节中，我们将研究搜索。我们将在本章后面的章节中介绍。搜索是在项集合中查找特定项的算法过程。搜索通常对于项是否存在返回True或False。有时它可能返回项被找到的地方。我们在这里将仅关注成员是否存在这个问题。</p><p>在Python中，有一个非常简单的方法来询问一个项是否在一个项列表中。我们使用in运算符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</div><div class="line"><span class="keyword">True</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><p>这很容易写，一个底层的操作替我们完成这个工作。事实证明，有很多不同的方法来搜索。我们在这里感兴趣的是这些算法如何工作以及它们如何相互比较。</p><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>当数据存储在诸如列表的集合中时，我们说它们具有线性或顺序关系。每个数据项都存储在相对于其他数据项的位置。在Python列表中，这些相对位置是单个项的索引值。由于这些索引值是有序的，我们可以按顺序访问它们。这个过程产生我们的第一种搜索技术 <code>顺序查找</code>。</p><p>Figure 1展示了这种搜索的工作原理。从列表中的第一个项目开始，我们按照基本的顺序排序，简单地从一个项移动到另一个项，直到找到我们正在寻找的项或遍历完整个列表。如果我们遍历完整个列表，则说明正在搜索的项不存在。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p>该算法的Python实现见CodeLens 1。该函数需要一个列表和我们正在寻找的项作为参数，并返回一个是否存在的布尔值。found布尔变量初始化为False，如果我们发现列表中的项，则赋值为    True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequentialSearch</span><span class="params">(alist,item)</span>:</span></div><div class="line">    pos=<span class="number">0</span></div><div class="line">    found=<span class="keyword">False</span></div><div class="line">    <span class="keyword">while</span> pos&lt;len(alist) <span class="keyword">and</span> <span class="keyword">not</span> found:</div><div class="line">        <span class="keyword">if</span> alist[pos]==item:</div><div class="line">            found=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            pos=pos+<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> found</div><div class="line"></div><div class="line">  </div><div class="line">testlist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">42</span>, <span class="number">13</span>, <span class="number">0</span>]</div><div class="line">print(sequentialSearch(testlist, <span class="number">3</span>))</div><div class="line">print(sequentialSearch(testlist, <span class="number">13</span>))</div></pre></td></tr></table></figure><p><em>CodeLens 1</em></p><h3 id="顺序查找分析"><a href="#顺序查找分析" class="headerlink" title="顺序查找分析"></a>顺序查找分析</h3><p>为了分析搜索算法，我们需要定一个基本计算单位。回想一下，这通常是为了解决问题要重复的共同步骤。对于搜索，计算比较操作数是有意义的。每个比较都有可能找到我们正在寻找的项目。此外，我们在这里做另一个假设。项列表不以任何方式排序。项随机放置到列表中。换句话说，项在列表任何位置的概率是一样的。</p><p>如果项不在列表中，知道它的唯一方法是将其与存在的每个项进行比较。如果有n个项，则顺序查找需要n个比较来发现项不存在。在项在列表中的情况下，分析不是那么简单。实际上有三种不同的情况可能发生。在最好的情况下，我们在列表的开头找到所需的项，只需要一个比较。在最坏的情况下，我们直到最后的比较才找到项，第n个比较。</p><p>平均情况怎么样？平均来说，我们会在列表的一般找到该项；也就是说，我们将比较n/2项。然而，回想一下，当n变大时，系数，无论它们是什么，在我们的近似中变得不重要，因此顺序查找的复杂度是O(n)。</p><p>Table 1总结了这些结果。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.table1.png" alt="image"></p><p><em>Table 1</em></p><p>我们之前假设，我们列表中的项是随机放置的，因此在项之间没有顺序。如果项以某种方式排序，顺序查找会发生什么？我们能够在搜索技术中取得更好的效率吗？</p><p>假设项的列表按升序排列。如果我们正在寻找的项存在于列表中，它在n个位置中的概率依旧相同。我们仍然会有相同数量的比较来找到该项。然而，如果该项不存在，则有一些优点。Figure 2展示了这个过程，寻找项50。注意项仍然按顺序进行比较直到54。此时，我们知道一些额外的东西。不仅54不是我们正在寻找的项，也没有超过54的其他元素可以匹配到该项，因为列表是有序的。在这种情况下，算法不必继续查看所有项。它可以立即停止。CodeLens 2展示了顺序查找功能的这种变化。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.figure2.png" alt="image"></p><p><em>Figure 2</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">orderedSequentialSearch</span><span class="params">(alist,item)</span>:</span></div><div class="line">    pos=<span class="number">0</span></div><div class="line">    found=<span class="keyword">False</span></div><div class="line">    stop=<span class="keyword">False</span></div><div class="line">    <span class="keyword">while</span> pos&lt;len(alist) <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</div><div class="line">        <span class="keyword">if</span> alist[pos]==item:</div><div class="line">            found=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> alist[pos]&gt;item:</div><div class="line">                stop=<span class="keyword">True</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                pos=pos+<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> found</div><div class="line"></div><div class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</div><div class="line">print(orderedSequentialSearch(testlist, <span class="number">3</span>))</div><div class="line">print(orderedSequentialSearch(testlist, <span class="number">13</span>))</div></pre></td></tr></table></figure><p><em>CodeLens 2</em></p><p>Table 2总结了这些结果。请注意，在最好的情况下，我们通过只查看一项会发现该项不在列表中。平均来说，我们将只了解n/2项就知道。然而，这种复杂度仍然是O(n)。总之，只有在我们没有找到该项的情况下，才通过对列表排序来改进顺序查找。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.table2.png" alt="image"></p><p><em>Table 2</em></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>有序列表对于我们的比较是很有用的。在顺序查找中，当我们与第一个项进行比较时，如果第一个项不是我们要查找的，则最多还有n-1个项目。二分查找从中间项开始，而不是按顺序查找列表。如果该项是我们正在寻找的项，我们就完成了查找。如果它不是，我们可以使用列表的有序性质来消除剩余项的一半。如果我们正在查找的项大于中间项，就可以消除中间项以及比中间项小的一半元素。如果该项在列表中，肯定在大的那半部分。</p><p>然后我们可以用大的半部分重复这个过程。从中间项开始，将其与我们正在寻找的内容进行比较。再次，我们找到元素或将列表分成两半，消除可能的搜索空间的另一部分。Figure 3展示了该算法如果快速找到值54。完整的函数见CodeLens 3中。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/assets/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.figure3.png" alt="image"></p><p><em>Figure 3</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(alist,item)</span>:</span></div><div class="line">    first=<span class="number">0</span></div><div class="line">    last=len(alist)<span class="number">-1</span></div><div class="line">    found=<span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> first&lt;=last <span class="keyword">and</span> <span class="keyword">not</span> found:</div><div class="line">        midpoint=(first+last)//<span class="number">2</span></div><div class="line">        <span class="keyword">if</span> alist[midpoint]==item:</div><div class="line">            found=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> item&lt;alist[midpoint]:</div><div class="line">                last=midpoint<span class="number">-1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                first=midpoint+<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> found</div><div class="line">  </div><div class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</div><div class="line">print(binarySearch(testlist, <span class="number">3</span>))</div><div class="line">print(binarySearch(testlist, <span class="number">13</span>))</div></pre></td></tr></table></figure><p><em>CodeLens 3</em></p><p>在我们继续分析之前，我们应该注意到，这个算法是分而治之策略的一个很好的例子。分和治意味着我们将问题分成更小的部分，以某种方式解决更小的部分，然后重新组合整个问题以获得结果。当我们执行列表的二分查找时，我们首先检查中间项。如果我们正在搜索的项小于中间项，我们可以简单地对原始列表的左半部分执行二分查找。同样，如果项大，我们可以执行右半部分的二分查找。无论哪种方式，都是递归调用二分查找函数。CodeLens 4展示了这个递归版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(alist,item)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(alist)==<span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        midpoint=len(alist)//<span class="number">2</span></div><div class="line">        <span class="keyword">if</span> alist[midpoint]==item:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> item&lt;alist[midpoint]:</div><div class="line">                <span class="keyword">return</span> binarySearch(alist[:midpoint],item)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> binarySearch(alist[midpoint+<span class="number">1</span>:],item)</div><div class="line">            </div><div class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</div><div class="line">print(binarySearch(testlist, <span class="number">3</span>))</div><div class="line">print(binarySearch(testlist, <span class="number">13</span>))</div></pre></td></tr></table></figure><p><em>CodeLens 4</em></p><h3 id="二分查找分析"><a href="#二分查找分析" class="headerlink" title="二分查找分析"></a>二分查找分析</h3><p>为了分析二分查找算法，我们需要记住，每个比较消除了大约一半的剩余项。该算法检查整个列表的最大比较数是多少？如果我们从n项开始，大约n/2项将在第一次比较后留下。第二次比较后，会有约n/4。然后n/8,n/16,等等。我们可以拆分列表多少次？Table 3帮助我们找到答案。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/assets/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.table3.png" alt="image"></p><p><em>Table 3</em></p><p>当我们切分列表足够多次时，我们最终得到只有一个项的列表。要么是我们正在寻找的项，要么不是。达到这一点所需的比较数是i，当n/2^i=1时。求解i得出i=log^n。最大比较数相对于列表中的项是对数的。因此，二分查找是O(log^n)。</p><p>还需要解决一个额外的分析问题。在上面所示的递归解中，递归调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">binarySearch(alist[:midpoint],item)</div></pre></td></tr></table></figure><p>使用切片运算符创建列表的左半部分，然后传递到下一个调用（同样对于右半部分）。我们上面做的分析假设切片操作符是恒定时间的。然而，我们知道Python中的slice运算符实际上是O(k)。这意味着使用slice的二分查找将不会在严格的对数时间执行。幸运的是，这可以通过传递列表连同开始和结束索引来纠正。可以像CodeLens 3中所做的那样计算索引。我们将此实现作为练习。</p><p>即使二分查找通常比顺序查找更好，但重要的是要注意，对于小的n值，排序的额外成本可能不值得。事实上，我们应该经常考虑采取额外的分类工作是否使搜索获得好处。如果我们可以排序依次，然后查找多次，排序的成本就不那么重要。然而，对于大型列表，一次排序可能是非常昂贵，从一开始就执行顺序查找可能是最好的选择。</p><h3 id="Hash查找"><a href="#Hash查找" class="headerlink" title="Hash查找"></a>Hash查找</h3><p>在前面的部分中，我们通过利用关于项在集合中相对于彼此存储的位置的信息，改进我们的搜索算法。例如，通过指导列表是有序的，我们可以使用二分查找在对数时间中搜索。在本节中，我们将尝试进一步建立一个可以在O(1)时间内搜索的数据结构。这个概念被称为Hash查找。</p><p>为了做到这一点，当我们在集合中查找项时，我们需要更多地了解项可能在哪里。如果每个项都在应该在的地方，那么搜索可以使用单个比较就能发现项的存在。然而，我们看到，通常不是这样的。</p><p><code>哈希表</code> 是以一种容易找到它们的方式存储的项的集合。哈希表的每个位置，通常称为一个槽，可以容纳一个项，并且由从 0 开始的整数值命名。例如，我们有一个名为 0 的槽，名为 1 的槽，名为 2 的槽，以上。最初，哈希表不包含项，因此每个槽都为空。我们可以通过使用列表来实现一个哈希表，每个元素初始化为<code>None</code> 。Figure 4 展示了大小 m = 11 的哈希表。换句话说，在表中有 m 个槽，命名为 0 到 10。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure4.png" alt="image"></p><p><em>Figure 4</em></p><p>项和该项在散列表中所属的槽之间的映射被称为 <code>hash 函数</code>。 hash 函数将接收集合中的任何项，并在槽名范围内（0和 m-1之间）返回一个整数。假设我们有整数项 <code>54,26,93,17,77</code> 和 <code>31</code> 的集合。我们的第一个 hash 函数，有时被称为 <code>余数法</code> ，只需要一个项并将其除以表大小，返回剩余部分作为其散列值<code>（h(item) = item％11）</code>。 Table 4 给出了我们的示例项的所有哈希值。注意，这种余数方法（模运算）通常以某种形式存在于所有散列函数中，因为结果必须在槽名的范围内。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.table4.png" alt="image"></p><p><em>Table 4</em></p><p>一旦计算了哈希值，我们可以将每个项插入到指定位置的哈希表中，如Figure 5所示。注意，11个插槽中6个现在已被占用。这被称为负载因子，通常表示为 <code>λ=项数/表大小</code>, 在这个例子中，<code>λ = 6/11</code> 。 </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure5.png" alt="image"></p><p><em>Figure 5</em></p><p>现在，当我们要搜索一个项时，我们只需使用哈希函数来计算项的槽名称，然后检查哈希表以查看它是否存在。该搜索操作是 O(1)，因为需要恒定的时间量来计算散列值，然后在该位置索引散列表。如果一切都正确的话，我们已经找到了一个恒定时间搜索算法。</p><p>你可能已经看到，只有每个项映射到哈希表中的唯一位置，这种技术才会起作用。 例如，如果项 44 是我们集合中的下一个项，则它的散列值为<code>0（44％11 == 0）</code>。 因为 77 的哈希值也是 0，我们会有一个问题。根据散列函数，两个或更多项将需要在同一槽中。这种现象被称为碰撞（它也可以被称为“冲突”）。显然，冲突使散列技术产生了问题。我们将在后面详细讨论。</p><h3 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h3><p>给定项的集合，将每个项映射到唯一槽的散列函数被称为完美散列函数。如果我们知道项和集合将永远不会改变，那么可以构造一个完美的散列函数。不幸的是，给定任意的项集合，没有系统的方法来构建完美的散列函数。幸运的是，我们不需要散列函数是完美的，仍然可以提高性能。</p><p>总是具有完美散列函数的一种方式是增加散列表的大小，使得可以容纳项范围中的每个可能值。这保证每个项将具有唯一的槽。虽然这对于小数目的项是实用的，但是当可能项的数目大时是不可行的。例如，如果项是九位数的社保号码，则此方法将需要大约十亿个槽。如果我们只想存储25名学生的数据，我们将浪费大量内存。</p><p>我们的目标是创建一个散列函数，最大限度地减少冲突数，易于计算，并均匀分布在哈希表中的项。有很多常用的方法来扩展简单余数法。我们将在这里介绍其中几个。</p><p><code>分组求和法</code> 将项划分为相等大小的块（最后一块可能不是相等大小）。然后将这些块加在一起以求出散列值。例如，如果我们的项是电话号码 <code>436-555-4601</code>，我们将取出数字，并将它们分成2位数<code>（43,65,55,46,01）</code>。<code>43 + 65 + 55 + 46 + 01</code>，我们得到 210。我们假设哈希表有11个槽，那么我们需要除以11。在这种情况下，210%11为1，因此电话号码 <code>436-555-4601</code> 散列到槽 1 。一些分组求和法会在求和之前每隔一个反转。对于上述示例，我们得到<code>43 + 56 + 55 + 64 + 01 = 219</code>，其给出<code>219％11 = 10</code> 。</p><p>用于构造散列函数的另一数值技术被称为<code>平方取中法</code>。我们首先对该项平方，然后提取一部分数字结果。例如，如果项是44，我们将首先计算 <code>44^2 = 1,936</code> 。通过提取中间两个数字 <code>93</code> ，我们得到 <code>5（93％11）</code>。Table 5 展示了余数法和中间平方法下的项。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.table5.png" alt="image"></p><p><em>Table 5</em></p><p>我们还可以为基于字符的项（如字符串）创建哈希函数。词 <code>cat</code> 可以被认为是 ascii 值的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'c'</span>)</div><div class="line"><span class="number">99</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'a'</span>)</div><div class="line"><span class="number">97</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'t'</span>)</div><div class="line"><span class="number">116</span></div></pre></td></tr></table></figure><p>然后，我们可以获取这三个ascii值，将它们相加，并使用余数方法获取散列值（参见Figure 6）。Listing 1展示了一个名为hash的函数，它接收字符串和表大小作为参数，并返回从 <code>0</code> 到 <code>tablesize-1</code> 的范围内的散列值。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.table5-1.png" alt="image"></p><p> <em>Figure 6</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(astring,tablesize)</span>:</span></div><div class="line">    sum=<span class="number">0</span></div><div class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> range(len(astring)):</div><div class="line">        sum=sum+ord(astring[pos])</div><div class="line">        </div><div class="line">        </div><div class="line">    <span class="keyword">return</span> sum%tablesize</div></pre></td></tr></table></figure><p><em>Listing 1</em></p><p>有趣的是，当使用此散列函数时，字符串总是返回相同的散列值。为了弥补这一点，我们可以使用字符的位置作为权重。Figure 7展示了使用位置值作为加权因子的一种可能的方式。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure7.png" alt="image"></p><p><em>Figure 7</em></p><p>你可以思考一些其他方法来计算集合中项的散列值。重要的是要记住，哈希函数必须是高效的，以便它不会成为存储和搜索过程的主要部分。如果哈希函数太复杂，则计算槽名称的程序要比之前所述的简单地进行基本的顺序或二分搜索更耗时。 这将打破散列的目的。</p><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>我们现在回到碰撞的问题。当两个项散列到同一个槽时，我们必须有一个系统的方法将第二个项放在散列表中。这个过程称为冲突解决。如前所述，如果散列函数是完美的，冲突将永远不会发生。然而，由于这通常是不可能的，所以冲突解决成为散列非常重要的部分。</p><p>解决冲突的一种方法是查找散列表，尝试查找到另一个空槽以保存导致冲突的项。一个简单的方法是从原始哈希值位置开始，然后以顺序方式移动槽，直到遇到第一个空槽。注意，我们可能需要回到第一个槽（循环）以查找整个散列表。这种冲突解决过程被称为开放寻址，因为它试图在散列表中找到下一个空槽或地址。通过系统地一次访问每个槽，我们执行称为线性探测的开放寻址技术。</p><p>Figure 8展示了在简单余数法散列函数<code>（54,26,93,17,77,31,44,55,20）</code> 下的整数项的扩展集合。上面的 Table 4 展示了原始项的哈希值。Figure 5 展示了原始内容。当我们尝试将 <code>44</code> 放入槽 0 时，发生冲突。在线性探测下，我们逐个顺序观察，直到找到位置。在这种情况下，我们找到槽 1。</p><p>再次，<code>55</code> 应该在槽 0 中，但是必须放置在槽 2 中，因为它是下一个开放位置。值 20 散列到槽 9 。由于槽 9 已满，我们进行线性探测。我们访问槽<code>10,0,1</code>和 <code>2</code>，最后在位置 3 找到一个空槽。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure8.png" alt="image"></p><p><em>Figure 9</em></p><p>处理聚集的一种方式是扩展线性探测技术，使得不是顺序地查找下一个开放槽，而是跳过槽，从而更均匀地分布已经引起冲突的项。这将潜在地减少发生的聚集。 Figure 10 展示了使用 <code>加3</code> 探头进行碰撞识别时的项。 这意味着一旦发生碰撞，我们将查看第三个槽，直到找到一个空。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure10.png" alt="image"></p><p><em>Figure 10</em></p><p>在冲突后寻找另一个槽的过程叫 <code>重新散列</code>。使用简单的线性探测，rehash 函数是 <code>newhashvalue = rehash(oldhashvalue)</code>其中 <code>rehash(pos)=(pos + 1)％sizeoftable</code>。 <code>加3</code>rehash 可以定义为<code>rehash(pos)=(pos + 3)％sizeoftable</code>。一般来说，<code>rehash(pos)=(pos + skip)％sizeoftable</code>。重要的是要注意，“跳过”的大小必须使得表中的所有槽最终都被访问。否则，表的一部分将不被使用。为了确保这一点，通常建议表大小是素数。这是我们在示例中使用 11 的原因。</p><p>线性探测思想的一个变种称为二次探测。代替使用常量 “跳过” 值，我们使用rehash 函数，将散列值递增 <code>1，3，5，7，9，</code> 依此类推。这意味着如果第一哈希值是 <code>h</code>，则连续值是<code>h + 1，h + 4，h + 9，h + 16</code>，等等。换句话说，二次探测使用由连续完全正方形组成的跳跃。Figure 11 展示了使用此技术放置之后的示例值。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure11.png" alt="image"></p><p><em>Figure 11</em></p><p>用于处理冲突问题的替代方法是允许每个槽保持对项的集合（或链）的引用。链接允许许多项存在于哈希表中的相同位置。当发生冲突时，项仍然放在散列表的正确槽中。随着越来越多的项哈希到相同的位置，搜索集合中的项的难度增加。 Figure 12 展示了添加到使用链接解决冲突的散列表时的项。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure12.png" alt="image"></p><p><em>Figure 12</em></p><p>当我们要搜索一个项时，我们使用散列函数来生成它应该在的槽。由于每个槽都有一个集合，我们使用一种搜索技术来查找该项是否存在。优点是，平均来说，每个槽中可能有更少的项，因此搜索可能更有效。我们将在本节结尾处查看散列的分析。</p><h3 id="实现map抽象数据类型"><a href="#实现map抽象数据类型" class="headerlink" title="实现map抽象数据类型"></a>实现map抽象数据类型</h3><p>最有用的Python集合之一是字典。回想一下，字典是一种关联数据类型，你可以在其中存储建-值对。该键用于查找关联的值。我们经常将这个想法称为map。</p><p>map 抽象数据类型定义如下。该结构是键与值之间的关联的无序集合。map 中的键都是唯一的，因此键和值之间存在一对一的关系。操作如下。</p><ul><li>Map() 创建一个新的 map 。它返回一个空的 map 集合。</li><li>put(key，val) 向 map 中添加一个新的键值对。如果键已经在 map 中，那么用新值替换旧值。</li><li>get(key) 给定一个键，返回存储在 map 中的值或 None。</li><li>del 使用 <code>del map[key]</code> 形式的语句从 map 中删除键值对。</li><li>len() 返回存储在 map 中的键值对的数量。</li><li>in 返回 True 对于 <code>key in map</code> 语句，如果给定的键在 map 中，否则为False。</li></ul><p>字典一个很大的好处是，给定一个键，我们可以非常快速地查找相关的值。为了提供这种快速查找能力，我们需要一个支持高效搜索的实现。我们可以使用具有顺序或二分查找的列表，但是使用如上所述的哈希表将更好，因为查找哈希表中的项可以接近 O(1) 性能。</p><p>在listing 2中，我们使用两个列表来创建一个实现Map抽象数据类型的HashTable类。一个名为slots的列表将保存键项，一个称为data的并行列表将保存数据值。当我们查找一个键时，data列表中相应位置将保存相关的数据值。我们将使用前面提出的想法将键列表视为哈希表。注意，哈希表的初始大小已经被选择为11。尽管这是任意的，但是重要的是，大小是质数，使得冲突解决算法可以尽可能高效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.size=<span class="number">11</span></div><div class="line">        self.slots=[<span class="keyword">None</span>]*self.size</div><div class="line">        self.data=[<span class="keyword">None</span>]*self.size</div></pre></td></tr></table></figure><p><em>Listing 2</em></p><p>hash 函数实现简单的余数方法。冲突解决技术是 <code>加1</code> rehash 函数的线性探测。 put 函数（见 Listing 3）假定最终将有一个空槽，除非 key 已经存在于 <code>self.slots</code> 中。 它计算原始哈希值，如果该槽不为空，则迭代 rehash 函数，直到出现空槽。如果非空槽已经包含 key，则旧数据值将替换为新数据值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,key,data)</span>:</span></div><div class="line">  hashvalue = self.hashfunction(key,len(self.slots))</div><div class="line"></div><div class="line">  <span class="keyword">if</span> self.slots[hashvalue] == <span class="keyword">None</span>:</div><div class="line">    self.slots[hashvalue] = key</div><div class="line">    self.data[hashvalue] = data</div><div class="line">  <span class="keyword">else</span>:</div><div class="line">    <span class="keyword">if</span> self.slots[hashvalue] == key:</div><div class="line">      self.data[hashvalue] = data  <span class="comment">#replace</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">      nextslot = self.rehash(hashvalue,len(self.slots))</div><div class="line">      <span class="keyword">while</span> self.slots[nextslot] != <span class="keyword">None</span> <span class="keyword">and</span> \</div><div class="line">                      self.slots[nextslot] != key:</div><div class="line">        nextslot = self.rehash(nextslot,len(self.slots))</div><div class="line"></div><div class="line">      <span class="keyword">if</span> self.slots[nextslot] == <span class="keyword">None</span>:</div><div class="line">        self.slots[nextslot]=key</div><div class="line">        self.data[nextslot]=data</div><div class="line">      <span class="keyword">else</span>:</div><div class="line">        self.data[nextslot] = data <span class="comment">#replace</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hashfunction</span><span class="params">(self,key,size)</span>:</span></div><div class="line">     <span class="keyword">return</span> key%size</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rehash</span><span class="params">(self,oldhash,size)</span>:</span></div><div class="line">    <span class="keyword">return</span> (oldhash+<span class="number">1</span>)%size</div></pre></td></tr></table></figure><p><em>Listing 3</em></p><p>同样，get 函数（见 Listing 4）从计算初始哈希值开始。如果值不在初始槽中，则 rehash 用于定位下一个可能的位置。注意，第 15 行保证搜索将通过检查以确保我们没有返回到初始槽来终止。如果发生这种情况，我们已用尽所有可能的槽，并且项不存在。</p><p>HashTable 类提供了附加的字典功能。我们重载 <code>__getitem__</code> 和<code>__setitem__</code> 方法以允许使用 <code>[]</code> 访问。 这意味着一旦创建了HashTable，索引操作符将可用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,key)</span>:</span></div><div class="line">  startslot = self.hashfunction(key,len(self.slots))</div><div class="line"></div><div class="line">  data = <span class="keyword">None</span></div><div class="line">  stop = <span class="keyword">False</span></div><div class="line">  found = <span class="keyword">False</span></div><div class="line">  position = startslot</div><div class="line">  <span class="keyword">while</span> self.slots[position] != <span class="keyword">None</span> <span class="keyword">and</span>  \</div><div class="line">                       <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</div><div class="line">     <span class="keyword">if</span> self.slots[position] == key:</div><div class="line">       found = <span class="keyword">True</span></div><div class="line">       data = self.data[position]</div><div class="line">     <span class="keyword">else</span>:</div><div class="line">       position=self.rehash(position,len(self.slots))</div><div class="line">       <span class="keyword">if</span> position == startslot:</div><div class="line">           stop = <span class="keyword">True</span></div><div class="line">  <span class="keyword">return</span> data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,key)</span>:</span></div><div class="line">    <span class="keyword">return</span> self.get(key)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self,key,data)</span>:</span></div><div class="line">    self.put(key,data)</div></pre></td></tr></table></figure><p><em>Listing 4</em></p><p>下面的会话展示了 HashTable 类的操作。首先，我们将创建一个哈希表并存储一些带有整数键和字符串数据值的项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>H=HashTable()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">54</span>]=<span class="string">"cat"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">26</span>]=<span class="string">"dog"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">93</span>]=<span class="string">"lion"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">17</span>]=<span class="string">"tiger"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">77</span>]=<span class="string">"bird"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">31</span>]=<span class="string">"cow"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">44</span>]=<span class="string">"goat"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">55</span>]=<span class="string">"pig"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">20</span>]=<span class="string">"chicken"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H.slots</div><div class="line">[<span class="number">77</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="number">31</span>, <span class="number">54</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H.data</div><div class="line">[<span class="string">'bird'</span>, <span class="string">'goat'</span>, <span class="string">'pig'</span>, <span class="string">'chicken'</span>, <span class="string">'dog'</span>, <span class="string">'lion'</span>,</div><div class="line">       <span class="string">'tiger'</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="string">'cow'</span>, <span class="string">'cat'</span>]</div></pre></td></tr></table></figure><p>接下来，我们将访问和修改哈希表中的一些项。注意，正替换键 20 的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">20</span>]</div><div class="line"><span class="string">'chicken'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">17</span>]</div><div class="line"><span class="string">'tiger'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">20</span>]=<span class="string">'duck'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">20</span>]</div><div class="line"><span class="string">'duck'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H.data</div><div class="line">[<span class="string">'bird'</span>, <span class="string">'goat'</span>, <span class="string">'pig'</span>, <span class="string">'duck'</span>, <span class="string">'dog'</span>, <span class="string">'lion'</span>,</div><div class="line">       <span class="string">'tiger'</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="string">'cow'</span>, <span class="string">'cat'</span>]</div><div class="line">&gt;&gt; print(H[<span class="number">99</span>])</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure><h3 id="hash分析"><a href="#hash分析" class="headerlink" title="hash分析"></a>hash分析</h3><p>我们之前说过，在最好的情况下，散列将提供 O(1)，恒定时间搜索。然而，由于冲突，比较的数量通常不是那么简单。即使对散列的完整分析超出了本文的范围，我们可以陈述一些近似搜索项所需的比较数量的已知结果。</p><p>我们需要分析散列表的使用的最重要的信息是负载因子 λ。概念上，如果 λ 小，则碰撞的机会较低，这意味着项更可能在它们所属的槽中。如果 λ 大，意味着表正在填满，则存在越来越多的冲突。这意味着冲突解决更困难，需要更多的比较来找到一个空槽。使用链接，增加的碰撞意味着每个链上的项数量增加。</p><p>和以前一样，我们将有一个成功的搜索结果和不成功的。对于使用具有线性探测的开放寻址的成功搜索，平均比较数大约为<code>1/2（1 + 1/(1-λ)）</code>，不成功的搜索为 1/2(1+(1/1-λ)^2 ) 如果我们使用链接，则对于成功的情况，平均比较数目是 1+λ/2，如果搜索不成功，则简单地是 λ 比较次数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;能够解释和实现顺序查找和二分查找
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode371题</title>
    <link href="http://adamzeng.site/2017/11/06/leetcode371/"/>
    <id>http://adamzeng.site/2017/11/06/leetcode371/</id>
    <published>2017-11-06T08:11:29.000Z</published>
    <updated>2017-11-06T12:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode371题389题401题461题645题"><a href="#leetcode371题389题401题461题645题" class="headerlink" title="leetcode371题389题401题461题645题"></a>leetcode371题389题401题461题645题</h1><h3 id="371题"><a href="#371题" class="headerlink" title="371题"></a>371题</h3><p>Calculate the sum of two integers <em>a</em> and <em>b</em>, but you are <strong>not allowed</strong> to use the operator <code>+</code> and <code>-</code>.<a id="more"></a></p><p><strong>Example:</strong><br>Given <em>a</em> = 1 and <em>b</em> = 2, return 3.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://discuss.leetcode.com/user/fujiaozhu" target="_blank" rel="noopener">@fujiaozhu</a> for adding this problem and creating all test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, a, b)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type a: int</div><div class="line">        :type b: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="string">"""</span></div><div class="line">        两个数的二进制形式：如5 = 0b101 ,3 = 0b011 ,两个二进制位如果一个为0,一个为1，则加之后为1,如果都为0，则加之后为0,如果都为1，则加之后为0，且向前进位，需要进位的位置为两个数的逻辑与</div><div class="line">        因为Python的整数不是固定的32位，所以需要做一些特殊的处理，具体见代码吧。</div><div class="line">代码里的将一个数对0x100000000取模（注意：Python的取模运算结果恒为非负数），是希望该数的二进制表示从第32位开始到更高的位都同是0（最低位是第0位），以在0-31位上模拟一个32位的int</div><div class="line">        """</div><div class="line">        <span class="keyword">while</span> b:</div><div class="line">            carry = a &amp; b</div><div class="line">            a = (a ^ b) % <span class="number">0x100000000</span></div><div class="line">            b = (carry &lt;&lt; <span class="number">1</span>) % <span class="number">0x100000000</span></div><div class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> a | (~<span class="number">0x100000000</span>+<span class="number">1</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, a, b)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type a: int</div><div class="line">        :type b: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> sum([a,b])</div></pre></td></tr></table></figure><h3 id="389题"><a href="#389题" class="headerlink" title="389题"></a>389题</h3><p>Given two strings <strong>s</strong> and <strong>t</strong> which consist of only lowercase letters.</p><p>String <strong>t</strong> is generated by random shuffling string <strong>s</strong> and then add one more letter at a random position.</p><p>Find the letter that was added in <strong>t</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">s = <span class="string">"abcd"</span></div><div class="line">t = <span class="string">"abcde"</span></div><div class="line"></div><div class="line">Output:</div><div class="line">e</div><div class="line"></div><div class="line">Explanation:</div><div class="line"><span class="string">'e'</span> <span class="keyword">is</span> the letter that was added.</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheDifference</span><span class="params">(self, s, t)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :type t: str</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        m=list(t)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            m.remove(i)</div><div class="line">        <span class="keyword">return</span> m[<span class="number">0</span>]</div></pre></td></tr></table></figure><p>我自己的解法，将t变为list，再遍历s中的字符，去除t中与s相同的字符,再返回m中剩余的所有字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheDifference</span><span class="params">(self, s, t)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :type t: str</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        <span class="comment"># d = dict.fromkeys(t,0)</span></div><div class="line">        <span class="comment"># for i in s:</span></div><div class="line">        <span class="comment">#     d[i] += 1;</span></div><div class="line">        <span class="comment"># for j in t:</span></div><div class="line">        <span class="comment">#     d[j] -= 1;</span></div><div class="line">        <span class="comment">#     if d[j] &lt; 0:</span></div><div class="line">        <span class="comment">#         return j </span></div><div class="line">        <span class="comment"># 第二种方法：排序</span></div><div class="line">        s, t = sorted(s), sorted(t)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</div><div class="line">            <span class="keyword">if</span> s[i] != t[i]:</div><div class="line">                <span class="keyword">return</span> t[i]</div><div class="line">        <span class="keyword">return</span> t[<span class="number">-1</span>]</div></pre></td></tr></table></figure><p>我所挑选的答案，均不是性能最优方案，但代码非常简单，易读。</p><h3 id="401题"><a href="#401题" class="headerlink" title="401题"></a>401题</h3><p>A binary watch has 4 LEDs on the top which represent the <strong>hours</strong> (<strong>0-11</strong>), and the 6 LEDs on the bottom represent the <strong>minutes</strong> (<strong>0-59</strong>).</p><p>Each LED represents a zero or one, with the least significant bit on the right.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt="image"></p><p>For example, the above binary watch reads “3:25”.</p><p>Given a non-negative integer <em>n</em> which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: n = <span class="number">1</span></div><div class="line">Return: [<span class="string">"1:00"</span>, <span class="string">"2:00"</span>, <span class="string">"4:00"</span>, <span class="string">"8:00"</span>, <span class="string">"0:01"</span>, <span class="string">"0:02"</span>, <span class="string">"0:04"</span>, <span class="string">"0:08"</span>, <span class="string">"0:16"</span>, <span class="string">"0:32"</span>]</div></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>The order of output does not matter.</p></li><li><p>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</p></li><li><p>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: n = <span class="number">1</span></div><div class="line">Return: [<span class="string">"1:00"</span>, <span class="string">"2:00"</span>, <span class="string">"4:00"</span>, <span class="string">"8:00"</span>, <span class="string">"0:01"</span>, <span class="string">"0:02"</span>, <span class="string">"0:04"</span>, <span class="string">"0:08"</span>, <span class="string">"0:16"</span>, <span class="string">"0:32"</span>]</div></pre></td></tr></table></figure><p>​</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readBinaryWatch</span><span class="params">(self, num)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type num: int</div><div class="line">        :rtype: List[str]</div><div class="line">        """</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bit_count</span><span class="params">(bits)</span>:</span></div><div class="line">            count = <span class="number">0</span></div><div class="line">            <span class="keyword">while</span> bits:</div><div class="line">                bits &amp;= bits<span class="number">-1</span></div><div class="line">                count += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> count</div><div class="line"></div><div class="line">        <span class="keyword">return</span> [<span class="string">'%d:%02d'</span> % (h, m)</div><div class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> xrange(<span class="number">12</span>) <span class="keyword">for</span> m <span class="keyword">in</span> xrange(<span class="number">60</span>)</div><div class="line">            <span class="keyword">if</span> bit_count(h) + bit_count(m) == num]</div></pre></td></tr></table></figure><p>bit_count函数是一个非常厉害的函数，它返回了由1 2 4 8组成的数所需的灯的数量，当然也是计算由1 2 4 8 16 32组成的数所需的灯的数量。</p><p>下面的返回也很有讲究，直接遍历12个小时数与60和分钟数，再用if来限定。</p><h3 id="461题"><a href="#461题" class="headerlink" title="461题"></a>461题</h3><p>解释：汉明距离就是其二进制数对应位不同的个数。</p><p> 汉明距离是以理查德·卫斯里·汉明的名字命名的。在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。</p><p>​    For example:<br>​    例如：</p><p>​    The Hamming distance between 1011101 and 1001001 is 2.<br>​    The Hamming distance between 2143896 and 2233796 is 3.<br>​    The Hamming distance between “toned” and “roses” is 3.<br>​    1011101 与 1001001 之间的汉明距离是 2。<br>​    2143896 与 2233796 之间的汉明距离是 3。<br>​    “toned” 与 “roses” 之间的汉明距离是 3。</p><hr><p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank" rel="noopener">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p><p><strong>Note:</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Input: x = <span class="number">1</span>, y = <span class="number">4</span></div><div class="line"></div><div class="line">Output: <span class="number">2</span></div><div class="line"></div><div class="line">Explanation:</div><div class="line"><span class="number">1</span>   (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>)</div><div class="line"><span class="number">4</span>   (<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>)</div><div class="line">       ↑   ↑</div><div class="line"></div><div class="line">The above arrows point to positions where the corresponding bits are different.</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span><span class="params">(self, x, y)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :type y: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        times = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">            bit1=x%<span class="number">2</span></div><div class="line">            bit2=y%<span class="number">2</span></div><div class="line">            x=x/<span class="number">2</span></div><div class="line">            y=y/<span class="number">2</span></div><div class="line">            <span class="keyword">if</span> bit1 != bit2:</div><div class="line">                times = times + <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> times</div></pre></td></tr></table></figure><p>我的解法，果然又是跑起来很慢的那种，下面是最快解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span><span class="params">(self, x, y)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :type y: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> bin(x^y).count(<span class="string">'1'</span>)</div></pre></td></tr></table></figure><p>基本只用了一行代码。。。通过抑或^,获得x^y之后获得的二进制数，x与y进行^运算相同的位结果是0，不同的位结果是1，然后通过count方法数出该二进制数中所剩下的有1的位，就得出x与y相同位不同数字的总个数了，也就是Hamming Distance！</p><h3 id="654题"><a href="#654题" class="headerlink" title="654题"></a>654题</h3><p>The set <code>S</code> originally contains numbers from 1 to <code>n</code>. But unfortunately, due to the data error, one of the numbers in the set got duplicated to <strong>another</strong> number in the set, which results in repetition of one number and loss of another number.</p><p>Given an array <code>nums</code> representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.</p><p><strong>Example 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>]</div><div class="line">Output: [<span class="number">2</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findErrorNums</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        N = len(nums)</div><div class="line">        count = [<span class="number">0</span>] * (N+<span class="number">1</span>)</div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</div><div class="line">            count[x] += <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, len(nums)+<span class="number">1</span>):</div><div class="line">            <span class="keyword">if</span> count[x] == <span class="number">2</span>:</div><div class="line">                twice = x</div><div class="line">            <span class="keyword">if</span> count[x] == <span class="number">0</span>:</div><div class="line">                never = x</div><div class="line">        <span class="keyword">return</span> twice, never</div></pre></td></tr></table></figure><p>太牛逼的解法，只能跪服，这道题我只符合了11/49cases。。</p><p>很难受，思路是count其实统计的是nums中出现的数字的次数。一般来说只有一个数出现的次数是2，其他出现的次数是1。下面遍历从1到nums+1的长度中的所有数，发现在count中次数为2的就是我们要找的，而次数为0的就是出现error未出现在nums中的。其实不太对，我发现有的用例很奇怪，[5,5]这种用例的话，上述代码也不符合。因为是遍历从1到nums+1长度的数，因为[5,5]这种列表不是从1开始的，所以很奇怪。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode371题389题401题461题645题&quot;&gt;&lt;a href=&quot;#leetcode371题389题401题461题645题&quot; class=&quot;headerlink&quot; title=&quot;leetcode371题389题401题461题645题&quot;&gt;&lt;/a&gt;leetcode371题389题401题461题645题&lt;/h1&gt;&lt;h3 id=&quot;371题&quot;&gt;&lt;a href=&quot;#371题&quot; class=&quot;headerlink&quot; title=&quot;371题&quot;&gt;&lt;/a&gt;371题&lt;/h3&gt;&lt;p&gt;Calculate the sum of two integers &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, but you are &lt;strong&gt;not allowed&lt;/strong&gt; to use the operator &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;.
    
    </summary>
    
      <category term="leetcode" scheme="http://adamzeng.site/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://adamzeng.site/tags/leetcode/"/>
    
  </entry>
  
</feed>
