<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AdamZeng</title>
  
  <subtitle>start from zero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://adamzeng.site/"/>
  <updated>2018-11-03T10:44:30.297Z</updated>
  <id>http://adamzeng.site/</id>
  
  <author>
    <name>AdamZeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发一</title>
    <link href="http://adamzeng.site/2018/11/01/%E5%B9%B6%E5%8F%91%E4%B8%80/"/>
    <id>http://adamzeng.site/2018/11/01/并发一/</id>
    <published>2018-11-01T09:58:51.000Z</published>
    <updated>2018-11-03T10:44:30.297Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>并发:同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替地换入或者换出内存，这些线程是同时”存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。</p><p>高并发:高并发（High Concurrency)是互联网分布式系统架构设计中必须要考虑的因此之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p><p>并发:多个线程操作相同的资源，保证线程安全，合理使用资源。</p><p>高并发:服务能同时处理很多请求，提高程序性能。</p><p>为什么需要CPU cache:CPU的频率太快了，快到主寸跟不上，这样在处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题(结构:cpu-&gt;cache-&gt;memory)。</p><p>CPU cache有什么意义：</p><ol><li>时间局限性：如果某个数据被访问，那么在不久的将来它很可能被再次访问。</li><li>空间局限性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问。</li></ol><h4 id="CPU多级缓存-缓存一致性（MESI）"><a href="#CPU多级缓存-缓存一致性（MESI）" class="headerlink" title="CPU多级缓存-缓存一致性（MESI）"></a>CPU多级缓存-缓存一致性（MESI）</h4><ul><li>用于保证多个CPU cache之间缓存共享数据的一致<img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwsrix1mgfj310o0f64ap.jpg" alt="屏幕快照 2018-11-01 下午9.58.41"></li></ul><h4 id="CPU多级缓存-乱序执行优化"><a href="#CPU多级缓存-乱序执行优化" class="headerlink" title="CPU多级缓存-乱序执行优化"></a>CPU多级缓存-乱序执行优化</h4><h4 id="Java内存模型-Java-Memory-Model-JMM"><a href="#Java内存模型-Java-Memory-Model-JMM" class="headerlink" title="Java内存模型(Java Memory Model,JMM)"></a>Java内存模型(Java Memory Model,JMM)</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwss8prshrj31260getoo.jpg" alt="屏幕快照 2018-11-01 下午10.23.44"></p><h4 id="Java内存模型-同步八种操作"><a href="#Java内存模型-同步八种操作" class="headerlink" title="Java内存模型-同步八种操作"></a>Java内存模型-同步八种操作</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fwsslfnldxj316e0iuqfv.jpg" alt="屏幕快照 2018-11-01 下午10.36.08"></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwtuoipxslj30zq0om7jw.jpg" alt="屏幕快照 2018-11-02 下午8.33.34"></p><ul><li>CPU多级缓存：缓存一致性、乱序执行优化</li><li>Java内存模型：JMM规定、抽象结构、同步八种操作及规则</li><li>Java并发的优势与风险</li></ul><h4 id="并发编程与线程安全"><a href="#并发编程与线程安全" class="headerlink" title="并发编程与线程安全"></a>并发编程与线程安全</h4><p>并发环境下得到我们所期望的结果</p><h4 id="并发模拟"><a href="#并发模拟" class="headerlink" title="并发模拟"></a>并发模拟</h4><ul><li>Postman：Http请求模拟工具</li><li>Apache Bench（AB)：Apache附带的工具，测试网站性能</li><li>JMeter：Apache组织开发的压力测试工具</li><li>代码：Semaphore、CountDownLatch等</li></ul><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>定义：当多个线程访问某个类时，不管运行时环境采用<strong>何种调度方式</strong>或者这些进程将如何交替执行，并且在主调代码中<strong>不需要任何额外的同步或协同</strong>，这个类都能表现出<strong>正确的行为</strong>，那么就称这个类是线程安全的。</p><ul><li>原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作。</li><li>可见性：一个线程对主内存的修改可以及时的被其他线程观察到。</li><li>有序性：一个线程观察到其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</li></ul><h4 id="原子性-Atomic包"><a href="#原子性-Atomic包" class="headerlink" title="原子性 -Atomic包"></a>原子性 -Atomic包</h4><ul><li><p>AtomicXXX：CAS、Unsafe.compareAndSwapInt</p></li><li><p>AtomicLong、LongAdder</p></li><li><p>对于long 与double类型的变量，JVM允许将读操作与写操作拆成两个32位的操作</p></li><li><p>AtomicReference、AtomicReferenceFieldUpdater</p><p>原子性更新对象中的某一个字段，是volatile非static字段</p></li><li><p>AtomicStampReference:CAS的ABA问题</p></li></ul><p>Unsafe类：compareAndSwapInt(var1,var2,var5,var5+var4)</p><p>如果当前值var2与底层从主内存地址中获取的值相同的话，才执行增加操作，因为这个增加操作依赖原值，原值在各个线程使用过程中可能会修改，需要有这么一个校验的过程，这样就防止某一次一个线程将缓存中的数据没来得及同步回主存之前，另一个线程将主存数据取来进行操作。将该Java线程中工作内存中的值与Java线程中共享的值（主内存中的值）进行对比，如果相同才执行增加操作。</p><p>LongAdder： 将AtomicLong内部核心数据value分离成一个数组，每个线程访问时，通过Hash等算法预测到其中一个数字进行计数，最后结果为这个数组的求和累加。</p><p>分成多个cell，每个cell独自维护内部的值。</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="synchronized：依赖JVM"><a href="#synchronized：依赖JVM" class="headerlink" title="synchronized：依赖JVM"></a>synchronized：依赖JVM</h5><p>同步锁，修饰的对象总共有四种：</p><ol><li>修饰一个代码块：大括号扩起来的代码，作用于<strong>调用这个代码块的对象</strong></li><li>修饰方法（同步方法）：整个方法，作用于<strong>调用的对象</strong></li><li>修饰静态方法：整个静态方法，作用于<strong>所有对象</strong></li><li>修饰类：括号扩起来的部分，作用于<strong>所有对象</strong></li></ol><p>修饰一个代码块与修饰一个方法均是作用于调用对象的，调用对象之间是互相不影响的</p><p>如果一个一个方法内部是一个完整的同步代码块，与用synchronized关键字直接修饰方法是等同的。</p><p>如果父类中有synchronized修饰的方法，子类在继承父类的时候，该方法的synchronized关键字不会被继承！！！（原因是：synchronized不属于方法声明的一部分）</p><h4 id="原子性-对比"><a href="#原子性-对比" class="headerlink" title="原子性-对比"></a>原子性-对比</h4><ul><li>synchronized：不可中断锁，适合竞争不激烈，可读性好</li><li>Lock:可中断锁，多样化同步，竞争激烈时能维持常态</li><li>Atomic:竞争激烈时能维持常态，比Lock性能好；只能同步一个值</li></ul><h5 id="Lock：依赖特殊的CPU指令，代码实现，Reen"><a href="#Lock：依赖特殊的CPU指令，代码实现，Reen" class="headerlink" title="Lock：依赖特殊的CPU指令，代码实现，Reen"></a>Lock：依赖特殊的CPU指令，代码实现，Reen</h5><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>导致共享变量在线程间不可见的原因</p><ul><li>线程交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主存间及时更新</li></ul><p>JMM关于<strong>synchronized</strong>的两条规定：</p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存</li><li><p>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值<strong>（注意，加锁与解锁是同一把锁）</strong></p><h4 id="可见性-volatile"><a href="#可见性-volatile" class="headerlink" title="可见性-volatile"></a>可见性-volatile</h4></li></ul><p>通过加入<strong>内存屏障</strong>和<strong>禁止重排序</strong>优化来实现</p><ul><li>对volatile变量写操作时，会在写操作后加入一条store屏障指令、将本地内存中的共享变量值刷新到主内存</li><li>对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fwv0b40p8kj31420mwn8e.jpg" alt="屏幕快照 2018-11-03 下午8.33.40"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fwv0ch3yzfj313g0na7fn.jpg" alt="屏幕快照 2018-11-03 下午8.35.30"></p><h4 id="volatile适合什么样的场景"><a href="#volatile适合什么样的场景" class="headerlink" title="volatile适合什么样的场景"></a>volatile适合什么样的场景</h4><ol><li>对变量的写操作不依赖当前值</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited=<span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="comment">// 线程1：</span></div><div class="line">context=loadContext();</div><div class="line">inited=<span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// 线程2：</span></div><div class="line"><span class="keyword">while</span>(!inited)&#123;</div><div class="line">    sleep();</div><div class="line">&#125;</div><div class="line">doSomethingWithConfig(context);</div></pre></td></tr></table></figure><p>还有一个使用场景double check</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><ul><li>Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</li><li>volatile、synchronized、Lock</li></ul><h4 id="有序性-happens-before"><a href="#有序性-happens-before" class="headerlink" title="有序性-happens-before"></a>有序性-happens-before</h4><p>如果两个操作的执行次序不能从happens-before原则推导出来，虚拟机就不能保证操作执行的次序。</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p></li><li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作</p></li><li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p></li><li>对象终极规则：一个对象的初始化完成先行发生于它的finalize()方法的开始</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;并发:同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替地换入或者换出内存，这些线程是同时”存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同
      
    
    </summary>
    
      <category term="多线程" scheme="http://adamzeng.site/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://adamzeng.site/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="http://adamzeng.site/2018/10/15/MyBatis/"/>
    <id>http://adamzeng.site/2018/10/15/MyBatis/</id>
    <published>2018-10-15T05:43:10.000Z</published>
    <updated>2018-10-20T05:27:42.051Z</updated>
    
    <content type="html"><![CDATA[<h4 id="MyBatis概述"><a href="#MyBatis概述" class="headerlink" title="MyBatis概述"></a>MyBatis概述</h4><p>ORM简介<a id="more"></a></p><ul><li>ORM：对象关系映射（Object Relation Mapping）</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw8v39qzpbj31bq0coak7.jpg" alt="屏幕快照 2018-10-15 下午4.51.00"></p><p>传统JDBC程序的设计缺陷</p><ul><li>大量配置信息硬编码</li><li>大量的无关业务处理的编码</li><li>扩展优化极为不便</li></ul><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Mybatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。</p><ul><li>避免传统JDBC硬编码</li><li>XML配置或者注解</li><li>POJO对象和数据库记录直接映射</li><li>完善的文档支持</li></ul><h4 id="MyBatis前世今生"><a href="#MyBatis前世今生" class="headerlink" title="MyBatis前世今生"></a>MyBatis前世今生</h4><ul><li>apache开源项目：ibatis<ul><li>ibatis是internet和abatis的组合，一个基于java持久层框架</li><li>2010年-&gt;apache software foundation -&gt;google code-童年修改名称：MyBatis</li><li>2013年-&gt;google code-&gt;迁移-&gt;GitHub</li></ul></li></ul><h4 id="MyBatis的使用优势"><a href="#MyBatis的使用优势" class="headerlink" title="MyBatis的使用优势"></a>MyBatis的使用优势</h4><ul><li>简单易学，快速上手，学习成本低</li><li>数据库交互信息配置化</li><li>动态SQL处理</li></ul><h4 id="MyBatis的使用场景"><a href="#MyBatis的使用场景" class="headerlink" title="MyBatis的使用场景"></a>MyBatis的使用场景</h4><ul><li>更加关注SQL优化的项目</li><li>需求频繁更新改动的项目</li></ul><p>####MyBatis开发环境搭建</p><ul><li>MyBatis的下载</li><li>项目中引入MyBatis支持</li><li>入门程序</li><li>了解MyBatis的工作原理</li></ul><h4 id="获取MyBatis"><a href="#获取MyBatis" class="headerlink" title="获取MyBatis"></a>获取MyBatis</h4><p>现在一般使用maven方式引入</p><h4 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h4><ul><li>需求：完成一个数据的查询流程</li><li>目的：了解mybatis核心api的操作流程</li><li>扩展：了解mybatis的工作流程</li></ul><h4 id="MyBatis核心炒作过程"><a href="#MyBatis核心炒作过程" class="headerlink" title="MyBatis核心炒作过程"></a>MyBatis核心炒作过程</h4><p>在程序运行过程中要对mybatis.xml主配置文件和<em>*</em>Mapper.xml映射配置文件进行读取</p><p>读取之后构建一个和数据库之间的会话</p><ul><li>SqlSessionFactoryBuilder</li><li>SqlSessionFactory</li><li>SqlSession</li><li>Executor</li></ul><p>Mybatis架构分解</p><h4 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h4><ul><li>数据查询接口</li><li>数据新增接口</li><li>数据更新接口</li><li>数据删除接口</li><li>获取配置接口</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw922qlwusj31io0nwx0g.jpg" alt="屏幕快照 2018-10-15 下午8.52.40"></p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><ul><li>项目案例演示</li><li>数据库数据准备工作</li><li>界面准备工作</li><li>MyBatis基础操作</li></ul><p>项目案例：后台管理系统用户数据维护平台</p><ul><li>所有用户数据查询</li><li>单个用户数据查询</li><li>用户数据修改</li><li>锁定用户账号</li><li>删除用户账号</li><li>彻底删除用户账号</li></ul><p>案例数据库准备</p><ul><li>数据库：MySQL5.7</li><li>数据库名称</li><li>数据表：用户表（Users） </li></ul><h4 id="基础操作—-主配置解析"><a href="#基础操作—-主配置解析" class="headerlink" title="基础操作—-主配置解析"></a>基础操作—-主配置解析</h4><ul><li>properties配置加载</li><li>environments环境配置</li><li>settings参数设置配置</li><li>typeAliases别名设置</li><li>mapper映射加载</li></ul><h4 id="基础操作—-查询数据"><a href="#基础操作—-查询数据" class="headerlink" title="基础操作—-查询数据"></a>基础操作—-查询数据</h4><ul><li>映射配置：sql片段</li><li>映射配置：select配置<ul><li>特殊配置：字段和属性不一致时resultMap配置</li></ul></li></ul><h4 id="基础操作——增加数据"><a href="#基础操作——增加数据" class="headerlink" title="基础操作——增加数据"></a>基础操作——增加数据</h4><ul><li>映射配置:sql片段</li><li>映射配置：insert配置 </li></ul><h4 id="基础操作——修改数据"><a href="#基础操作——修改数据" class="headerlink" title="基础操作——修改数据"></a>基础操作——修改数据</h4><ul><li>映射配置：update配置</li><li>动态SQL配置：set配置</li></ul><h4 id="基础操作——删除数据"><a href="#基础操作——删除数据" class="headerlink" title="基础操作——删除数据"></a>基础操作——删除数据</h4><ul><li>映射配置：delete配置</li><li>补充：业务功能中的删除账号、锁定账号和彻底删除账号</li></ul><h4 id="基础进阶——多表关联入门"><a href="#基础进阶——多表关联入门" class="headerlink" title="基础进阶——多表关联入门"></a>基础进阶——多表关联入门</h4><ul><li>需求：一个用户有多个地址</li><li>解决方案：多表关联查询</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;MyBatis概述&quot;&gt;&lt;a href=&quot;#MyBatis概述&quot; class=&quot;headerlink&quot; title=&quot;MyBatis概述&quot;&gt;&lt;/a&gt;MyBatis概述&lt;/h4&gt;&lt;p&gt;ORM简介
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring-5</title>
    <link href="http://adamzeng.site/2018/10/14/Spring-5/"/>
    <id>http://adamzeng.site/2018/10/14/Spring-5/</id>
    <published>2018-10-14T05:25:00.000Z</published>
    <updated>2018-10-14T09:45:04.191Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h4><ul><li><p>Java事务导引</p><ul><li>什么是事务</li><li>事务与Java的关系</li><li>事务的原则性内容</li></ul></li><li><p>Spring事务核心接口</p></li><li>编程式事务管理</li><li>声明式事务管理</li><li>事务最佳实践</li><li>总结</li></ul><h4 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h4><ul><li><p>事务是正确执行一系列的操作（或动作），使得数据库从一种状态转换成另一种状态，且保证操作全部成功，或者全部失败。</p></li><li><p>事务原则是什么</p><ul><li>事务必须服从ISO/IEC所制定的ACID原则</li><li>ACID原则如下：<ul><li>原子性（Atomicity）：即不可分割性，事务要么全部被执行，要么就全部不被执行。</li><li>一致性（Consistency）：事务的执行使得数据库从一种正确状态转换成另一种正确状态。</li><li>隔离性（Isolation）：在事务正确提交之前，它可能的结果不应显示给任何其他事务。</li><li>持久性（Durability）：事务正确提交后，其结果将永久保存在数据库中。</li></ul></li></ul></li><li><p>Java事务的产生</p><ul><li>程序操作数据库的需要。在Java编写的程序或系统中，实现ACID的操作。</li></ul></li><li>Java事务实现范围<ul><li>通过JDBC相应方法间接来实现对数据库的增、删、改、查，把事务转移到Java程序代码中进行控制；</li><li>确保事务—-要么全部执行成功，要么撤销不执行。</li></ul></li><li>总结：Java事务机制和原理就是确保数据库操作的ACID特性。</li></ul><h4 id="Java事务实现模式"><a href="#Java事务实现模式" class="headerlink" title="Java事务实现模式"></a>Java事务实现模式</h4><ul><li>Java事务的实现<ul><li>通过Java代码来实现对数据库的事务性操作。</li></ul></li><li>Java事务类型<ul><li>JDBC事务：用Connection对象控制，包括手动模式和自动模式；</li><li>JTA（Java transaction API）事务：与实现无关，与协议无关的API；</li><li>容器事务：应用服务器提供的，且大多是基于JTA完成（通常基于JNDI的，相当复杂的API实现）。</li></ul></li></ul><p>JDBC事务：控制的局限性在一个数据库连接内，但是其使用简单。</p><p>JTA事务：功能强大，可跨越多个数据库或多DAO，使用比较复杂。</p><p>容器事务：主要指的是J2EE应用服务器提供的事务管理，局限于EJB。</p><h4 id="Spring事务核心接口"><a href="#Spring事务核心接口" class="headerlink" title="Spring事务核心接口"></a>Spring事务核心接口</h4><p>事务接口架构</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw7peaqvq9j31kw0rtkgh.jpg" alt="屏幕快照 2018-10-14 下午4.47.23"></p><h4 id="Spring事务属性定义"><a href="#Spring事务属性定义" class="headerlink" title="Spring事务属性定义"></a>Spring事务属性定义</h4><ul><li>事务属性范围</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw7pnox1oaj30ee0e2gqe.jpg" alt="屏幕快照 2018-10-14 下午4.57.44"></p><ul><li>事务属性定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</div><div class="line">    <span class="comment">// 返回事务的传播行为</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制</span></div><div class="line">    <span class="comment">// 另外一个事务可以看到本事务内的哪些数据</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 返回事务必须在多少秒内完成</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 判断事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>数据读取类型说明</p><ul><li>脏读：事务没提交，提前读取；</li><li>不可重复读：两次读取的数据不一致；</li><li>幻读：事务不是独立执行时发生的一种非预期现象。</li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul><li>隔离级别定义了一个事务可能受其他并发事务影响的程度。</li><li>隔离级别分为：</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw7pxffrdmj318m0eih47.jpg" alt="屏幕快照 2018-10-14 下午5.06.58"></p><ul><li>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播；</li><li>Spring的7种传播行为：</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw7pzc6hnvj317y0janp6.jpg" alt="屏幕快照 2018-10-14 下午5.08.39"></p><h4 id="事务是否只读"><a href="#事务是否只读" class="headerlink" title="事务是否只读"></a>事务是否只读</h4><ul><li><p>利用数据库事务的“只读”属性，进行特定优化处理。</p></li><li><p>设置“只读”注意：</p><ul><li><p>事务的是否“只读”属性，不同的数据库厂商支持不同。</p></li><li><p>通常而言只读属性的应用要参考厂商的具体支持说明，比如，</p><p>Oracle的“readOnly”不起作用，不影响其增删改查；</p><p>Mysql的“readOnly”为true，只能查，增删改则出异常。</p></li></ul></li></ul><h4 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h4><ul><li>事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</li><li>设置事务时注意点：为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。</li></ul><h4 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚"></a>事务回滚</h4><ul><li>默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚。</li><li>自定义回滚策略：<ul><li>声明事务在遇到特定的检查性异常时像遇到运行期异常那样回滚；</li><li>声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</li></ul></li></ul><h4 id="Spring事务状态"><a href="#Spring事务状态" class="headerlink" title="Spring事务状态"></a>Spring事务状态</h4><ul><li>事务接口<ul><li>通过事务管理器获取TransactionStatus实例；</li><li>控制事务在回滚或提交的时候需要应用对应的事务状态；</li><li>Spring事务接口：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Spring事务状态接口</span></div><div class="line"><span class="comment">//通过调用PlatfromTransactionManager的getTransaction()获取事务状态实例</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;<span class="comment">// 是否是新的事务</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavePoint</span><span class="params">()</span></span>;<span class="comment">// 是否有恢复点</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;<span class="comment">// 设置为只回滚</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">//是否为只回滚</span></div><div class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h4><p>编程式事务实现方式</p><ul><li>事务管理器（PlatformTransactionManager）方式<ul><li>类似应用JTA UserTransaction API方式，但异常处理更简洁；；</li><li>核心类为：Spring事务管理的三个接口类以及JdbcTemplate类。</li></ul></li><li>模板事务（TransactionTemplate）的方式<ul><li>此为Spring官方团队推荐的编程式事务管理方式；</li><li>主要工具为JdbcTemplate类。</li></ul></li></ul><h4 id="编程式事务实现案例"><a href="#编程式事务实现案例" class="headerlink" title="编程式事务实现案例"></a>编程式事务实现案例</h4><ul><li><p>事务管理器（PlatformTransactionManager）</p></li><li><p>要介绍的功能是修改数据库中存储的书籍信息</p></li><li>书籍信息包括：ISBN号、名称、价格和出版日期</li><li>会有一个对应的Book类包含上述内容</li></ul><p>下面为Book类中的属性定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> String isbn;</div><div class="line"><span class="keyword">private</span> String name;</div><div class="line"><span class="keyword">private</span> <span class="keyword">float</span> price;</div><div class="line"><span class="keyword">private</span> Date pubdate;</div></pre></td></tr></table></figure><ul><li>步骤：获取事务管理器；创建事务属性对象；获取事务状态对象；创建JDBC模板对象；业务数据操作处理。</li></ul><h4 id="模板事务（TransactionTemplate）案例"><a href="#模板事务（TransactionTemplate）案例" class="headerlink" title="模板事务（TransactionTemplate）案例"></a>模板事务（TransactionTemplate）案例</h4><ul><li>步骤：获取模板对象；选择事务结果类型；业务数据操作处理。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>需要有效的数据源，具体数据源根据实际情况创建</li><li><p>创建编程事务管理对象：</p><ul><li>事务模板（TransactionTemplate）</li><li>事务管理器（PlateformTransactionManager）</li></ul></li><li><p>业务逻辑处理</p><ul><li>基于JdbcTemplate完成业务处理。</li></ul></li></ul><h4 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h4><p>基于AOP模式机制，对方法前后进行拦截。</p><ul><li><p>声明式事务管理的配置类型：</p><ul><li><p>5种类型（?)：独立代理；共享代理；拦截器；</p><p>tx.拦截器；全注释（前三类2.0版后不推荐使用）</p></li></ul></li><li><p>声明式事务管理配置实现方式：</p><ul><li>2种类型的配置实现参考</li><li>声明式事务管理完整案例：书籍管理操作。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Spring事务管理&quot;&gt;&lt;a href=&quot;#Spring事务管理&quot; class=&quot;headerlink&quot; title=&quot;Spring事务管理&quot;&gt;&lt;/a&gt;Spring事务管理&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java事务导引&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是事务&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring-4</title>
    <link href="http://adamzeng.site/2018/10/13/Spring-4/"/>
    <id>http://adamzeng.site/2018/10/13/Spring-4/</id>
    <published>2018-10-13T09:25:36.000Z</published>
    <updated>2018-10-14T05:24:14.294Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDBC-Template"><a href="#JDBC-Template" class="headerlink" title="JDBC Template"></a>JDBC Template</h4><p>使用Spring组件JDBC Template简化持久化操作<a id="more"></a></p><h4 id="JDBC的概念"><a href="#JDBC的概念" class="headerlink" title="JDBC的概念"></a>JDBC的概念</h4><ul><li><p>为了简化持久化操作，Spring在JDBC API之上提供了JDBC Template组件</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw6q9b3d7ij31c0090gqq.jpg" alt="屏幕快照 2018-10-13 下午8.32.51"></p></li></ul><p>####Spring简单封装JDBC API</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fw6qa4bxewj31fq0eqjy2.jpg" alt="屏幕快照 2018-10-13 下午8.33.35"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JDBC API</span></div><div class="line">Statement statement =conn.createStatement();</div><div class="line">ResultSet resultSet=statement.executeQuery(<span class="string">"select count(*) COUNT from student"</span>);</div><div class="line"><span class="keyword">if</span>(resultSet.next()) &#123;</div><div class="line">    Integer count=resultSet.getInt(<span class="string">"COUNT"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//JDBC Template</span></div><div class="line">Integer count =jt.queryForObject(<span class="string">"select count(*) from student"</span>,Integer.class);</div></pre></td></tr></table></figure><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fw6qmde8kuj314a0pak55.jpg" alt="屏幕快照 2018-10-13 下午8.44.10"></p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><ul><li><p>Maven</p><ul><li>Mysql驱动</li><li>Spring组件（core、beans、context、aop）</li><li>JDBC Template（jdbc、tx）</li></ul></li><li><p>Spring配置</p><ul><li>数据源</li><li>JDBC Template</li></ul></li></ul><h4 id="JDBC-Template基本使用"><a href="#JDBC-Template基本使用" class="headerlink" title="JDBC Template基本使用"></a>JDBC Template基本使用</h4><ul><li>execute方法</li><li>update与batchUpdate方法</li><li>query与queryXXX方法</li><li>call方法</li></ul><h4 id="update方法"><a href="#update方法" class="headerlink" title="update方法"></a>update方法</h4><ul><li>对数据进行增删改操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql,Object[] args)</span></span></div><div class="line"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql,Object... args)</span></div></pre></td></tr></table></figure><h4 id="batchUpdate方法"><a href="#batchUpdate方法" class="headerlink" title="batchUpdate方法"></a>batchUpdate方法</h4><ul><li>批量增删改操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] batchUpdate(String[] sql)</div><div class="line"><span class="keyword">int</span>[] batchUpdate(String sql,List&lt;Object[]&gt; args)</div></pre></td></tr></table></figure><h4 id="查询简单数据项"><a href="#查询简单数据项" class="headerlink" title="查询简单数据项"></a>查询简单数据项</h4><ul><li>获取一个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">T <span class="title">queryForObject</span><span class="params">(String sql,Class&lt;T&gt; type)</span></span></div><div class="line">T <span class="title">queryForObject</span><span class="params">(String sql,Object[] args, Class&lt;T&gt; type)</span></div><div class="line">T <span class="title">queryForObject</span><span class="params">(String sql,Class&lt;T&gt; type,Object... arg)</span></div></pre></td></tr></table></figure><ul><li>获取多个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(String sql,Class&lt;T&gt; type)</span></span></div><div class="line">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(String sql,Object[] args,Class&lt;T&gt; type)</span></div><div class="line">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(String sql,Class&lt;T&gt; type,Object... arg)</span></div></pre></td></tr></table></figure><ul><li>查询复杂对象（封装为Map）<ul><li>获取一个</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">Map <span class="title">queryForMap</span><span class="params">(String sql)</span></span></div><div class="line">Map <span class="title">queryForMap</span><span class="params">(String sql,Object[] args)</span></div><div class="line">Map <span class="title">queryForMap</span><span class="params">(String sql,Object... arg)</span></div></pre></td></tr></table></figure><ul><li><ul><li>获取多个</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure><ul><li>查询复杂对象（封装为实体对象）<ul><li>RowMapper接口</li><li>获取一个</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">T <span class="title">queryForObject</span><span class="params">(String sql,RowMapper&lt;T&gt; mapper)</span></span></div><div class="line">T <span class="title">queryForObject</span><span class="params">(String sql,Object[] args,RowMapper&lt;T&gt; mapper)</span></div><div class="line">T <span class="title">queryForObject</span><span class="params">(String sql,RowMapper&lt;T&gt; mapper,Object... arg)</span></div></pre></td></tr></table></figure><ul><li>获取多个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql,RowMapper&lt;T&gt; mapper)</span></span></div><div class="line">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql,Object[] args,RowMapper&lt;T&gt; mapper)</span></div><div class="line">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql,RowMapper&lt;T&gt; mapper,Object... arg)</span></div></pre></td></tr></table></figure><h4 id="持久层实现"><a href="#持久层实现" class="headerlink" title="持久层实现"></a>持久层实现</h4><ul><li>实体类</li><li>DAO<ul><li>注入JdbcTemplate</li><li>声明RowMapper</li></ul></li></ul><p>优缺点分析</p><p>优点：</p><ul><li>简单</li><li>灵活</li></ul><p>确定：</p><ul><li>SQL与Java代码掺杂</li><li>功能不丰富</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>持久化操作特点</p><ul><li>必须</li><li>机械性</li></ul></li><li><p>ORM (Object Relationship Map)</p><ul><li>对象-关系</li></ul></li><li><p>JDBC Template是Spring框架对JDBC操作的封装，简单。灵活但不够强大。</p></li><li>实际应用中还需要和其他ORM框架混合使用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JDBC-Template&quot;&gt;&lt;a href=&quot;#JDBC-Template&quot; class=&quot;headerlink&quot; title=&quot;JDBC Template&quot;&gt;&lt;/a&gt;JDBC Template&lt;/h4&gt;&lt;p&gt;使用Spring组件JDBC Template简化持久化操作
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring-3</title>
    <link href="http://adamzeng.site/2018/10/12/Spring-3/"/>
    <id>http://adamzeng.site/2018/10/12/Spring-3/</id>
    <published>2018-10-12T04:25:18.000Z</published>
    <updated>2018-10-13T09:24:47.793Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring基于AspectJ的AOP开发"><a href="#Spring基于AspectJ的AOP开发" class="headerlink" title="Spring基于AspectJ的AOP开发"></a>Spring基于AspectJ的AOP开发</h4><ul><li>使用AspectJ实现AOP<a id="more"></a><ul><li>注解方式</li><li>XML方式</li></ul></li></ul><h4 id="基于AspectJ的AOP注解开发方式"><a href="#基于AspectJ的AOP注解开发方式" class="headerlink" title="基于AspectJ的AOP注解开发方式"></a>基于AspectJ的AOP注解开发方式</h4><ul><li><p>AspectJ是一个基于Java语言的AOP框架</p></li><li><p>能够使Spring AOP的开发变得简单</p></li><li><p>Spring2.0以后新增了对AspectJ切点表达式支持</p></li><li>@AspectJ是AspectJ1.5新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面<ul><li>新版本Spring框架，建议使用AspectJ方法来开发AOP</li></ul></li><li>使用AspectJ需要导入Spring AOP和AspectJ相关jar包<ul><li>spring-aop-4.2.4.RELEASE.jar</li><li>com.sprngsource.org.aopalliance-1.0.0.jar</li><li>spring-aspects-4.2.4.RELEASE.jar</li><li>com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</li></ul></li></ul><h4 id="注解开发：环境准备"><a href="#注解开发：环境准备" class="headerlink" title="注解开发：环境准备"></a>注解开发：环境准备</h4><h4 id="AspectJ提供不同的通知类型"><a href="#AspectJ提供不同的通知类型" class="headerlink" title="AspectJ提供不同的通知类型"></a>AspectJ提供不同的通知类型</h4><ul><li>@Before前置通知，相当于BeforeAdvice</li><li>@AfterReturning后置通知，相当于AfterReturningAdvice</li><li>@Around环绕通知，相当于MethodInterceptor</li><li>@AfterThrowing异常抛出通知，相当于ThrowAdvice</li><li>@After最终final通知，不管是否异常，该通知都会执行</li><li>@DeclareParents引介通知，相当于IntroductionInterceptor（不要求掌握）</li></ul><h4 id="在通知中通过value属性定义切点"><a href="#在通知中通过value属性定义切点" class="headerlink" title="在通知中通过value属性定义切点"></a>在通知中通过value属性定义切点</h4><ul><li><p>通过execution函数，可以定义切点的方法切入</p></li><li><p>语法：</p><p> —execution(&lt;访问修饰符&gt;?&lt;返回类型&gt;&lt;方法名&gt;(&lt;参数&gt;)&lt;异常&gt;)</p></li><li><p>例如</p><ul><li>匹配所有类public方法execution(public **(…))</li><li>匹配指定包下所有类方法executoin(<em> com.imooc.dao.</em>(…))不包含子包</li><li>execution(<em> com.imooc.dao..</em>(..)) ..*表示包、子孙包下所有类</li><li>匹配指定类所有方法execution(<em> com.imooc.service.UserService.</em>(..))</li><li>匹配实现特定接口所有类方法execution(<em> com.imooc.dao.GenericDAO+.</em>(..))</li><li>匹配所有save开头的方法execution(<em> save</em>(..))</li></ul></li></ul><h4 id="为目标类，定义切面类"><a href="#为目标类，定义切面类" class="headerlink" title="为目标类，定义切面类"></a>为目标类，定义切面类</h4><p>定义切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="function"><span class="keyword">public</span> class <span class="title">MyAspectAnno</span><span class="params">()</span> </span>&#123;&#125;</div></pre></td></tr></table></figure><p>@Before前置通知</p><p>在方法执行之前进行的增强</p><ul><li>可以在方法中传入JoinPoint对象，用来获得切点信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 要增强的代码：</span></div><div class="line"><span class="meta">@Before</span>(<span class="string">"execution(* com.imooc.spring.demo1.UserDao.save(..))"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"==============前置通知======="</span>+joinPoint);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>@AfterReturning后置通知</p><ul><li>通过returning属性可以定义方法返回值，作为参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AfterReturning</span>(value<span class="string">"execution(* com.imooc.spring.demo1.UserDao.update(..))"</span>,returning=<span class="string">"returning"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returning)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"=========后置通知========="</span>+returning)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>@Around环绕通知</p><ul><li>around方法的返回值就是目标代理方法执行返回值</li><li>参数为ProceedingJoinPoint可以调用拦截目标方法执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Around</span>(<span class="string">"execution(* com.imooc.spring.demo1.UserDao.delete(..))"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">    System.out.println(<span class="string">"=======环绕前通知"</span>);</div><div class="line">    Object obj=joinPoint.proceed();</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重点：如果不调用ProceedingJoinPoint的proceed方法，那么目标方法就被拦截了。</p><p>@AfterThrowing异常抛出通知</p><ul><li>通过设置throwing属性，可以设置发生异常对象参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(* com.imooc.spring.demo1.UserDao.find(..))"</span>,throwing=<span class="string">"e"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"==========异常抛出通知=========="</span>+e.getMessage);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>@After最终通知（无论目标方法中是否有异常总是会被执行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* com.imooc.spring.demo1.UserDao.findAll(..))"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"=======最终通知====="</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="通过-Pointcut为切点命名"><a href="#通过-Pointcut为切点命名" class="headerlink" title="通过@Pointcut为切点命名"></a>通过@Pointcut为切点命名</h4><ul><li><p>在每个通知内定义切点，会造成工作量大，不易维护，对于重复的切点，可以使用@Pointcut进行定义</p></li><li><p>切点方法：private void无参数方法，方法名为切点名</p></li><li>当通知多个切点时，可以使用||进行连接</li></ul><h4 id="AspectJ的XML方式进行开发"><a href="#AspectJ的XML方式进行开发" class="headerlink" title="AspectJ的XML方式进行开发"></a>AspectJ的XML方式进行开发</h4><h4 id="使用XML配置切面"><a href="#使用XML配置切面" class="headerlink" title="使用XML配置切面"></a>使用XML配置切面</h4><ul><li><p>编写切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectJXML</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"前置增强=========="</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"后置增强=========="</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"环绕前增强==========="</span>);</div><div class="line">        Object obj=joinPoint.proceed();</div><div class="line">        System.out.println(<span class="string">"环绕后增强==========="</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Throwable e)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"异常抛出通知=========="</span>+e.getMessage());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"最终通知============"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>完成切面类的配置</p><p>\<bean id="myAspectJXML" class="com.imooc.spring.demo2.MyAspectJXML"></bean></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Spring基于AspectJ的AOP开发&quot;&gt;&lt;a href=&quot;#Spring基于AspectJ的AOP开发&quot; class=&quot;headerlink&quot; title=&quot;Spring基于AspectJ的AOP开发&quot;&gt;&lt;/a&gt;Spring基于AspectJ的AOP开发&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用AspectJ实现AOP
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>spring-2</title>
    <link href="http://adamzeng.site/2018/10/10/spring-2/"/>
    <id>http://adamzeng.site/2018/10/10/spring-2/</id>
    <published>2018-10-10T10:31:58.000Z</published>
    <updated>2018-10-12T04:24:37.934Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h4><p>面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术，AOP是OOP的延续，是软件开发中的一个热点，是Spring框架中的一个重要内容。<a id="more"></a></p><ul><li><p>AOP Aspect Oriented Programming 面向切面编程</p></li><li><p>AOP采取横向抽取机制，取代了传统纵向集成体系重复性代码（性能监视、事务管理、安全检查、缓存）</p></li></ul><p>AOP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>&#123;</div><div class="line">        checkPrivilege()</div><div class="line">        <span class="comment">//保存用户</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>&#123;</div><div class="line">        <span class="comment">//修改用户</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(User user)</span></span>&#123;</div><div class="line">        <span class="comment">//删除用户</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(User user)</span></span>&#123;</div><div class="line">        <span class="comment">//查询用户</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPrivilege</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你不可能在每一个save方法里面去写一个checkPrivilege(),这样就比较low了。</p><p>因为实际业务中可能有上百个类。</p><p>传统方式————&gt;纵向继承。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDaoImpl</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPrivilege</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDaoImpl</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>&#123;</div><div class="line">        checkPrivilege()</div><div class="line">        <span class="comment">//保存用户</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而AOP采用的是<strong>横向抽取机制</strong>——&gt;代理机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>&#123;</div><div class="line">        <span class="comment">//保存用户</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>UserDaoImpl——————&gt;Proxy</p><p>AOP底层的实现就是一个代理机制</p><p>Spring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类植入增强代码。</p><h4 id="AOP相关术语"><a href="#AOP相关术语" class="headerlink" title="AOP相关术语"></a>AOP相关术语</h4><p>Joinpoint（连接点）：所谓连接点是指那些被拦截到的店。在Spring中，这些点指的是方法，因为Spring只支持方法类型的连接点。</p><p>Pointcut（切入点）：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。</p><p>Advice（通知/增强）：所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。</p><p>通知分为前置通知，后置通知，异常通知，最终通知，环绕通知（切面要完成的功能）</p><p>Introduction（引介）：引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field。</p><p>Target(目标对象)：代理的目标对象</p><p>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载器织入。</p><p>Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类。</p><p>Aspect（切面）：是切入点和通知（引介）的结合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">find</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(User user)</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>Joinpoint(连接点)：指的是可以被拦截到的点。</p><ul><li>增删改查这些方法都可以被增强，这些方法称为是连接点。</li></ul></li><li><p>Pointcut（切入点）：指的是真正被拦截到的点。</p><ul><li>只想对save方法进行增强（做权限校验），save方法称为是切入点。</li></ul></li><li><p>Advice（通知）：拦截后要做的事情。</p><ul><li>对save方法要进行权限校验，权限校验的方法称为是通知。</li></ul></li><li><p>Spring只负责方法层面的增强！！！！</p></li><li>Target（目标）：被增强的对象（实现类UserDaoImpl）</li><li><p>Weaving（织入）：将Advice应用到Target的过程</p><ul><li>将权限校验应用到UserDaoImpl的save方法的这个过程。</li></ul></li><li><p>Proxy（代理）：被应用了增强后，产生一个代理对象。</p></li><li>Aspect（切面）：就是切入点和通知的组合。</li></ul><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>使用JDK本身的一个类</p><h4 id="使用CGLIB生成代理"><a href="#使用CGLIB生成代理" class="headerlink" title="使用CGLIB生成代理"></a>使用CGLIB生成代理</h4><p>非常底层的字节码增强技术</p><p>生成一个类来继承目标类。</p><ul><li>对于不使用接口的业务类，无法使用JDK动态代理</li><li>CGlib采用非常底层字节码技术，可以为一个类创建子类，解决无接口代理问题。</li></ul><h4 id="代理知识总结"><a href="#代理知识总结" class="headerlink" title="代理知识总结"></a>代理知识总结</h4><ul><li>Spring在运行期，生成动态代理对象，不需要特殊的编译期</li><li>Spring AOP的底层就是通过JDK动态代理或CGlib动态代理技术为目标Bean执行横向织入<ul><li>若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。</li><li>若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。</li></ul></li><li>程序中应优先对接口创建代理，便于程序解耦维护</li><li>标记为final的方法，不能被代理，因为无法进行覆盖<ul><li>JDK动态代理，是针对接口生成子类，接口中方法不能使用final修饰</li><li>CGLib是针对目标类生产子类，因此类或方法不能使用final的。</li></ul></li><li>Spring只支持方法连接点，不支持属性连接点。</li></ul><h4 id="Spring-AOP增强类型"><a href="#Spring-AOP增强类型" class="headerlink" title="Spring AOP增强类型"></a>Spring AOP增强类型</h4><ul><li>AOP联盟为通知Advice定义了org.aopalliance.aop.Interface.Advice</li><li>Spring按照通知Advice在目标类方法的连接点位置，可以分为5类<ul><li>前置通知org.springframework.aop.MethodBeforeAdvice<ul><li>在目标方法执行前实施增强  </li></ul></li><li>后置通知org.springframework.aop.AfterReturningAdvice<ul><li>在目标方法执行后实施增强</li></ul></li><li>环绕通知org.aopalliance.intercept.MethodInterceptor<ul><li>在目标执行前后实施增强</li></ul></li><li>在异常抛出通知org.springframework.aop.ThrowsAdvice<ul><li>在方法池异常后实施增强</li></ul></li><li>引介通知org.springframework.aop.IntroductionInterceptor<ul><li>在目标类中添加一些新的方法和属性</li></ul></li></ul></li></ul><h4 id="Spring-AOP的切面类型"><a href="#Spring-AOP的切面类型" class="headerlink" title="Spring AOP的切面类型"></a>Spring AOP的切面类型</h4><ul><li>Advisor：代表一般切面，Advice本身就是一个切面，对目标类所有方法进行拦截</li><li><p>PointcutAdvisor：代表具有切点的切面，可以指定拦截目标类方法</p></li><li><p>IntroductionAdvisor：代表引介切面，针对引介通知而使用切面（不要求掌握）</p></li></ul><h4 id="Advisor切面案例"><a href="#Advisor切面案例" class="headerlink" title="Advisor切面案例"></a>Advisor切面案例</h4><p>对目标类里面的所有方法都完成增强工作</p><ul><li><p>ProxyFactoryBean常用可配置属性</p><ul><li><p>target：代理的目标对象</p></li><li><p>proxyInterfaces：代理要实现的接口</p><ul><li><p>如果多个接口可以使用以下格式赋值</p><p>\<list></list></p><p>​    \<value>\</value></p><p>…</p><p>\&lt;\list&gt;</p></li></ul></li></ul></li></ul><h4 id="拦截其他属性的配置"><a href="#拦截其他属性的配置" class="headerlink" title="拦截其他属性的配置"></a>拦截其他属性的配置</h4><ul><li>proxyTargetClass：是否对类代理而不是接口，设置为true时，使用CGLib代理</li><li>interceptorNames：需要织入目标的Advice</li><li>singleton：返回代理是否为单实例，默认为单例</li><li>optimize：当设置为true时，强制使用CGLib</li></ul><p>PointcutAdvisor切点切面</p><ul><li><p>使用普通Advice作为切面，将对目标类所有方法进行拦截，不够灵活，在实际开发中常采用带有切点的切面</p></li><li><p>常用PointcutAdvisor实现类</p><ul><li>DefaultPointcutAdvisor最常用的切面类型，它可以通过任意Pointcut和Advice组合定义切面</li><li>JdkRegexpMethodPointcut构造正则表达式切点</li></ul></li></ul><h4 id="自动创建代理"><a href="#自动创建代理" class="headerlink" title="自动创建代理"></a>自动创建代理</h4><p>每一个需要产生代理的对象都需要一个ProxyFactoryBean</p><ul><li>前面的案例中，每一个代理都是通过ProxyFactoryBean织入切面代理，在实际开发中，非常多的Bean每个都配置ProxyFactoryBean开发维护量巨大</li><li>解决方案：自动创建代理<ul><li>BeanNameAutoProxyCreator根据Bean名称创建代理</li><li>DefaultAdvisorAutoProxyCreator根据Advisor本身包含信息创建代理</li><li>AnnotationAwareAspectJAutoProxyCreator基于Bean中的AspectJ注解进行自动代理</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>AOP是面向切面编程，是面向对象的进化版</p><p>底层原理采用的是代理机制，根据类是否实现接口，如果实现了接口就是采用动态代理，没有实现接口就使用GClib的方式。</p><p>一般切面是对这个类中所有方法增强</p><p>还有一种对某个类某些方法增强，如果有一个类，就需要使用proxyFactoryBean，如果类很多，就需要有很多proxyFactoryBean，维护量很大。</p><p>所以使用自动创建代理的方式</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Spring的AOP&quot;&gt;&lt;a href=&quot;#Spring的AOP&quot; class=&quot;headerlink&quot; title=&quot;Spring的AOP&quot;&gt;&lt;/a&gt;Spring的AOP&lt;/h4&gt;&lt;p&gt;面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术，AOP是OOP的延续，是软件开发中的一个热点，是Spring框架中的一个重要内容。
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>常见命令</title>
    <link href="http://adamzeng.site/2018/10/07/%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://adamzeng.site/2018/10/07/常见命令/</id>
    <published>2018-10-07T00:27:46.000Z</published>
    <updated>2018-10-07T04:41:24.230Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Privileged-EXEC-Password-Example"><a href="#Privileged-EXEC-Password-Example" class="headerlink" title="Privileged EXEC Password Example"></a>Privileged EXEC Password Example</h4><a id="more"></a><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvzcwcrt38j31180o4jtj.jpg" alt="屏幕快照 2018-10-07 上午11.31.44"></p><h4 id="User-EXEC-Password-Example"><a href="#User-EXEC-Password-Example" class="headerlink" title="User EXEC Password Example"></a>User EXEC Password Example</h4><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvzd3bk6p6j31120nota6.jpg" alt="屏幕快照 2018-10-07 上午11.38.27"></p><h4 id="VTY-Line-Password-Example"><a href="#VTY-Line-Password-Example" class="headerlink" title="VTY Line Password Example"></a>VTY Line Password Example</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvzd43n33xj31120no75k.jpg" alt="屏幕快照 2018-10-07 上午11.39.15"></p><h4 id="Encrypt-Password"><a href="#Encrypt-Password" class="headerlink" title="Encrypt Password"></a>Encrypt Password</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvzd5429j5j311y0jw40t.jpg" alt="屏幕快照 2018-10-07 上午11.40.11"></p><h4 id="Banner-Message"><a href="#Banner-Message" class="headerlink" title="Banner Message"></a>Banner Message</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvzd76b3jkj310w05uag2.jpg" alt="屏幕快照 2018-10-07 上午11.41.48"></p><h4 id="Viewing-and-Saving-the-Configuration"><a href="#Viewing-and-Saving-the-Configuration" class="headerlink" title="Viewing and Saving the Configuration"></a>Viewing and Saving the Configuration</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvzd9kmt73j31160p4jz5.jpg" alt="屏幕快照 2018-10-07 上午11.44.26"></p><h4 id="Switch-Configuration-Tasks"><a href="#Switch-Configuration-Tasks" class="headerlink" title="Switch Configuration Tasks"></a>Switch Configuration Tasks</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvzdckcrcbj30us0oqtb7.jpg" alt="屏幕快照 2018-10-07 上午11.46.50"></p><h4 id="Configure-Router-Interface"><a href="#Configure-Router-Interface" class="headerlink" title="Configure Router Interface"></a>Configure Router Interface</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvzdrx6zqyj310e0e4acy.jpg" alt="屏幕快照 2018-10-07 下午12.02.05"></p><h4 id="Configuring-a-Switch-Default-Gateway"><a href="#Configuring-a-Switch-Default-Gateway" class="headerlink" title="Configuring a Switch Default Gateway"></a>Configuring a Switch Default Gateway</h4><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvzjfisza8j30zw0dmjtd.jpg" alt="屏幕快照 2018-10-07 下午3.17.45"></p><h4 id="IOS-Ping-Indicators"><a href="#IOS-Ping-Indicators" class="headerlink" title="IOS Ping Indicators"></a>IOS Ping Indicators</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvzji9539sj314a0tin99.jpg" alt="屏幕快照 2018-10-07 下午3.20.17"></p><h4 id="tracert-and-traceroute"><a href="#tracert-and-traceroute" class="headerlink" title="tracert and traceroute"></a>tracert and traceroute</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvzjt2zw1lj30z20oun82.jpg" alt="屏幕快照 2018-10-07 下午3.30.37"></p><h4 id="Show-running-config"><a href="#Show-running-config" class="headerlink" title="Show running-config"></a>Show running-config</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvzjwra97aj30zo0nwwi6.jpg" alt="屏幕快照 2018-10-07 下午3.34.20"></p><h4 id="Show-ip-route"><a href="#Show-ip-route" class="headerlink" title="Show ip route"></a>Show ip route</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvzk3r2u70j310o0nqade.jpg" alt="屏幕快照 2018-10-07 下午3.41.04"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Privileged-EXEC-Password-Example&quot;&gt;&lt;a href=&quot;#Privileged-EXEC-Password-Example&quot; class=&quot;headerlink&quot; title=&quot;Privileged EXEC Password Example&quot;&gt;&lt;/a&gt;Privileged EXEC Password Example&lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring(1)</title>
    <link href="http://adamzeng.site/2018/10/06/Spring-1/"/>
    <id>http://adamzeng.site/2018/10/06/Spring-1/</id>
    <published>2018-10-06T09:34:36.000Z</published>
    <updated>2018-10-10T09:36:01.305Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Spring是一个开源框架<a id="more"></a></p></li><li><p>Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能</p></li><li>Spring是JavaSE/EE的一站式框架</li></ul><p>####方便解耦，简化开发</p><p>Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理</p><h4 id="AOP编程的支持"><a href="#AOP编程的支持" class="headerlink" title="AOP编程的支持"></a>AOP编程的支持</h4><p>Spring提供面向切面编程，可以方便的实现对程序进行拦截、运行监控等功能</p><h4 id="声明式事务的支持"><a href="#声明式事务的支持" class="headerlink" title="声明式事务的支持"></a>声明式事务的支持</h4><p>只需要通过配置就可以完成对事务的管理，而无需时候手动编程</p><h4 id="方便程序的测试"><a href="#方便程序的测试" class="headerlink" title="方便程序的测试"></a>方便程序的测试</h4><p>Spring对Junit4支持，可以通过注解方便的测试Spring程序</p><h4 id="方便集成各种优秀框架"><a href="#方便集成各种优秀框架" class="headerlink" title="方便集成各种优秀框架"></a>方便集成各种优秀框架</h4><p>Spring不排斥各种优秀框架</p><h4 id="降低Java-EE-API的使用难度"><a href="#降低Java-EE-API的使用难度" class="headerlink" title="降低Java EE API的使用难度"></a>降低Java EE API的使用难度</h4><p>Spring封装了EE的较难用的API</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvyoyu6iwbj314y0pcdsw.jpg" alt="屏幕快照 2018-10-06 下午8.43.36"></p><h4 id="Spring-IOC的底层原理"><a href="#Spring-IOC的底层原理" class="headerlink" title="Spring IOC的底层原理"></a>Spring IOC的底层原理</h4><p>传统方式的开发</p><p>UserService us=new UserService();</p><p>但是我们要面向接口编程</p><p>UserService us= new UserServiceImp1();</p><p>但是这样也不好</p><p>ocp原则：open-close原则，对程序扩展是open的，对修改程序代码是close。</p><p>尽量做到不修改程序的源码，实现对程序的扩展。</p><p>使用一个设计模式，工厂模式！！！！</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvypae46hoj30mi0d277g.jpg" alt="屏幕快照 2018-10-06 下午8.54.45"></p><p>把获取UserService的方法放在FactoryBean中来管理。UserService与UserServiceImp1之间就没有直接的耦合关系了。</p><p>但我们要达到真正的解耦，需要使用：</p><ul><li>工厂+反射+配置文件</li></ul><p>配置文件：\<bean id="us" class="com.adam.UserServiceImp1"></bean></p><p>工厂类里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryBean</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        反射</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Spring-IOC的快速入门案例"><a href="#Spring-IOC的快速入门案例" class="headerlink" title="Spring IOC的快速入门案例"></a>Spring IOC的快速入门案例</h4><ul><li>下载Spring开发包</li><li>复制Spring开发jar包到工程</li><li>理解IOC控制反转和DI依赖注入</li><li>编写Spring核心配置文件</li><li>在程序中读取Spring配置文件，通过Spring框架获得bean，完成相应操作</li></ul><h4 id="引入jar包"><a href="#引入jar包" class="headerlink" title="引入jar包"></a>引入jar包</h4><p>直接在pom.xml来编写dependency</p><p>Maven会自动把相应的jar包加入External Library当中。</p><h4 id="IOC到底是什么"><a href="#IOC到底是什么" class="headerlink" title="IOC到底是什么"></a>IOC到底是什么</h4><ul><li><p>IOC Inverse of control反转控制的概念，就是将原本在程序中手动创建UserService对象的控制权，交由Spring框架管理。</p></li><li><p>简单说，就是创建UserService对象控制权被反转到了Spring框架</p></li><li>DI Dependency Injection依赖注入的概念，就是在Spring创建这个对象的过程中，将这个对象所依赖的属性注入进去。</li></ul><p>####Spring的工厂类</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvytgzq87fj30w00sqn77.jpg" alt="屏幕快照 2018-10-06 下午11.18.56"></p><h4 id="Spring的Bean管理（XML方式）"><a href="#Spring的Bean管理（XML方式）" class="headerlink" title="Spring的Bean管理（XML方式）"></a>Spring的Bean管理（XML方式）</h4><p>Spring是如何来生成实例的呢？</p><p>三种实例化Bean的方式</p><ul><li>使用类构造器实例化（默认无参数）</li><li>使用静态工厂的方式实例化（简单工厂模式）</li><li>使用实例工厂方法实例化(工厂方法模式)</li></ul><p>一般情况下采用无参构造器的方式</p><p>除非类特别复杂。</p><h4 id="Bean常用的相关配置"><a href="#Bean常用的相关配置" class="headerlink" title="Bean常用的相关配置"></a>Bean常用的相关配置</h4><p>id和name</p><ul><li>一般情况下，装配一个Bean时，通过指定一个id属性作为Bean的名称。</li><li><p>id属性在IOC容器中必须是唯一的</p></li><li><p>如果Bean的名称中含有特殊字符，就需要使用name属性。</p></li></ul><p>class</p><ul><li><p>class用于设置一个类的完全路径名称，主要作用是IOC容器生成类的实例</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvzsf0rdcwj30xq0h4dpw.jpg" alt="屏幕快照 2018-10-07 下午8.28.16"></p><h4 id="Spring容器中Bean的生命周期"><a href="#Spring容器中Bean的生命周期" class="headerlink" title="Spring容器中Bean的生命周期"></a>Spring容器中Bean的生命周期</h4><p>Spring初始化bean或销毁bean时，有时需要做一些处理工作，因此spring可以在创建和销毁bean的时候调用bean的两个生命周期方法。</p><bean id="xxx" class="...Yoo" init-method="init" destory-method="destory"><p>当bean被载入到容器的时候调用init</p><p>当bean从容器中删除的时候调用destory(scope=singleton有效)</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvzuf6vxohj30y40rck47.jpg" alt="屏幕快照 2018-10-07 下午9.37.51"></p><ol><li>instantiate bean对象</li><li>populate properties封装属性</li><li>如果Bean实现BeanNameAware执行setBeanName</li><li>如果Bean实现BeanFactoryAware或者ApplicationContextAware设置工厂setBeanFactory或者上下文对象setApplicationContext</li><li>如果存在类实现BeanPostProcessor(后处理Bean)，执行postProcessBeforeInitialization</li><li>如果Bean实现InitializingBean执行afterPropertiesSet</li><li>调用\<bean init-method="init">指定初始化方法init</bean></li><li>如果过存在类实现BeanPostProcessor(处理Bean)，执行postProcessAfterInitialization。</li><li>执行业务处理</li><li>如果Bean实现DisposableBean执行destroy</li><li>调用\<bean destroy-method="customerDestroy">指定销毁方法</bean></li></ol></bean></li></ul><h4 id="Spring的属性注入"><a href="#Spring的属性注入" class="headerlink" title="Spring的属性注入"></a>Spring的属性注入</h4><ul><li>对于类成员变量，注入方式有三种</li></ul><ol><li>构造函数注入</li><li>属性setter方法注入</li><li>接口注入</li></ol><ul><li>Spring支持前两种</li></ul><h4 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h4><ul><li>通过构造方法注入Bean的属性值或依赖的对象，它保证了Bean实例在实例化后就可以使用。</li><li>构造器注入在\<constructor-arg>元素里声明的属性</constructor-arg></li></ul><h4 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h4><ul><li>使用set方法注入，在Spring配置文件中，通过\<property>设置注入属性</property></li><li>对于对象属性，同样需要在Spring配置文件的\<property>设置注入属性，而且还要在Spring配置文件中设置该对象的bean标签，且值标签不是value而是ref。</property></li></ul><h4 id="p名称空间注入"><a href="#p名称空间注入" class="headerlink" title="p名称空间注入"></a>p名称空间注入</h4><ul><li>使用p命名空间</li><li>为了简化XML文件配置，Spring从2.5开始引入一个新的p名称空间</li><li>p:\&lt;属性名&gt;=”xxx”引入常量值</li><li>p:\&lt;属性名&gt;-ref=”xxx”引用其他对象</li></ul><h4 id="SpEL注入"><a href="#SpEL注入" class="headerlink" title="SpEL注入"></a>SpEL注入</h4><ul><li>SpEL：Spring expression language，spring表达式语言，对依赖注入进行简化</li><li>语法:#{表达式}</li><li>\<bean id="" value="#{表达式}"></bean></li></ul><p>SpEL表达式语言</p><p>语法：#{}</p><p>#{‘hello’}:使用字符串</p><p>#{beanId}:使用另一个bean</p><p>#{beanId.content.toUpperCase()}:使用指定名属性，并使用方法</p><p>#{T(java.lang.Math).PI}:使用静态字段或方法</p><h4 id="复杂类型的属性注入"><a href="#复杂类型的属性注入" class="headerlink" title="复杂类型的属性注入"></a>复杂类型的属性注入</h4><ul><li>数组类型的属性注入</li><li>List集合类型的属性注入</li><li>Set集合类型的属性注入</li><li>Map集合类型的属性注入</li><li>Properties类型的属性注入</li></ul><h4 id="Spring的Bean管理-注解方式"><a href="#Spring的Bean管理-注解方式" class="headerlink" title="Spring的Bean管理(注解方式)"></a>Spring的Bean管理(注解方式)</h4><p>使用注解定义Bean</p><ul><li><p>Spring2.5引入使用注解去定义Bean</p><ul><li>@Component描述Spring框架中Bean</li></ul></li><li><p>除了@Component外，Spring提供了3个功能基本和@Component等效的注解 </p><ul><li>@Repository用于对DAO实现类进行标注</li><li>@Service用于对Service实现类进行标注</li><li>@Controller用于对Controller实现类进行标注</li></ul></li><li><p>这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强</p></li></ul><p>使用注解方式如果没有set方法，注解写在属性上</p><p>如果有set方法，注解写在set方法上。</p><ul><li>使用@Autowired进行自动注入<ul><li>如果存在两个相同Bean类型相同，则按照名称注入</li></ul></li></ul><ul><li>@Autowired注入时可以针对成员变量或者set方法</li><li>通过@Autowired的required属性，设置一定要找到匹配的Bean</li><li>使用@Qualifier指定注入Bean的名称</li><li>使用@Qualifier指定Bean名称后，注解Bean必须指定相同名称</li><li>Spring提供对JSR-250中定义@Resource标准注解的支持</li><li>@Resource和@Autowired注解方式类似</li></ul><h4 id="Spring的其他注解"><a href="#Spring的其他注解" class="headerlink" title="Spring的其他注解"></a>Spring的其他注解</h4><p>Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean的时候调用bean的两个生命周期方法。</p><bean id="xxx" class="...Yoo" init-method="init" destroy-method="destroy"><p>当bean被载入到容器的时候调用</p><p>init</p><p>注解方式下：</p><ul><li>@PostConstruct</li><li>初始化</li></ul><p>当bean从容器中删除的时候调用</p><p>destroy(scope=singleton有效)注解方式如下：</p><ul><li>@PreDestroy</li><li>销毁</li></ul><h4 id="Bean的作用范围"><a href="#Bean的作用范围" class="headerlink" title="Bean的作用范围"></a>Bean的作用范围</h4><ul><li>使用注解配置的Bean和\<bean>配置的一样，默认作用范围都是singleton</bean></li><li>@Scope注解用于指定Bean的作用范围</li><li>通过Scope来指定是单例还是多例（加一个@Scope(“prototype”)在Bean上面）</li></ul><p>传统XML配置和注解配置混合使用</p><h4 id="XML方法的优势"><a href="#XML方法的优势" class="headerlink" title="XML方法的优势"></a>XML方法的优势</h4><ul><li>结构清晰，易于阅读</li></ul><h4 id="注解方法的优势"><a href="#注解方法的优势" class="headerlink" title="注解方法的优势"></a>注解方法的优势</h4><ul><li>开发便捷，属性注入方便</li></ul><p>各司其职，</p><p>XML用于管理我们的类，注解用于完成属性注入</p><h4 id="XML与注解的整合开发"><a href="#XML与注解的整合开发" class="headerlink" title="XML与注解的整合开发"></a>XML与注解的整合开发</h4><ul><li>引入context命名空间</li><li>在配置文件中添加context:annotation-config标签</li></ul></bean>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Spring是一个开源框架
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型和线程</title>
    <link href="http://adamzeng.site/2018/10/02/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://adamzeng.site/2018/10/02/Java内存模型和线程/</id>
    <published>2018-10-02T10:10:25.000Z</published>
    <updated>2018-10-05T09:33:15.223Z</updated>
    
    <content type="html"><![CDATA[<p>计算机的运行速度<a id="more"></a>与它的存储和通信子系统速度差距太大，大量的时间都花费在磁盘I/O、网络通信或者数据库访问上。如果不希望处理器在大部分时都处于等待其他资源的状态，就必须使用一些手段去把处理器的运算能力”压榨”出来，否则就会造成很大的浪费，而让计算机同时处理几项任务则是最容易想到、也被证明是非常有效的”压榨”手段。</p><p>一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Second，TPS）是最重要的指标之一，它代表着一秒内服务端同时能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。</p><h4 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h4><p>“让计算机并发执行若干个运算任务”与”更充分地利用计算机处理器的效能”之间的因果关系，看起来顺理成章，实际上它们之间没有想象中的那么简单，其中一个重要的复杂性来源是绝大多数的运算任务都不可能只靠处理器”计算”就能完成，处理器至少要与内存交互，如读取数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。由于计算机的存储设备与处理器运算速度的有几个数据级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来了更高的复杂度，因为它引入了一个新的问题：缓存一致性(Cache Coherence)。在多处理器系统中，每个处理器有自己的高速缓存，而它们又共享同一主内存(Main Memory)，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性地问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI，MESI(Illinois Protocol)、MOSI、Synapse、Firefly及Dragon Protocol等。</p><p>内存模型这个词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有 具有很高的可比性。</p><p>除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序优化类似，Java虚拟机的即时编译器中也有类似的指令重排序(Instruction Reorder)优化。</p><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>Java虚拟机规范中试图定义一种Java内存模型(Java Memory Model, JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景下就必须针对不同的平台来编写程序。</p><p>定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发访问操作不会产生歧义：但是，也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中的某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，在JDK1.5(实现了JSR-133)发布后，Java内存模型已经成熟和完善起来了。</p><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（variable）与Java编程中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</p><p>Java内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与介绍物理硬件时的主内存名字一样,两者也可以互相类比，但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系。</p><p>这里所讲的主内存、工作内存与JVM内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施)可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。</p><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外，这个问题在后面再说）。</p><ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java内存模型只要求上述两个模型必须按顺序执行，而没有保证是连续执行。也就是说，read和load之间、store与write之间是可插入其他指令的，如对主内存中的变量a，b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则:</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中”诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li></ul><p>稍后介绍的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下安全的。由于这种定义相当严谨但又十分烦琐，实践起来很麻烦，所以在后面笔者将介绍这种定义的一个等效判断原则——先行发生原则，用来确定一个访问在并发环境下是否安全。</p><h4 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h4><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。了解volatile变量的语义对后面了解多线程操作的其他特性很有意义。</p><p>Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，笔者先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。</p><p>当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的”可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量才会对线程B可见。</p><p>关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立:”volatile”变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的。这句话的论据部分并没有错，但是其论据并不能得出”基于volatile变量的运算在并发下是安全的”这个结论。volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性的问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因。</p><p>这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是20000。读者运行完这段代码之后，并不会获得期望的结果，而且会每次运行程序，输出的结果都不一样，都是一个小于200000的数字，这是为什么呢？</p><p>问题就出现在自增运算”race++“之中，我们用Javap反编译这段代码后会得到代码清单12-2，发现只有一行代码的increase()方法在Class文件中是由4条字节码指令构成的（return指令不是有race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。</p><h4 id="Java内存模型下的一些”天然的“先行发生关系"><a href="#Java内存模型下的一些”天然的“先行发生关系" class="headerlink" title="Java内存模型下的一些”天然的“先行发生关系"></a>Java内存模型下的一些”天然的“先行发生关系</h4><p>如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p><ul><li>程序次序规则（Prohram Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“同样是指时间上的先后顺序。</li><li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的”后面“同样是指时间上的先后顺序。</li><li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行于对此线程的终止检测，我可以通过Thread.join() 方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li><li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt()方法检测到是否有中断发生。</li><li>对象中介规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li><li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li></ul><p>Java语言无须任何同步手段保障就能成立的先行发生规则就只有上面这些了。</p><p>下面演示一下如何使用这些规则去判定操作间是否具备顺序性，对于读写共享变量的操作来说，就是线程是否安全，读者还可以从下面这个例子中感受一下”时间上的先后顺序“与”先行发生“之间有什么不同。</p><h4 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h4><p>并发不一定要依赖多线程（如PHP中很常见的多线程并发），但是在Java里面谈论并发，大多数都与线程脱不开关系。既然我们这本书探讨的话题是Java虚拟机的特性，那讲到Java线程，我们就从Java线程在虚拟机中的实现开始讲起。</p><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>我们知道，线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等)，又可以独立调度，（线程是CPU调度的基本单位）。</p><p>主流的炒作系统都提供了线程实现，Java语言则提供了不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行start()且还未结束的java.lang.Thread类的实例就代表了一个线程。我们注意到Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的。在Java API中，一个Native方法往往意味着这个方法没有使用Native方法，不过，通常最高效率的手段来实现（当然也可能是为了执行效率而使用Native方法，不过，通常最高效率的手段也就是平台相关手段）。正因为如此，作者把本节的标题定为“线程的实现”而不是“Java线程的实现”。</p><p>实现线程主要有3种方式：使用用户线程加轻量级进程混合实现。</p><h4 id="使用用户线程加轻量级进程混合实现"><a href="#使用用户线程加轻量级进程混合实现" class="headerlink" title="使用用户线程加轻量级进程混合实现"></a>使用用户线程加轻量级进程混合实现</h4><p>线程除了依赖内核实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式。在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程，被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为N：M的关系，这种就是多对多的线程模型。</p><p>许多Unix系列的操作系统，如Solaris，HP-UX等都提供了N:M的线程模型实现。</p><h4 id="Java的线程实现"><a href="#Java的线程实现" class="headerlink" title="Java的线程实现"></a>Java的线程实现</h4><p>Java线程在JDK1.2之前，是基于称为“绿色线程”（Green Threads）的用户线程实现的，而在JDK1.2中，线程模型替换为基于操作系统原生线程模型来实现。因此，在目前的JDK版本中，操作系统支持怎样的线程模型，在很大程度上决定了Java虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也并未限定Java线程需要使用哪种线程模型来实现。</p><p>对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的。</p><p>而在Solaris平台中，由于操作系统的线程特性可以同时支持一对一（通过Bound Threads或Alternate Libthread实现）及多对多（通过LWP/Thread Based Synchronization实现）的线程模型，因此在Solaris版的JDK中也对应提供了两个平台专有的虚拟机参数：-XX：+UseLWPSynchronization（默认值）和-XX:+UseBoundThreads来明确指定虚拟机使用哪种线程模型。</p><h4 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h4><p>线程调度是指为线程分配处理器使用权的过程，主要的调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。</p><p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的自大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。Lua语言中的”协同例程“就是这类实现。它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。很久以前的Windows3.x系统就是使用协同式来实现多进程多任务的，相当不稳定，一个进程坚持不让出CPU执行时间就可能会导致整个系统崩溃。</p><p>如果使用抢占式调度的多线程系统，那么每个线程将由系统分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，线程本身是没有什么办法的）。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java使用的线程调度方式就是抢占式调度。与前面所说的Windows 3.x的例子相对，在Windows 9x/NT内核中就是使用抢占式来实现多进程的，当一个进程除了问题，我们还可以使用任务管理器把这个进程”杀掉“，而不至于导致系统崩溃。</p><p>虽然Java线程调度是系统自动完成的，但是我们还是可以”建议“系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY),在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。</p><p>不过，线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应，如Solaris中有2147483648（2^32)种优先级，但Windows中就只有7种，比Java线程优先级多的系统还好说，中间留下一点空位就可以了，但比Java线程优先级少的系统，就不得不出现几个优先级系统相同的情况了。</p><h4 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h4><p>在Java语言中（特指JDK1.5以后，即Java内存模型被修正之后的Java语言），不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程保障措施，在第12章我们谈到final关键字带来的可见性时曾经提到过这一点，只要一个不可变的对象被正确地构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致状态，”不可变“带来的安全性是最简单和最纯粹的。</p><p>Java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，如果读者还没想明白这句话，不妨想一想java.lang.String类的对象，它是一个典型的不可变对象，我们调用它的substring()、replace()、和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。</p><p>保证对象的行为不影响自己状态的途径有很多种，其中最简单的就是把对象中带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的。</p><h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>绝对的线程安全完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到”不管运行时环境如何，调用者都不需要任何额外的同步措施“通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。我们可以通过Java API中一个不是”绝对线程安全“的线程安全类来看看这里的”绝对“是什么意思。</p><p>如果说java.util.Vector是一个线程安全的容器，相信所有的Java程序员对此都不会有异议，因为它的add(),get()和size()这类方法都是被synchronized修饰的，尽管这样效率很低，但确实是安全的。但是，即使它所有的方法都被修饰成同步，也不意味着调用它的时候永远都不再需要同步手段了。</p><h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API中大部分的类都是属于线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。</p><h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应该尽量避免。</p><p>一个线程对立的例子是Thread类的suspend()和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是由于这个原因，suspend()和resume()方法已经被JDK声明废弃（@Deprecated）了。常见的线程对立的操作还有System.setIn()、System.setOut()和System.runFinalizersOnExit()等。</p><h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><p>了解了什么是线程安全之后，紧接着的一个问题就是我们应该如何实现线程安全，这听起来似乎是一件由代码如何编写来决定的事情，确实，如何实现线程安全与代码编写有很大的关系，但虚拟机提供的同步和锁机制也起到了非常重要的作用。</p><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p>互斥同步（Mutual Exclusion&amp;Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section)、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果:互斥是方法，同步是目的。</p><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization)。从处理问题的方式上说，互斥同步属于一种悲观策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止),这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机的运行速度
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM类文件结构</title>
    <link href="http://adamzeng.site/2018/09/22/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://adamzeng.site/2018/09/22/JVM类文件结构/</id>
    <published>2018-09-22T09:07:06.000Z</published>
    <updated>2018-09-22T10:43:56.368Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>记得在第一节计算机程序课上我的老师就讲过：“计算机只认识0和1，所以我们写的程序需要经编译器翻译成由0和1构成的二进制格式才能由计算机执行。”10多年时间过去了，今天的计算机仍然只能识别0和1，但由于最近10年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p><p>Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。因此，有一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础。</p><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p><p>根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。</p><p>无符号数属于基本的数据类型，以u1,u2,u4,u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以”_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由表6-1所示的数据项构成。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fviia57et7j30wc0j2ahs.jpg" alt="屏幕快照 2018-09-22 下午8.43.21"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;记得在第一节计算机程序课上我的老师就讲过：“计算机只认识0和1，所以我们写的程序需要经编译器翻译成由0和1构成的二进制格式才能由计算机执行。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ipv6复习</title>
    <link href="http://adamzeng.site/2018/09/22/ipv6%E5%A4%8D%E4%B9%A0/"/>
    <id>http://adamzeng.site/2018/09/22/ipv6复习/</id>
    <published>2018-09-22T00:52:25.000Z</published>
    <updated>2018-09-25T12:13:34.920Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Rule-1-Omit-leading-0s"><a href="#Rule-1-Omit-leading-0s" class="headerlink" title="Rule 1- Omit leading 0s"></a>Rule 1- Omit leading 0s</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvi1ht14d6j311a04swf2.jpg" alt="屏幕快照 2018-09-22 上午11.02.28"></p><p>The first rule to help reduce the notation of IPv6 addresses is to omit any leading 0s (zeros) in any 16-bit section or hextet. For example:<a id="more"></a></p><ul><li><p>01AB can be represented as 1AB</p></li><li><p>09F0 can be represented as 9F0</p></li><li><p>0A00 can be represented as A00</p></li><li><p>00AB can be represented as AB</p></li></ul><p>This rule only applies to leading 0s, NOT to trailing 0s, otherwise the address would be ambiguous. For example, the hextet “ABC” could be either “0ABC” or “ABC0”, but these do not represent the same value.</p><h4 id="Rule-2-Omit-all-0-segments"><a href="#Rule-2-Omit-all-0-segments" class="headerlink" title="Rule 2-Omit all 0 segments"></a>Rule 2-Omit all 0 segments</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvi1p2w4jmj310y06udgo.jpg" alt="屏幕快照 2018-09-22 上午11.09.37"></p><p>The second rule to help reduce the notation of IPv6 addresses is that a double colon (::) can replace any single, contiguous string of one or more 16-bit segments (hextets) consisting of all 0s.</p><p>The double colon (::) can only be used once within an address, otherwise there would be more than one possible resulting address. When used with the omitting leading 0s technique, the notation of IPv6 address can often be greatly reduced. This is commonly known as the compressed format.</p><p>Incorrect address:</p><ul><li>2001:0DB8::ABCD::1234</li></ul><h4 id="IPv6-Address-Types"><a href="#IPv6-Address-Types" class="headerlink" title="IPv6 Address Types"></a>IPv6 Address Types</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvi221eq9xj313u0rwdt2.jpg" alt="屏幕快照 2018-09-22 上午11.21.53"></p><ul><li><p><strong>Unicast</strong> - An IPv6 unicast address uniquely identifies an interface on an IPv6-enabled device. As shown in the figure, a source IPv6 address must be a unicast address.</p></li><li><p><strong>Multicast</strong> - An IPv6 multicast address is used to send a single IPv6 packet to multiple destinations.</p></li><li><p><strong>Anycast</strong> - An IPv6 anycast address is any IPv6 unicast address that can be assigned to multiple devices. A packet sent to an anycast address is routed to the nearest device having that address. Anycast addresses are beyond the scope of this course.</p></li></ul><h4 id="IPv6-prefix-length"><a href="#IPv6-prefix-length" class="headerlink" title="IPv6 prefix length"></a>IPv6 prefix length</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvi2mva3l9j311e0keag2.jpg" alt="屏幕快照 2018-09-22 上午11.41.47"></p><p>Recall that the prefix, or network portion, of an IPv4 address, can be identified by a dotted-decimal subnet mask or prefix length (slash notation). For example, an IPv4 address of 192.168.1.10 with dotted-decimal subnet mask 255.255.255.0 is equivalent to 192.168.1.10/24.</p><p>IPv6 uses the prefix length to represent the prefix portion of the address. IPv6 does not use the dotted-decimal subnet mask notation. The prefix length is used to indicate the network portion of an IPv6 address using the IPv6 address/prefix length.</p><p>The prefix length can range from 0 to 128. A typical IPv6 prefix length for LANs and most other types of networks is /64. This means the prefix or network portion of the address is 64 bits in length, leaving another 64 bits for the interface ID (host portion) of the address.</p><h4 id="IPv6-Unicast-Addresses"><a href="#IPv6-Unicast-Addresses" class="headerlink" title="IPv6 Unicast Addresses"></a>IPv6 Unicast Addresses</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvi2rso5cyj311o0rednl.jpg" alt="屏幕快照 2018-09-22 上午11.46.36"></p><p>An IPv6 unicast address uniquely identifies an interface on an IPv6-enabled device. A packet sent to a unicast address is received by the interface that is assigned that address. Similar to IPv4, a source IPv6 address must be a unicast address. The destination IPv6 address can be either a unicast or a multicast address.</p><h4 id="Structure-of-an-IPv6-Global-Unicast-Address"><a href="#Structure-of-an-IPv6-Global-Unicast-Address" class="headerlink" title="Structure of an IPv6 Global Unicast Address"></a>Structure of an IPv6 Global Unicast Address</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvi36it5syj31640s6n8e.jpg" alt="屏幕快照 2018-09-22 下午12.00.53"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvi38mkgyuj314y0o8dos.jpg" alt="屏幕快照 2018-09-22 下午12.02.46"></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvi3973huxj314m0scdm3.jpg" alt="屏幕快照 2018-09-22 下午12.03.28"></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvi3d061rjj31520tkn9e.jpg" alt="屏幕快照 2018-09-22 下午12.07.03"></p><h4 id="Subnetting-Using-the-Subnet-ID"><a href="#Subnetting-Using-the-Subnet-ID" class="headerlink" title="Subnetting Using the Subnet ID"></a>Subnetting Using the Subnet ID</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvi3qdhoafj30z80omk2j.jpg" alt="屏幕快照 2018-09-22 下午12.19.18"></p><p>The 16 bit subnet ID section of the IPv6 global unicast address can be used by an organization to create internal subnets.</p><p>The subnet ID provides more than enough subnets and host support than will ever be needed in one subnet. For instance, the 16 bit section can:</p><ul><li><p>Create up to 65,536 /64 subnets. This does not include the possibility of borrowing any bits from the interface ID of the address.</p></li><li><p>Support up to 18 quintillion host IPv6 addresses per subnet (i.e., 18,000,000,000,000,000,000).</p></li></ul><p><strong>Note</strong>: Subnetting into the 64 bit Interface ID (or host portion) is also possible but it is rarely required.</p><p>IPv6 subnetting is also easier to implement than IPv4, because there is no conversion to binary required. To determine the next available subnet, just count up in hexadecimal.</p><h4 id="Configure-a-Next-Hop-Static-IPv6-Route"><a href="#Configure-a-Next-Hop-Static-IPv6-Route" class="headerlink" title="Configure a Next-Hop Static IPv6 Route"></a>Configure a Next-Hop Static IPv6 Route</h4><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvi4279fjrj314m0toao2.jpg" alt="屏幕快照 2018-09-22 下午12.31.18"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvi445e5ooj314c0t67f4.jpg" alt="屏幕快照 2018-09-22 下午12.33.08"></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvi45usu4wj31540twwsf.jpg" alt="屏幕快照 2018-09-22 下午12.34.27"></p><h4 id="Configure-a-Default-Static-IPv6-Route"><a href="#Configure-a-Default-Static-IPv6-Route" class="headerlink" title="Configure a Default Static IPv6 Route"></a>Configure a Default Static IPv6 Route</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvi4a9atj9j31460to16b.jpg" alt="屏幕快照 2018-09-22 下午12.39.02"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvi4dl06f6j314m0tk7hq.jpg" alt="屏幕快照 2018-09-22 下午12.41.28"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvi9axl7vhj315i0tm4at.jpg" alt="屏幕快照 2018-09-22 下午3.32.22"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Rule-1-Omit-leading-0s&quot;&gt;&lt;a href=&quot;#Rule-1-Omit-leading-0s&quot; class=&quot;headerlink&quot; title=&quot;Rule 1- Omit leading 0s&quot;&gt;&lt;/a&gt;Rule 1- Omit leading 0s&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNbRwly1fvi1ht14d6j311a04swf2.jpg&quot; alt=&quot;屏幕快照 2018-09-22 上午11.02.28&quot;&gt;&lt;/p&gt;
&lt;p&gt;The first rule to help reduce the notation of IPv6 addresses is to omit any leading 0s (zeros) in any 16-bit section or hextet. For example:
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jvm检测工具</title>
    <link href="http://adamzeng.site/2018/09/21/jvm%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <id>http://adamzeng.site/2018/09/21/jvm检测工具/</id>
    <published>2018-09-21T07:37:57.000Z</published>
    <updated>2018-09-21T23:48:23.163Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h4><p>下图为macox平台上的JConsole，内存区域相当于可视化的jstat命令，用于监视受收集器管理的虚拟机内存（Java堆和永久代）的变化趋势。我们通过运行代码下图代码来体验一下它的监视功能。<a id="more"></a></p><p>运行时的设置的虚拟机参数为：-Xms100m -Xmx100m -XX:+UseSerialGC，这段代码的作用是以64KB/50毫秒的速度往Java堆中填充数据，一拱填充1000次，使用JConsole的“内存”页签进行监视，观察曲线和柱状指示图的变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOOMObject</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> *<span class="number">1024</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillHeap</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++) &#123;</div><div class="line"><span class="comment">// wait a while, make curve more apparent</span></div><div class="line">Thread.sleep(<span class="number">50</span>);</div><div class="line">list.add(<span class="keyword">new</span> OOMObject());</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">System.gc();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">fillHeap(<span class="number">2000</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvh7c0rv9cj31cm102n33.jpg" alt="屏幕快照 2018-09-21 下午5.38.26"></p><p>程序运行后，在内存页签中可以看到内存池Eden区的运行趋势呈现折线状，如上图所示。而监视范围扩大至整个堆后，会发现曲线是一条向上增长得平滑曲线。并且从柱状图可以看出，在1000次循环执行结束，运行了System.gc()后，虽然整个新生代Eden和Survivor区都基本被清空了，但是代表老年代的柱状图仍然保持峰值状态，说明被填充进堆中的数据在System.gc()方法执行之后仍然存货。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvh8i7rdtej30jq0dodgf.jpg" alt="2843224-384b0ec9f7da088d"></p><p>####JVM内存包括区域</p><ol><li>Heap（堆区）</li></ol><ul><li>New Generation（新生代） <ul><li>Eden</li><li>Survivor From</li><li>Survivor To</li></ul></li><li>Old Generation（老年代）</li></ul><ol><li>方法区</li></ol><ul><li>Permanent Generation（持久代）</li></ul><ol><li>Stack（栈区）</li><li>Metaspace（元空间）</li><li>Direct ByteBuffer（直接内存）</li></ol><p>下面我们就通过一些JVM启动参数来配置以上内存空间</p><h2 id="Heap（堆）内存大小设置"><a href="#Heap（堆）内存大小设置" class="headerlink" title="Heap（堆）内存大小设置"></a>Heap（堆）内存大小设置</h2><p>-Xms512m</p><blockquote><p>设置JVM堆初始内存为512M</p></blockquote><p>-Xmx1g</p><blockquote><p>设置JVM堆最大可用内存为1G</p></blockquote><h2 id="New-Generation（新生代）内存大小设置"><a href="#New-Generation（新生代）内存大小设置" class="headerlink" title="New Generation（新生代）内存大小设置"></a>New Generation（新生代）内存大小设置</h2><p>-Xmn256m</p><blockquote><p>设置JVM的新生代内存大小（－Xmn 是将NewSize与MaxNewSize设为一致。256m）,同下面两个参数<br> -XX:NewSize=256m<br> -XX:MaxNewSize=256m</p></blockquote><p><strong>还可以通过新生代和老年代内存的比值来设置新生代大小</strong><br> -XX:NewRatio=3</p><blockquote><p>设置新生代（包括Eden和两个Survivor区）与老年代的比值（除去持久代）。设置为3，则新生代与老年代所占比值为1：3，新生代占整个堆栈的1/4</p></blockquote><h2 id="Survivor内存大小设置"><a href="#Survivor内存大小设置" class="headerlink" title="Survivor内存大小设置"></a>Survivor内存大小设置</h2><p>-XX:SurvivorRatio=8</p><blockquote><p>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个新生代的1/10</p></blockquote><h2 id="Eden内存大小设置"><a href="#Eden内存大小设置" class="headerlink" title="Eden内存大小设置"></a>Eden内存大小设置</h2><p>新生代减去2*Survivor的内存大小就是Eden的大小。</p><h2 id="Old-Generation（老年的）的内存大小设置"><a href="#Old-Generation（老年的）的内存大小设置" class="headerlink" title="Old Generation（老年的）的内存大小设置"></a>Old Generation（老年的）的内存大小设置</h2><p>堆内存减去新生代内存<br> 如上面设置的参数举例如下：<br> 老年代初始内存为：512M-256M=256M<br> 老年代最大内存为：1G-256M=768M</p><h2 id="Stack-栈-内存大小设置"><a href="#Stack-栈-内存大小设置" class="headerlink" title="Stack(栈)内存大小设置"></a>Stack(栈)内存大小设置</h2><p>-Xss1m<br> 每个线程都会产生一个栈。在相同物理内存下，减小这个值能生成更多的线程。如果这个值太小会影响方法调用的深度。</p><h2 id="Permanent-Generation（持久代）内存大小设置"><a href="#Permanent-Generation（持久代）内存大小设置" class="headerlink" title="Permanent Generation（持久代）内存大小设置"></a>Permanent Generation（持久代）内存大小设置</h2><p>方法区内存分配（JDK8以前的版本使用，JDK8以后没有持久代了，使用的MetaSpace）<br> -XX: PermSize=128m 设置持久代初始内存大小128M<br> -XX:MaxPermSize=512m 设置持久代最大内存大小512M</p><h2 id="Metaspace（元空间）内存大小设置"><a href="#Metaspace（元空间）内存大小设置" class="headerlink" title="Metaspace（元空间）内存大小设置"></a>Metaspace（元空间）内存大小设置</h2><p>元空间（Metaspace）(JDK8)<br> -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m（JDK8），JDK8的持久代几乎可用完机器的所有内存，同样设一个128M的初始值，512M的最大值保护一下。</p><blockquote><ol><li>默认情况下，类元数据分配受到可用的本机内存容量的限制（容量依然取决于你使用32位JVM还是64位操作系统的虚拟内存的可用性）。</li></ol></blockquote><ol><li>一个新的参数 (MaxMetaspaceSize)可以使用。允许你来限制用于类元数据的本地内存。如果没有特别指定，元空间将会根据应用程序在运行时的需求动态设置大小。</li></ol><h2 id="Direct-ByteBuffer（直接内存）内存大小设置"><a href="#Direct-ByteBuffer（直接内存）内存大小设置" class="headerlink" title="Direct ByteBuffer（直接内存）内存大小设置"></a>Direct ByteBuffer（直接内存）内存大小设置</h2><p>-XX:MaxDirectMemorySize</p><blockquote><p>此参数的含义是当Direct ByteBuffer分配的堆外内存到达指定大小后，即触发Full GC。注意该值是有上限的，默认是64M，最大为sun.misc.VM.maxDirectMemory()，在程序中中可以获得-XX:MaxDirectMemorySize的设置的值。<br> 使用NIO可以api可以使用直接内存。</p></blockquote><h2 id="设置新生代代对象进入老年代的年龄"><a href="#设置新生代代对象进入老年代的年龄" class="headerlink" title="设置新生代代对象进入老年代的年龄"></a>设置新生代代对象进入老年代的年龄</h2><p>-XX:MaxTenuringThreshold=15</p><blockquote><p>设置垃圾最大年龄。如果设置为0的话，则新生代对象不经过Survivor区，直接进入老年代。对于老年代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则新生代对象会在Survivor区进行多次复制，这样可以增加对象再新生代的存活时间，增加在新生代即被回收的概论。</p></blockquote><p>他最大值为15岁，因为对象头中用了4位进行存储垃圾年龄 【1111（二进制）=15（十进制）】。</p><h2 id="不常用的参数："><a href="#不常用的参数：" class="headerlink" title="不常用的参数："></a>不常用的参数：</h2><p>-XX:MaxHeapFreeRatio=70</p><blockquote><p>GC后java堆中空闲量占的最大比例，大于该值，则堆内存会减少</p></blockquote><p>-XX:MinHeapFreeRatio=40</p><blockquote><p>GC后java堆中空闲量占的最小比例，小于该值，则堆内存会增加</p></blockquote><p>-XX:PretenureSizeThreshold=1024</p><blockquote><p>（单位字节）对象大小大于1024字节的直接在老年代分配对象</p></blockquote><p>-XX:TLABWasteTargetPercent =1</p><blockquote><p>TLAB占eden区的百分比    默认1%</p></blockquote><h4 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h4><p>如果上面的“内存”页签相当于可视化的jstat命令的话，“线程”页签的功能相当于可视化jstack命令，遇到线程停顿时可以使用这个页签进行监控分析。前面讲解jstack命令，遇到线程停顿时可以使用这个页签进行监控分析。前面讲解jstack命令的时候提到线程长时间停顿的主要原因主要有：等待外部资源（数据库连接、网络资源、设备资源等）、死循环、锁等待（活锁和死锁）。通过下面的代码分别演示一下这几种情况。</p><p>使用main方法中注释内容可以检测死循环，活锁，现在检测的是死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadWait</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 线程死循环演示</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBusyThread</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) ;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"testBusyThread"</span>);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 线程锁等待演示</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createLockThread</span><span class="params">(<span class="keyword">final</span> Object lock)</span> </span>&#123;</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        lock.wait();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">                        ex.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="string">"testLockThread"</span>);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynAddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a, b;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SynAddRunnable</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.a = a;</div><div class="line">            <span class="keyword">this</span>.b = b;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (Integer.valueOf(a)) &#123;</div><div class="line">                <span class="keyword">synchronized</span> (Integer.valueOf(b)) &#123;</div><div class="line">                    System.out.println(a + b);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">/*BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</span></div><div class="line">        br.readLine();</div><div class="line">        createBusyThread();</div><div class="line">        br.readLine();</div><div class="line">        Object obj = new Object();</div><div class="line">        createLockThread(obj);*/</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynAddRunnable(<span class="number">1</span>, <span class="number">2</span>)).start();</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynAddRunnable(<span class="number">2</span>, <span class="number">1</span>)).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvhzahru62j31ck0zagpk.jpg" alt="屏幕快照 2018-09-22 上午9.46.08"></p><p>上图即是用Jconsole进行分析之后的结果，发现在Thread-3中导致死锁的是Thread-2。同样的在Thread-2中导致死锁的是Thread-3。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JConsole&quot;&gt;&lt;a href=&quot;#JConsole&quot; class=&quot;headerlink&quot; title=&quot;JConsole&quot;&gt;&lt;/a&gt;JConsole&lt;/h4&gt;&lt;p&gt;下图为macox平台上的JConsole，内存区域相当于可视化的jstat命令，用于监视受收集器管理的虚拟机内存（Java堆和永久代）的变化趋势。我们通过运行代码下图代码来体验一下它的监视功能。
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>minor GC</title>
    <link href="http://adamzeng.site/2018/09/20/minor-GC/"/>
    <id>http://adamzeng.site/2018/09/20/minor-GC/</id>
    <published>2018-09-20T01:08:55.000Z</published>
    <updated>2018-09-20T01:09:53.049Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <link href="http://adamzeng.site/2018/09/17/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://adamzeng.site/2018/09/17/垃圾收集器与内存分配策略/</id>
    <published>2018-09-17T09:33:12.000Z</published>
    <updated>2018-09-18T01:46:16.082Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>static-route-and-dynamic-route</title>
    <link href="http://adamzeng.site/2018/09/16/static-route-and-dynamic-route/"/>
    <id>http://adamzeng.site/2018/09/16/static-route-and-dynamic-route/</id>
    <published>2018-09-16T07:07:08.000Z</published>
    <updated>2018-09-22T00:21:20.264Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Why-use-static-routing"><a href="#Why-use-static-routing" class="headerlink" title="Why use static routing?"></a>Why use static routing?</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvbejbpus2j31040dgn0a.jpg" alt="屏幕快照 2018-09-16 下午5.14.52"></p><p>Static routing provides some advantages over dynamic routing, including:<a id="more"></a></p><ul><li><p>Static routes are not advertised over the network, resulting in better security.</p></li><li><p>Static routes use less bandwidth than dynamic routing protocols, no CPU cycles are used to calculate and communicate routes.</p></li><li><p>The path a static route uses to send data is known.</p></li></ul><p>Static routing has the following disadvantages:</p><ul><li><p>Initial configuration and maintenance is time-consuming.</p></li><li><p>Configuration is error-prone, especially in large networks.</p></li><li><p>Administrator intervention is required to maintain changing route information.</p></li><li><p>Does not scale well with growing networks; maintenance becomes cumbersome.</p></li><li><p>Requires complete knowledge of the whole network for proper implementation.</p></li></ul><h4 id="ip-route-Command"><a href="#ip-route-Command" class="headerlink" title="ip route Command"></a>ip route Command</h4><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvbikax1hrj311a0e4gpy.jpg" alt="屏幕快照 2018-09-16 下午7.34.05"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvbjkayh7tj312u0jen6r.jpg" alt="屏幕快照 2018-09-16 下午8.08.44"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvbjonpf4cj313k0segxh.jpg" alt="屏幕快照 2018-09-16 下午8.12.47"></p><h4 id="ipv6-route-command"><a href="#ipv6-route-command" class="headerlink" title="ipv6 route command"></a>ipv6 route command</h4><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvbk8qkpndj314w0o0wsy.jpg" alt="屏幕快照 2018-09-16 下午8.32.09"></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvbkh3xgfcj31540u015u.jpg" alt="屏幕快照 2018-09-16 下午8.40.03"></p><p>R1 is configured with a default static route pointing to R2. Because no administrative distance is configured, the default value (1) is used for this static route. R1 is also configured with a floating static default pointing to R3 with an administrative distance of 5. This value is greater than the default value of 1 and therefore; this route floats and is not present in the routing table, unless the preferred route fails.</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Why-use-static-routing&quot;&gt;&lt;a href=&quot;#Why-use-static-routing&quot; class=&quot;headerlink&quot; title=&quot;Why use static routing?&quot;&gt;&lt;/a&gt;Why use static routing?&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwly1fvbejbpus2j31040dgn0a.jpg&quot; alt=&quot;屏幕快照 2018-09-16 下午5.14.52&quot;&gt;&lt;/p&gt;
&lt;p&gt;Static routing provides some advantages over dynamic routing, including:
    
    </summary>
    
      <category term="network" scheme="http://adamzeng.site/categories/network/"/>
    
    
      <category term="network" scheme="http://adamzeng.site/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <link href="http://adamzeng.site/2018/09/16/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://adamzeng.site/2018/09/16/Java内存区域与内存溢出异常/</id>
    <published>2018-09-16T01:20:29.000Z</published>
    <updated>2018-09-16T12:11:00.462Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机在执行Java程序的过程中，会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁、在第七版的Java SE中的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示<a id="more"></a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fvb4kp1xmwj30lw0gmtgm.jpg" alt="屏幕快照 2018-09-16 上午11.30.03"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效地方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为”线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈所描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的”堆“笔者在后面会专门讲述，而所指的”栈“就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean，byte，char，short，int，float，long，double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常：如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)的服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么”绝对“了。</p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做”GC堆“（Garbage Collected Heap）。从内存从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivior空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将是第3章的主题。</p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，即可以实现成固定大小的，也可以是可扩展，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区称为”永久代“（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。</p><p><strong>原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有-XX：MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如String.intern())会因这个原因导致不同虚拟机下有不同的表现。因此，对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了，在目前已经发布的JDK1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。</strong></p><p><em>Java 虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样”永久“存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收”成绩“比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。在Sun’公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</em></p><p><em>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</em></p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p><p>在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，在本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机在执行Java程序的过程中，会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁、在第七版的Java SE中的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM系列一走进JVM</title>
    <link href="http://adamzeng.site/2018/09/15/JVM%E7%B3%BB%E5%88%97%E4%B8%80%E8%B5%B0%E8%BF%9BJVM/"/>
    <id>http://adamzeng.site/2018/09/15/JVM系列一走进JVM/</id>
    <published>2018-09-15T10:17:34.000Z</published>
    <updated>2018-09-21T23:49:57.182Z</updated>
    
    <content type="html"><![CDATA[<p>现代高性能的虚拟机雏形是Exact VM,因它使用准备式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management)而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。譬如内存中有一个32位的整数123456，它到底是一个reference类型指向123456的内存地址还是一个数值为123456的整数，虚拟机将有能力分辨出来，这样才能在GC（垃圾收集）的时候准确判断堆上的数据是否还可能被使用。由于使用了准确式内存管理，Exact VM可以抛弃以前Classic VM基于handler的对象查找方式（原因是进行GC后对象将可能会被移动位置，如果将地址为123456的对象移动到654321，在没有明确信息表明内存中哪些数据是reference的前提下，虚拟机是不敢把内存中所有为123456的值改为654321的，所以要使用句柄来保持reference值的稳定），这样每次定位对象都少了一次间接查找的开销，提升执行性能。<a id="more"></a></p><p>虽然Exact VM的技术相对Classic VM来说先进了很多，但是在商业应用上只存在了很短暂的时间就被更为优秀的HotSpot VM所取代，甚至还没有来得及发布Windows和Linux平台下的商用版本。</p><h4 id="Sun-HotSpot-VM"><a href="#Sun-HotSpot-VM" class="headerlink" title="Sun HotSpot VM"></a>Sun HotSpot VM</h4><p>HotSpot VM既继承了Sun之前两款商用虚拟机的有点（如前面提到的准确式内存管理），也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术（其实两个VM基本上是同时期的独立产品，HotSpot还稍早一些，HotSpot一开始就是准确式GC，而Exact VM中也有与HotSpot几乎一样的热点探测。）</p><p><strong>HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。如果一个方法被频繁调用，或者方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无需等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多代码优化技术，输出质量更高的本地代码。</strong></p><h4 id="64位虚拟机"><a href="#64位虚拟机" class="headerlink" title="64位虚拟机"></a>64位虚拟机</h4><p>在几年之前，主流的CPU就开始支持64位架构了。</p><p>但是在Java EE方面，企业级应用经常需要使用超过4GB的内存，对于64位虚拟机的需求是非常迫切的，但由于上述原因，许多企业应用都仍然选择使用虚拟集群等方式继续在32位虚拟机中进行部署。Sun也注意到了这些问题，并做出了一些改善，提供了普通对象指针压缩功能（-XX:+UseCompressedOops，这个参数不建议显式设置，建议维持默认由虚拟机的Ergonomics机制自动开启），在执行代码时，动态植入压缩指令以节省内存消耗，但是开启压缩指针会增加执行代码数量，因为所有在Java堆里的、指向Java堆内对象的指针都会被压缩，这些指针的访问就需要更多的代码才可以实现，而且并不只是读写字段才受影响，在实例方法调用、子类型检查等操作中也受影响，因为对象实例指向对象类型的引用也被压缩了。随着硬件的进一步发展，计算机终究会完全过渡到64位的时代，这是一件毫无疑问的事情，主流的虚拟机应用也终究会从32位发展至64位，而虚拟机对64位的支持也将会进一步完善。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代高性能的虚拟机雏形是Exact VM,因它使用准备式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management)而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。譬如内存中有一个32位的整数123456，它到底是一个reference类型指向123456的内存地址还是一个数值为123456的整数，虚拟机将有能力分辨出来，这样才能在GC（垃圾收集）的时候准确判断堆上的数据是否还可能被使用。由于使用了准确式内存管理，Exact VM可以抛弃以前Classic VM基于handler的对象查找方式（原因是进行GC后对象将可能会被移动位置，如果将地址为123456的对象移动到654321，在没有明确信息表明内存中哪些数据是reference的前提下，虚拟机是不敢把内存中所有为123456的值改为654321的，所以要使用句柄来保持reference值的稳定），这样每次定位对象都少了一次间接查找的开销，提升执行性能。
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java加载配置文件的三种方式</title>
    <link href="http://adamzeng.site/2018/09/14/java%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://adamzeng.site/2018/09/14/java加载配置文件的三种方式/</id>
    <published>2018-09-14T00:21:43.000Z</published>
    <updated>2018-09-14T00:42:50.423Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://images.cnitblog.com/i/562629/201406/150730416869009.jpg" alt="avatar"></p><p>比如我们要加载db.properties文件<a id="more"></a></p><p>通常情况下会有以下三种方式：</p><ul><li><p>使用文件io流</p></li><li><p>使用相对路径</p></li><li><p>如果我们要获取src（类包）下的db.properties</p></li></ul><p>  使用文件io流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// 文件真实路径</span></div><div class="line">    String fileName = <span class="string">"E:/Workspace/SSHDemo/Source/db.properties"</span>;</div><div class="line">    Properties p = <span class="keyword">new</span> Properties();</div><div class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fileName));</div><div class="line">    p.load(is);</div><div class="line">    System.out.println(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用相对路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 相对路径</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Properties p = <span class="keyword">new</span> Properties();</div><div class="line">    <span class="comment">// InputStream is = ClassLoader.getSystemResourceAsStream("db.properties");</span></div><div class="line">    </div><div class="line">    InputStream is = Thread.currentTread().getContextClassLoader().getSystemResourceAsStream(<span class="string">"db.properties"</span>);</div><div class="line">    p.load(is);</div><div class="line">    System.out.println(p);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    Properties p = <span class="keyword">new</span> Properties();</div><div class="line">    </div><div class="line">    InputStream is = SourceLoader.class.getClassLoader().getSystemResourceAsStream(<span class="string">"db.properties"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果我们要获取src（类包）下的db.properties又该怎么处理呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//相对于类路径  properties文件盒java放在一起</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Properties p=<span class="keyword">new</span> Properties();</div><div class="line">        <span class="comment">//InputStream is=ClassLoader.getSystemResourceAsStream("db.properties");</span></div><div class="line">        InputStream is=SourceLoader.class.getResourceAsStream(<span class="string">"db.properties"</span>);</div><div class="line">        p.load(is);</div><div class="line">        System.out.println(p);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>三种方法都打印出db.properties文件中的信息</p><p><img src="http://images.cnitblog.com/i/562629/201406/150735374523200.jpg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://images.cnitblog.com/i/562629/201406/150730416869009.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;p&gt;比如我们要加载db.properties文件
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>primary-function-and-features-of-a-router</title>
    <link href="http://adamzeng.site/2018/09/13/primary-function-and-features-of-a-router/"/>
    <id>http://adamzeng.site/2018/09/13/primary-function-and-features-of-a-router/</id>
    <published>2018-09-13T10:34:35.000Z</published>
    <updated>2018-09-16T06:59:22.117Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Router到底有什么用？"><a href="#Router到底有什么用？" class="headerlink" title="Router到底有什么用？"></a>Router到底有什么用？</h4><p>Ethernet switches function at the data link layer, Layer 2, and are used to forward Ethernet frames between devices within the same network.<a id="more"></a></p><p>通常switch工作在数据链路层，第二层，并且通常是用于传输以太帧在同一个网络的不同设备之间。</p><p>However, when the source IP and destination IP addresses are on different networks, the Ethernet frame must be sent to a router.</p><p>然而，当起始IP与终点IP在不同的network当中的时候，以太帧必须要被送到router中去。</p><p>A router connects one network to another network. The router is responsible for the delivery of packets across different networks. The destination of the IP packet might be a web server in another country or an email server on the local area network.</p><p>一个路由将一个网络与另一个网络连接起来。路由负责包在不同的network中传递，IP packet的终点可能是一个在另一个国家的网络服务器或者是在本地区的邮件服务器。</p><p>The router uses its routing table to determine the best path to use to forward a packet. It is the responsibility of the routers to deliver those packets in a timely manner. The effectiveness of internetwork communications depends, to a large degree, on the ability of routers to forward packets in the most efficient way possible.</p><p>Router使用它的路由表来决定使用最好的路径来传输一个packet。这是路由的责任及时地来发送这些packet。有效的互联网沟通很大程度上取决于router以最有效的方式来传递packets的能力。</p><p>When a host sends a packet to a device on a different IP network, the packet is forwarded to the default gateway because a host device cannot communicate directly with devices outside of the local network. The default gateway is the destination that routes traffic from the local network to devices on remote networks. It is often used to connect a local network to the Internet.</p><p>当一个host发送一个packet到一个不同的IP network中的设备，packet被发送到default gateway因为一个host设备不能直接与外面的本地网络之间进行沟通。default gateway是目的地从本地network路由到remote的networks。通常用来连接本地网络到Internet。</p><h4 id="Routers-are-computers（router本身也是电脑）"><a href="#Routers-are-computers（router本身也是电脑）" class="headerlink" title="Routers are computers（router本身也是电脑）"></a>Routers are computers（router本身也是电脑）</h4><ul><li>central processing unit(CPU)</li><li>operating system(OS)</li><li>Memory and storage(RAM,ROM,NVRAM,Flash,hard drive)</li></ul><h5 id="阐述volatile与non-volatile的区别"><a href="#阐述volatile与non-volatile的区别" class="headerlink" title="阐述volatile与non-volatile的区别"></a>阐述volatile与non-volatile的区别</h5><p>Router memory is classified as volatile or non-volatile. Volatile memory loses its content when the power is turned off, while non-volatile memory does not lose its content when the power is turned off.</p><p><img src="/Users/adamzeng/Desktop/屏幕快照 2018-09-13 下午9.12.10.png" alt="屏幕快照 2018-09-13 下午9.12.10"></p><p><img src="/Users/adamzeng/Desktop/屏幕快照 2018-09-13 下午9.11.31.png" alt="屏幕快照 2018-09-13 下午9.11.31"></p><p><strong>NVRAM</strong>提供startup configuration file的存储</p><p><strong>Flash</strong>提供IOS与system-ralated file的存储</p><h4 id="The-Router-Connection"><a href="#The-Router-Connection" class="headerlink" title="The Router Connection"></a>The Router Connection</h4><p>A router connects multiple networks, which means that it has multiple interfaces that each belong to a different IP network. When a router receives an IP packet on one interface, it determines which interface to use to forward the packet to the destination.</p><p>当一个router收到IP packet在某一个interface的时候，它会决定使用哪一个interface来传输packet到目的地。</p><h4 id="Routers-选择最好的路径"><a href="#Routers-选择最好的路径" class="headerlink" title="Routers 选择最好的路径"></a>Routers 选择最好的路径</h4><p>When the router receives a packet, it examines the destination address of the packet and uses the routing table to search for the best path to that network.</p><p>The routing table also includes the interface to be used to forward packets for each known network. </p><p>routing table同样也包含interface被用于对于每一个已知网络传输packets。</p><p>When a match is found, the router encapsulates the packet into the data link frame of the outgoing or exit interface, and the packet is forwarded toward its destination.</p><p>当匹配上之后，router把packet封装成出口interface的数据链路帧，并且packet被发送往它的目的地。</p><p>It is possible for a router to receive a packet that is encapsulated in one type of data link frame, and to forward the packet out of an interface that uses a different type of data link frame. </p><p>很有可能router收到某一种packet以一种数据链路帧的形式封装并以另一种数据链路帧的形式将包发送出去。</p><p>The data link encapsulation depends on the type of interface on the router and the type of medium to which it connects. </p><p>不同的数据链路封装取决于在router上的interface的类型与与之相连的介质类型。</p><p>router R1 receives the packet encapsulated in an Ethernet frame. After de-encapsulating the packet, R1 uses the destination IP address of the packet to search its routing table for a matching network address. After a destination network address is found in the routing table, R1 encapsulates the packet inside a PPP frame and forwards the packet to R2. A similar process is performed by R2.</p><p>R1收到以Ethernet frame形式封装的packet。R1使用packet的目的地IP address来搜寻它自己的routing table 来寻找一个相匹配的network address。在找到之后，R1将packet封装入一个PPP帧中并且将包传递出去给R2。</p><p><img src="/Users/adamzeng/Desktop/屏幕快照 2018-09-13 下午11.01.39.png" alt="屏幕快照 2018-09-13 下午11.01.39"></p><ul><li><strong>Default gateway</strong> - Identifies the IP address of the router to send a packet to when the destination is not on the same local network subnet.</li></ul><p>The default gateway is usually the address of the interface on the router connected to the local network. The router maintains routing table entries of all connected networks as well as entries of remote networks, and determines the best path to reach those destinations.</p><p>####Configure an IPv4 Loopback Interface</p><p>Another common configuration of Cisco IOS routers is enabling a loopback interface.</p><p>The loopback interface is a logical interface internal to the router.</p><p>这意味着loopback interface仅存在于逻辑上的router内部。</p><p> It is not assigned to a physical port and can therefore never be connected to any other device. It is considered a software interface that is automatically placed in an “up” state, as long as the router is functioning.</p><p>这个通常不会分配给一个物理端口并且因此绝不会与任何其他装置相连。它被认为是一个软件接口被自动设置为up状态，只要router在工作状态。</p><p>The loopback interface is useful in testing and managing a Cisco IOS device because it ensures that at least one interface will always be available. For example, it can be used for testing purposes, such as testing internal routing processes, by emulating networks behind the router.</p><p>loopback interface对于测试和管理一个Cisco IOS 设备很有用因为它确保至少一个interface将会一直available。举一个例子，它能够被使用于测试目的。</p><p><img src="https://ws2.sinaimg.cn/large/0069RVTdly1fv9ynslg52j311k0dgabt.jpg" alt="屏幕快照 2018-09-15 上午10.44.37"></p><p>####Verify Interface Settings</p><ul><li><strong>show ip interface brief</strong> - Displays a summary for all interfaces including the IPv4 address of the interface and current operational status.</li><li><strong>show ip route</strong> - Displays the contents of the IPv4 routing table stored in RAM. In Cisco IOS 15, active interfaces should appear in the routing table with two related entries identified by the code ‘<strong>C</strong>’ (Connected) or ‘<strong>L</strong>’ (Local). In previous IOS versions, only a single entry with the code ‘<strong>C</strong>’ will appear.</li><li><strong>show running-config interface</strong> <em>interface-id</em> - Displays the commands configured on the specified interface.</li></ul><p>####Verify IPv6 Interface Settings</p><p>The commands to verify the IPv6 interface configuration are similar to the commands used for IPv4.</p><p>通常情况下是相同的</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdly1fv9ymq3rffj311o0gimzi.jpg" alt="屏幕快照 2018-09-15 上午10.54.24"></p><p><img src="https://ws1.sinaimg.cn/large/0069RVTdly1fv9ylyvmz9j311q0gmjtr.jpg" alt="屏幕快照 2018-09-15 上午11.02.25">The output displays two configured IPv6 addresses per interface. One address is the IPv6 global unicast address that was manually entered. The other address, which begins with FE80, is the link-local unicast address for the interface. A link-local address is automatically added to an interface whenever a global unicast address is assigned. An IPv6 network interface is required to have a link-local address, but not necessarily a global unicast address.</p><p>通常输出会显示两个设置好的IPV6 的地址在每个interface上。一个地址是IPv6 global unicast address是人为输入的。另一个地址开头是FE80，是给interface的link-local unicast address。link-local address会被自动添加给一个interface无论何时一个global unicast address被分配。一个IPv6网络interface被要求有一个link-local address，但不一定需要一个global unicast address。</p><p>The <strong>show ipv6 route</strong> command shown in Figure 3 can be used to verify that IPv6 networks and specific IPv6 interface addresses have been installed in the IPv6 routing table. The <strong>show ipv6 route</strong> command will only display IPv6 networks, not IPv4 networks.</p><p><img src="https://ws1.sinaimg.cn/large/0069RVTdly1fv9ymf1r0oj31200gwdj8.jpg" alt="屏幕快照 2018-09-15 上午11.09.21"></p><p>这个命令能够被用于验证IPv6网络并且确认IPv6的interface address已经被安装到IPv6 routing table中去了。</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdly1fv9yorxoroj316e0ui7ki.jpg" alt="屏幕快照 2018-09-15 上午11.20.31"></p><p>A primary function of a router is to forward packets toward their destination. This is accomplished by using a switching function, which is the process used by a router to accept a packet on one interface and forward it out of another interface. A key responsibility of the switching function is to encapsulate packets in the appropriate data link frame type for the outgoing data link.</p><p>一个主要的router的功能是发送packet到目的地。这个通过使用一个switching功能来完成，这是一个过程被一个router使用来接收一个packet在一个interface并且发送它到另一个interface。一个关键的职责关于switching 职责是封装packet进入合适的数据链路帧类型对应出口data link。</p><p>As shown in the figure, devices have Layer 3 IPv4 addresses and Ethernet interfaces have Layer 2 data link addresses. For example, PC1 is configured with IPv4 address 192.168.1.10 and an example MAC address of 0A-10. As a packet travels from the source device to the final destination device, the Layer 3 IP addresses do not change. This is because the Layer 3 PDU does not change. However, the Layer 2 data link addresses change at every hop as the packet is de-encapsulated and re-encapsulated in a new Layer 2 frame by each router.</p><p>router负责将packet封装进入不同类型的数据链路帧，每一个router都是这样工作。</p><p>It is common for packets to require encapsulation into a different type of Layer 2 frame than the one which was received. For example, a router might receive an Ethernet encapsulated frame on a FastEthernet interface, and then process that frame to be forwarded out of a serial interface.</p><p>很常见通过讲一个layer2 frame类型是Ethernet 转换为一个适合serial interface的frame类型。</p><p>Notice in the figure that the ports between R2 and R3 do not have associated MAC addresses. This is because this is a serial link. MAC addresses are only required on multi-access networks, such as Ethernet. A serial link is a point-to-point connection and uses a different Layer 2 frame that does not require the use of a MAC address. In this example, when Ethernet frames are received on R2 from the Fa0/0 interface, destined for PC2, it is de-encapsulated and then re-encapsulated for the serial interface, such as a Point-to-Point Protocol (PPP) encapsulated frame. When R3 receives the PPP frame, it is de-encapsulated again and then re-encapsulated into an Ethernet frame with a destination MAC address of 0B-20, prior to being forwarded out the Fa0/0 interface.</p><p>对于Serial link而言，不需要MAC地址，只有到Ethernet连接的时候才会把destination MAC address封装进Frame中。</p><p>If the destination network address is the same network as PC1, then PC1 does not use the default gateway. Instead, PC1 refers to its ARP cache for the MAC address of the device with that destination IPv4 address. If the MAC address is not in the cache, then PC1 generates an ARP request to acquire the address to complete the packet and send it to the destination. If the destination network address is on a different network, then PC1 forwards the packet to its default gateway.</p><p>如果目的地网络地址与PC1在相同的地址，PC1就不适用default gateway。而是PC1会参考它的ARP cache使用那个destination IPv4地址。如果MAC地址不在cache当中，PC1就会产生一个ARP请求来获得地址产生一个packet包并且将它发送到目的地，如果destination network是在不同的网络中，PC1发送packet到default gateway。</p><p>If an ARP entry does not exist in the ARP table for the default gateway, PC1 sends an ARP request. Router R1 sends back an ARP reply. PC1 can then forward the packet to the MAC address of the default gateway, the Fa0/0 interface of router R1.</p><p>如果ARP entry不在ARP table对于default gateway当中。PC1发送一个ARP 请求。Router R1发送回一个ARP reply。PC1能够发送packet到MAC address of default gateway。</p><p>####Administrative Distance</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdly1fva0mqydgdj311e0eeq4r.jpg" alt="屏幕快照 2018-09-15 下午12.28.12"></p><h4 id="static-route"><a href="#static-route" class="headerlink" title="static route"></a>static route</h4><p>A default static route is useful when a router has only one exit point to another router,such as when the router connects to a central router or service provider.</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvbe1fd7s0j314a0fqgp3.jpg" alt="屏幕快照 2018-09-16 下午4.57.00"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvbe1r68qmj311k0d8mzk.jpg" alt="屏幕快照 2018-09-16 下午4.57.00"></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvbe2sgyrtj311e0d6419.jpg" alt="屏幕快照 2018-09-16 下午4.59.01"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Router到底有什么用？&quot;&gt;&lt;a href=&quot;#Router到底有什么用？&quot; class=&quot;headerlink&quot; title=&quot;Router到底有什么用？&quot;&gt;&lt;/a&gt;Router到底有什么用？&lt;/h4&gt;&lt;p&gt;Ethernet switches function at the data link layer, Layer 2, and are used to forward Ethernet frames between devices within the same network.
    
    </summary>
    
      <category term="network" scheme="http://adamzeng.site/categories/network/"/>
    
    
      <category term="network" scheme="http://adamzeng.site/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>二叉查找树</title>
    <link href="http://adamzeng.site/2018/08/27/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>http://adamzeng.site/2018/08/27/二叉查找树/</id>
    <published>2018-08-27T12:32:46.000Z</published>
    <updated>2018-08-30T13:49:46.664Z</updated>
    
    <content type="html"><![CDATA[<p>树（tree）提供了一种层次组织结构，数据可以存储在树中的每个结点内。</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><ul><li>二叉查找树可以用链接结构实现。<a id="more"></a></li></ul><p>线性表、栈和队列都是由一系列元素构成的线性结构。二叉树（binary tree）是一种层次结构，它要么是空集，要么是由一个称为根（root）的元素和两颗不同的二叉树组成的，这两颗二叉树分别称为左子树（left subtree）和右子树（right subtree）。允许这两颗子树中的一颗或者两颗为空。二叉树示例如图所示。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%8811.20.28.png" alt="avatar"></p><p>一条路径的长度（length）是指在该条路径上的边的个数。一个结点的深度（depth）是指从根结点到该结点的路径长度。有时候，我们将一棵树中具有某个给定深度的所有结点的集合称为该树的层（level）。兄弟结点（sibling）是共享同一父结点的结点。一个结点的左（右）子树的根结点称为这个结点的左（右）子结点（left（right）child）。没有子结点的结点称为叶结点（leaf）。非空树的高度为从根结点到最远的叶结点的路径长度。只有一个结点的树高度为0。习惯上，将空树的高度定为-1。考虑上图a中的树，从结点60到45的路径的长度为2。结点60的深度为0，结点55的深度为1，而结点45的深度为2。这颗树的高度为2。结点45和57是兄弟结点。结点45、57、67和107位于同一层。</p><p>一种称为二叉树（binary search tree， BST）的特殊类型的二叉树非常有用。二叉查找树（没有重复元素）的特征是：对于树中的每一个结点，它的左子树中结点都小于该结点的值，而它的右子树中结点的值都大于该结点的值。</p><h4 id="表示二叉查找树"><a href="#表示二叉查找树" class="headerlink" title="表示二叉查找树"></a>表示二叉查找树</h4><p>可以使用一个链式结点的集合来表示二叉树。每个结点都包含一个数值和两个称为left和right的链接，分别指向左孩子和右孩子，</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-27%20%E4%B8%8B%E5%8D%8811.47.06.png" alt="avatar"></p><p>结点可以定义为一个类，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">protected</span> E element;</div><div class="line">    <span class="keyword">protected</span> TreeNode&lt;E&gt; left;</div><div class="line">    <span class="keyword">protected</span> TreeNode&lt;E&gt; right;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        element = e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>变量root指向树的根结点。如果树为空，那么root的值为null。下面的代码创建了如上图所示的树的前三个结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create the root node</span></div><div class="line">TreeNode&lt;Integer&gt; root = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="number">60</span>);</div><div class="line"></div><div class="line"><span class="comment">// Create the left child node</span></div><div class="line">root.left = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="number">55</span>);</div><div class="line"></div><div class="line"><span class="comment">// Create the right child node</span></div><div class="line">root.right = <span class="keyword">new</span> TreeNode&lt;&gt;(<span class="number">100</span>);</div></pre></td></tr></table></figure><h4 id="查找一个元素"><a href="#查找一个元素" class="headerlink" title="查找一个元素"></a>查找一个元素</h4><p>要在二叉查找树中查找一个元素，可从根结点开始向下扫描，直到找到一个匹配元素，或者达到一颗空子树为止。该算法在下面的程序中。让current指向根结点，重复下面的步骤直到current为null或者元素匹配current.element。</p><ul><li>如果element小于current.element，就将current.left赋给current。</li><li>如果element大于current.element，就将current.right赋给current。</li><li>如果element等于current.element，就返回true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(E element)</span> </span>&#123;</div><div class="line">    TreeNode&lt;E&gt; current =root; <span class="comment">// Start from the root</span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(element &lt;current.element) &#123;</div><div class="line">            current = current.left; <span class="comment">// Go left</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; current.element) &#123;</div><div class="line">            current = current.right; <span class="comment">// Go right</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Element matches current.element</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="在BST中插入一个元素"><a href="#在BST中插入一个元素" class="headerlink" title="在BST中插入一个元素"></a>在BST中插入一个元素</h4><p>为了在BST中插入一个元素，需要确定在树中插入元素的位置。关键思路是确定新结点的父结点所在的位置。下面程序清单给出该算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(tree is empty) &#123;</div><div class="line">        <span class="comment">// Create the node for e as the root</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Locate the parent node</span></div><div class="line">        parent = current = node;</div><div class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span>(e &lt; the value in current.element) &#123;</div><div class="line">                parent = current; <span class="comment">// Keep the parent</span></div><div class="line">                current = current.left; <span class="comment">// Go left</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e &gt; the value in current.element) &#123;</div><div class="line">                parent = current; <span class="comment">// Keep the parent</span></div><div class="line">                current = current.right; <span class="comment">// Go right</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// Duplicate node not inserted</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// Create a new node for e and attach it to parent</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// Element inserted</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果这棵树是空的，就使用新元素创建一个根结点；否则，寻找新元素结点的父结点的位置。为该元素创建一个新结点，然后将该结点链接到它的父结点上。如果新元素的值小于父元素的值，则将新元素的结点设置为父结点的左子结点；如果新元素的值大于父元素的值，则将新元素的结点设置为父结点的右子结点。</p><p>例如，要将数据101插入下图所示的树中，在算法中的while循环结束之后，parent指向存储107的结点，如图a所示。存储数据101的新结点将成为父结点的左子结点。要将数据59插入树中，在算法中的while循环结束之后，父结点指向数据57的结点，如图b所示。存储数据59的新结点成为父结点的右子结点。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-28%20%E4%B8%8A%E5%8D%8811.06.17.png" alt="avatar"></p><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><p>树的遍历（tree traversal）就是访问树中每个结点一次且只有一次的过程。遍历树的方法有很多种。中序（inorder）、前序（preorder）、后序（postorder）、深度优先（depth-first)和广度优先（breadth-first）等遍历方法。</p><p>中序遍历（inorder traversal）法，首先递归地访问当前结点的左子树，然后访问当前结点，最后递归地访问该结点的右子树。中序遍历法以递增顺序显示BST中的所有结点。</p><p>后序遍历（postorder traversal）法，首先递归地访问当前结点的左子树，然后递归地访问该结点的右子树，最后访问该结点本身。后序遍历的一个应用就是找出一个文件系统中目录的个数。如下图所示，每个目录都是一个内部结点，而每个文件都是叶结点。可以使用后序遍历法，在找出根目录的大小之前得到每个文件和子目录的大小。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-28%20%E4%B8%8A%E5%8D%8811.14.44.png" alt="avatar"></p><p>前序遍历（preorder traversal）法，首先访问当前结点，然后递归地访问该结点的左子树，最后递归地访问该结点的右子树。深度优先遍历法与前序遍历法相同。前序遍历的一个应用就是打印一个结构性文档。如下图所示，可以使用前序遍历法打印本书的目录。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-28%20%E4%B8%8A%E5%8D%8811.14.55.png" alt="avatar"></p><ul><li>可以采用前序插入元素的方法来重构一颗二叉查找树。重构的树为原始的二叉查找树保留了父结点和子结点的关系。</li></ul><p>广度优先遍历法逐层访问树中的结点。首先访问根结点，然后从左往右访问根结点的所有子结点，再从左往右访问根结点的所有孙子结点，以此类推。</p><p>例如，对于往上两个图中的树，它中序遍历为</p><p>45 55 57 59 60 67 100 101 107</p><p>它的后序遍历为</p><p>45 59 57 55 67 101 107 100 60</p><p>它的前序遍历为</p><p>60 55 45 57 59 100 67 107 101</p><p>它的广度优先遍历为</p><p>60 55 100 45 57 67 107 59 101</p><p>可以使用下面的树来帮助记忆中序、后序以及前序：</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-28%20%E4%B8%8B%E5%8D%8812.09.51.png" alt="avatar"></p><p>中序是1+2，后序是1 2+，前序是+1 2。</p><h4 id="BST类"><a href="#BST类" class="headerlink" title="BST类"></a>BST类</h4><p>我们遵循Java合集框架API的设计模式，使用一个名为Tree的接口来定义树的所有常用操作，并提供名为AbstractTree的抽象类，该抽象类部分地实现了Tree，如下图所示。继承AbstractTree定义一个具体的BST类。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-28%20%E4%B8%8B%E5%8D%8812.13.48.png" alt="avatar"></p><p>BST.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">AbstractTree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">protected</span> TreeNode&lt;E&gt; root;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Create a default binary search tree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Create a binary search tree from an array of objects</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">(E[] objects)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</div><div class="line">            insert(objects[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">/** Return true if the element is in the tree */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        TreeNode&lt;E&gt; current = root; <span class="comment">// Start from the root</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</div><div class="line">                current = current.left;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</div><div class="line">                current = current.right;</div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// element matches current.element</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// Element is found</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">/** Insert element e into the binary search tree.</span></div><div class="line">     * Return true if the element is inserted successfully */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">            root = createNewNode(e); <span class="comment">// Create a new root</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Locate the parent node</span></div><div class="line">            TreeNode&lt;E&gt; parent = <span class="keyword">null</span>;</div><div class="line">            TreeNode&lt;E&gt; current = root;</div><div class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</div><div class="line">                    parent = current;</div><div class="line">                    current = current.left;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</div><div class="line">                    parent = current;</div><div class="line">                    current = current.right;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// Duplicated node not inserted</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Create the new node and attach it to the parent node</span></div><div class="line">            <span class="keyword">if</span> (e.compareTo(parent.element) &gt; <span class="number">0</span>) &#123;</div><div class="line">                parent.right = createNewNode(e);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(parent.element) &lt; <span class="number">0</span>) &#123;</div><div class="line">                parent.left = createNewNode(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        size++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// Element insert successfully</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> TreeNode&lt;E&gt; <span class="title">createNewNode</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">/** Inorder traversal from the root */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</div><div class="line">        inorder(root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Inorder traversal from a subtree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        inorder(root.left);</div><div class="line">        System.out.print(root.element + <span class="string">" "</span>);</div><div class="line">        inorder(root.right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">/** Postorder traversal from the root */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span> </span>&#123;</div><div class="line">        postorder(root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Postorder traversal from a subtree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        System.out.print(root.element + <span class="string">" "</span>);</div><div class="line">        postorder(root.left);</div><div class="line">        postorder(root.right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Preorder traversal from a subtree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span> </span>&#123;</div><div class="line">        preorder(root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Preorder traversal from a subtree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">        preorder(root.left);</div><div class="line">        preorder(root.right);</div><div class="line">        System.out.print(root.element + <span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This inner class is static, because it does not access</div><div class="line">     * any instance members defined in its outer class</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</div><div class="line">        <span class="keyword">protected</span> E element;</div><div class="line">        <span class="keyword">protected</span> TreeNode&lt;E&gt; left;</div><div class="line">        <span class="keyword">protected</span> TreeNode&lt;E&gt; right;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">            element = e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">/** Get the number of nodes in the tree */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return the root of the tree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;E&gt; <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns a path from the root leading to the specified element</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> java.util.ArrayList&lt;TreeNode&lt;E&gt;&gt; path(E e) &#123;</div><div class="line">        java.util.ArrayList&lt;TreeNode&lt;E&gt;&gt; list = <span class="keyword">new</span> java.util.ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        TreeNode&lt;E&gt; current = root; <span class="comment">// Start from the root</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</div><div class="line">            list.add(current); <span class="comment">// Add the node to the list</span></div><div class="line">            <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</div><div class="line">                current = current.left;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</div><div class="line">                current = current.right;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> list; <span class="comment">// Return an array list of nodes</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Delete an element from the binary search tree.</div><div class="line">     * Return true if the element is deleted successfully</div><div class="line">     * Return false if the element is not in the tree.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        <span class="comment">// Locate the node to be deleted and also locate its parent node</span></div><div class="line">        TreeNode&lt;E&gt; parent = <span class="keyword">null</span>;</div><div class="line">        TreeNode&lt;E&gt; current = root;</div><div class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (e.compareTo(current.element) &lt; <span class="number">0</span>) &#123;</div><div class="line">                parent = current;</div><div class="line">                current = current.left;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(current.element) &gt; <span class="number">0</span>) &#123;</div><div class="line">                parent = current;</div><div class="line">                current = current.right;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>; <span class="comment">// Element is in the tree pointed at by current</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Case 1: current has no left child</span></div><div class="line">        <span class="keyword">if</span> (current.left == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// Connect the parent with the right child of the current node</span></div><div class="line">            <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</div><div class="line">                root = current.right;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.compareTo(parent.element) &lt; <span class="number">0</span>) &#123;</div><div class="line">                    parent.left = current.right;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    parent.right = current.right;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Case 2: The current node has a left child.</span></div><div class="line">            <span class="comment">// Locate the rightmost node in the left subtree of</span></div><div class="line">            <span class="comment">// the current node and also its parent.</span></div><div class="line">            TreeNode&lt;E&gt; parentOfRightMost = current;</div><div class="line">            TreeNode&lt;E&gt; rightMost = current.left;</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (rightMost.right != <span class="keyword">null</span>) &#123;</div><div class="line">                parentOfRightMost = rightMost;</div><div class="line">                rightMost = rightMost.right; <span class="comment">// Keep going to the right</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Replace the element in current by the element in rightMost</span></div><div class="line">            current.element = rightMost.element;</div><div class="line"></div><div class="line">            <span class="comment">// Eliminate rightmost node</span></div><div class="line">            <span class="keyword">if</span> (parentOfRightMost.right == rightMost) &#123;</div><div class="line">                parentOfRightMost.right = rightMost.left;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Special case: parentOfRightMost == current</span></div><div class="line">                parentOfRightMost.left = rightMost.left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        size--;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// Element deleted successfully</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">/** Obtain an iterator. Use inorder. */</span></div><div class="line">    <span class="keyword">public</span> java.util.<span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InorderIterator();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Inner class InorderIterator</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InorderIterator</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">        <span class="comment">// Store the elements in a list</span></div><div class="line">        <span class="keyword">private</span> java.util.ArrayList&lt;E&gt; list =</div><div class="line">                <span class="keyword">new</span> java.util.ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">0</span>; <span class="comment">// Point to the current element in list</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InorderIterator</span><span class="params">()</span> </span>&#123;</div><div class="line">            inorder(); <span class="comment">// Traverse binary tree and store elements in list</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Inorder traversal from the root</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</div><div class="line">            inorder(root);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Inorder traversal from a subtree</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode&lt;E&gt; root)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">            inorder(root.left);</div><div class="line">            list.add(root.element);</div><div class="line">            inorder(root.right);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="comment">/** More elements for traversing? */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (current &lt; list.size()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="comment">/** Get the current element and move to the next */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> list.get(current++);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="comment">/** Remove the current element */</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException</div><div class="line">                    (<span class="string">"Removing an element from the iterator is not supported"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Remove all elements from the tree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        root = <span class="keyword">null</span>;</div><div class="line">        size = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Tree.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tree</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return true if the element is in the tree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Insert element e into the binary search tree.</div><div class="line">     * Return true if the element is inserted successfully.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Delete the specified element from the tree.</div><div class="line">     * Return true if the element is deleted successfully</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Inorder traversal from the root</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Postorder traversal from the root</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Preorder traversal from the root</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the number of nodes in the tree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return true if the tree is empty</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>AbstractTree.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tree</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return true if the element is in the tree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Insert element e into the binary search tree.</div><div class="line">     * Return true if the element is inserted successfully.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Delete the specified element from the tree.</div><div class="line">     * Return true if the element is deleted successfully</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Inorder traversal from the root</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Postorder traversal from the root</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorder</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Preorder traversal from the root</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the number of nodes in the tree</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Return true if the tree is empty</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树（tree）提供了一种层次组织结构，数据可以存储在树中的每个结点内。&lt;/p&gt;
&lt;h4 id=&quot;二叉查找树&quot;&gt;&lt;a href=&quot;#二叉查找树&quot; class=&quot;headerlink&quot; title=&quot;二叉查找树&quot;&gt;&lt;/a&gt;二叉查找树&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;二叉查找树可以用链接结构实现。
    
    </summary>
    
      <category term="Java" scheme="http://adamzeng.site/categories/Java/"/>
    
    
      <category term="Java" scheme="http://adamzeng.site/tags/Java/"/>
    
  </entry>
  
</feed>
