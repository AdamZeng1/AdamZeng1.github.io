<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AdamZeng</title>
  
  <subtitle>start from zero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://adamzeng.site/"/>
  <updated>2019-10-15T08:45:17.294Z</updated>
  <id>http://adamzeng.site/</id>
  
  <author>
    <name>AdamZeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++fundamental</title>
    <link href="http://adamzeng.site/2019/10/15/C-fundamental-1/"/>
    <id>http://adamzeng.site/2019/10/15/C-fundamental-1/</id>
    <published>2019-10-15T08:44:51.000Z</published>
    <updated>2019-10-15T08:45:17.294Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Primitive-Type"><a href="#Primitive-Type" class="headerlink" title="Primitive Type"></a>Primitive Type</h4><p>There are just six common primitive types in C++:</p><a id="more"></a><ol><li>int, stores integers</li><li>char, stores single characters/single byte</li><li>bool, stores a Boolean (true or false)</li><li>float, stores a floating point number</li><li>double, stores a double-precision floating point number</li><li>void, denotes the absence of a value</li></ol><h4 id="User-Defined-Type"><a href="#User-Defined-Type" class="headerlink" title="User-Defined Type"></a>User-Defined Type</h4><p>A unbounded number of user-defined types can exist- we’ll create many of out own!</p><p>Two common user-defined types</p><ul><li>std::string, a string(sequence of characters)</li><li>std::vector, a dynamically growing array</li></ul><h4 id="Public-vs-Private"><a href="#Public-vs-Private" class="headerlink" title="Public vs Private"></a>Public vs Private</h4><p>The protection level determines the access that “client code” has to the member data or functionality:</p><ul><li>Public members can be accessed by client code</li><li>Private members cannot be accessed by client code(only within the class itself)</li></ul><h4 id="Encapsolation"><a href="#Encapsolation" class="headerlink" title="Encapsolation"></a>Encapsolation</h4><p>In C++, the interface (h.file) to the class is defined separately from the implementation(.cpp).</p><h4 id="C-header-file-h"><a href="#C-header-file-h" class="headerlink" title="C++ header file(.h)"></a>C++ header file(.h)</h4><p>A header file (.h) defines the interface to the class, which includes:</p><ul><li>Declaration of all member variables</li><li>Declaration of all member functions</li></ul><h5 id="Pragma-once：-in-the-header-file"><a href="#Pragma-once：-in-the-header-file" class="headerlink" title="#Pragma once：  in the header file"></a>#Pragma once：  in the header file</h5><p>instructs the compiler only compile this code once</p><p>Even multiple people use our class, we only want the definition of our class to be defined exactly once.</p><p>class definition ends with ;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Cube.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Cube.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Cube::getVolume() &#123;</span><br><span class="line"><span class="keyword">return</span> length_ * length_ * length_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Cube::getSurfaceArea() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">6</span> * length_ * length_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The C++ standard library, often abbreviated as std, or sometimes called the C++ standard template library.</p><p>The C++ standard library is organized into many separate sub-libraries that can be #include’d in any C++ program.</p><h4 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h4><p>The iostream header includes operations for reading/writing to files and console itself, including std::out.</p><p>std::endl which is to denote a new line should be added to the end of our line.</p><h4 id="Standard-Library-Organization"><a href="#Standard-Library-Organization" class="headerlink" title="Standard Library Organization"></a>Standard Library Organization</h4><p>All functionality used from the standard library will be part of the std namespace.</p><ul><li><p>Namespaces allows us to avoid name conflicts for commonly used names;</p></li><li><p>If a feature from a namespace is used often, it can be imported into the global space with using</p></li></ul><p>using std::cout;</p><h4 id="Using-the-namespace"><a href="#Using-the-namespace" class="headerlink" title="Using the namespace"></a>Using the namespace</h4><p>A “Cube” is rather generic - hundreds of cube-based data structures exists!</p><p>We will be specific about our Cube and specify that our cube is within the uiuc namespace</p><p>In C++, the programmer has control over the memory and lifecycle of every variable! By default, variables live in stack memory.</p><h4 id="A-variable"><a href="#A-variable" class="headerlink" title="A variable"></a>A variable</h4><p>Every C++ variable has four things:</p><ul><li>A name</li><li>A type</li><li>A value</li><li>A location in memory(“memory address”)</li></ul><p>int primeNumber = 7;</p><h4 id="A-variable’s-Memory-Address"><a href="#A-variable’s-Memory-Address" class="headerlink" title="A variable’s Memory Address"></a>A variable’s Memory Address</h4><p>In C++, the &amp; operator returns the memory address of a variable</p><h4 id="Stack-Memory"><a href="#Stack-Memory" class="headerlink" title="Stack Memory"></a>Stack Memory</h4><p>By default, every variable in C++ is placed in stack memory.</p><p>Stack memory is associated with the current function and the memory’s lifecycle is tied to the function:</p><ul><li>When the function returns or ends, the stack memory of that function is released.</li></ul><p><em>Stack memory</em> always starts from high addresses and grows down.</p><h4 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h4><p>A pointer is a variable that stores the memory address of the data.</p><p>Simply put: pointers are a level of indirection from the data.</p><p>In C++,a pointer is defined by adding an * to the type of the variable</p><ul><li>Integer pointer: int *p =\&num;</li></ul><h4 id="Dereference-Operator"><a href="#Dereference-Operator" class="headerlink" title="Dereference Operator"></a>Dereference Operator</h4><p>Given a pointer, a level of indirection can be removed with the dereference operator *.</p><p>int num = 7;</p><p>int *p = \&num;</p><p>int value_in_num = *p;</p><p>*p = 42;</p><h4 id="Heap-Memory"><a href="#Heap-Memory" class="headerlink" title="Heap Memory"></a>Heap Memory</h4><p>If memory needs to exist for longer than the lifecycle of the function, we must use heap memory.</p><ul><li>The only way to create heap memory in C++ is with the new operator.</li></ul><p>The new operator returns a pointer to the memory storing the data - not the instance of the data itself.</p><p>The new operator in C++ will always do three things:</p><ol><li>Allocate memory on the heap for the data structure</li><li>Initialize the data structure</li><li>Return a pointer to the start of the data structure</li></ol><p>The memory is only ever reclaimed by the system when the pointer is passed to the delete operator.</p><p>The code below allocates two chunks of memory:</p><ul><li>Memory to store an integer pointer on the stack</li><li>Memory to store an integer on the heap</li></ul><p>int * numPtr = new int;</p><p>nullptr</p><p>The C++ keyword nullptr is a pointer that points to the memory address 0x0.</p><ul><li>nullptr represents a pointer to “nowhere”.</li><li>Address 0x0 is reserved and never used by the system.</li><li>Address 0x0 will always generate an “segmentation fault” when accessed.</li><li>Calls to delete 0x0 are ignored.</li></ul><p>emember that after the line “delete c;” the pointer c still stores the address of the deleted variable, which is no longer valid to dereference and is therefore dangerous. The pointer won’t be automatically set to nullptr. Then, you should <em>manually</em> set c to nullptr if you want to better protect against coding mistakes:</p><p>delete c;</p><p>c = nullptr;</p><p>Also, this is a good practice in general whenever you use “delete” on a pointer, but in this particular example, the function that is about to return is “main”. When main returns, the program exits and the operating system will usually release all the allocated memory back to the system. This isn’t an excuse to be sloppy, though; as you will soon see, many class objects have their “destructor” functions called silently when the program exits, and mistakes can trigger crashes even during that process.</p><h4 id="Arrow-Operator-gt"><a href="#Arrow-Operator-gt" class="headerlink" title="Arrow Operator(-&gt;)"></a>Arrow Operator(-&gt;)</h4><p>When an object is stored via a pointer, access  can be made to member functions using -&gt; operator:</p><p>c-&gt;getVolume();</p><p>…identical to…</p><p>(*c).getVolume();</p><p>Although each cpp file needs the appropriate headers included various header files.(The compiler might automatically skip)</p><p>That’s why it’s okay that main.cpp doesn’t have the Cube function definitions included: as long as main.cpp does know about the type information from the Cube function signatures in Cube.h, the main.o file will be “linked against” </p><p>The linker program will also link against system-wide object files, such as for iostream. After the compiler and linker programs finish processing your code, you will get an executable file as a result. In this case, that file is simply named main.</p><p>Fortunately, you won’t have to configure the compiler manually in this course. We will provide a Makefile to you for each project,which is a kind of script that tells the compiler how to build your program. </p><p>we include a Makefile with each project in this course, which is a kind of script that tells the compiler how to build your program. It gives instructions to the compiler and linker about which source files to use. All you need to do is type make on the command line in the appropriate directory.</p><p>####Automatic Default Constructor</p><p>If we do not provide any custom constructors, the C++ compiler provides an automatic default constructor for our class for free!</p><p>The automatic default constructor will only initialize all member variables to their default values.</p><h4 id="Custom-Default-Constructor"><a href="#Custom-Default-Constructor" class="headerlink" title="Custom Default Constructor"></a>Custom Default Constructor</h4><p>The simplest constructor we can provide is a custom default constructor the specifies the state of the object when the object is constructed. We define one by creating:</p><ul><li>A member function with the same name of the class</li><li>The function takes zero parameters</li><li>The function does not have a return type.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cube::Cube() <span class="comment">// custom default constructor</span></span><br></pre></td></tr></table></figure><h4 id="Custome-Constructor"><a href="#Custome-Constructor" class="headerlink" title="Custome Constructor"></a>Custome Constructor</h4><p>We can also specify custom, non-default constructors that require client code to supply arguments:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cube::Cube(<span class="keyword">double</span> length) <span class="comment">// one-argument ctor specifying initial length</span></span><br></pre></td></tr></table></figure><h4 id="Automatic-Custome-Constructor"><a href="#Automatic-Custome-Constructor" class="headerlink" title="Automatic Custome Constructor"></a>Automatic Custome Constructor</h4><p>If any custom constructor is defined, an automatic default cosntructor is not defined.</p><p>In C++, a copy constructor is a special constructor that exists to make a copy of an existing object.</p><p>The automatic copy constructor will copy the contents of all member variables.</p><h4 id="Custom-Copy-Constructor"><a href="#Custom-Copy-Constructor" class="headerlink" title="Custom Copy Constructor"></a>Custom Copy Constructor</h4><p>A custom copy constructor is :</p><ul><li>A class constructor </li><li>Has exactly one argument </li></ul><ul><li>The argument must be const reference of the same type as the class.</li></ul><p>Example:</p><p>Cube::Cube(const Cube &amp; obj)</p><h4 id="Copy-Constructor-Invocation"><a href="#Copy-Constructor-Invocation" class="headerlink" title="Copy Constructor Invocation"></a>Copy Constructor Invocation</h4><p>Often, copy constructors are invoked automatically:</p><ul><li>Passing an object as a parameter(by value)</li><li>Returning an object from a function(by value)</li><li>Initializing a new object</li></ul><p>In C++, a copy assignment operator defines the behavior when an object is copied using the assigment operator =</p><h4 id="Copy-Contructor-vs-Assigment"><a href="#Copy-Contructor-vs-Assigment" class="headerlink" title="Copy Contructor vs. Assigment"></a>Copy Contructor vs. Assigment</h4><p>A copy constructor creates a new object (constructor).</p><p>An assignment operator assigns a value to an existing object.</p><ul><li>An assignment operator is always called on an object that has already been constructed.</li></ul><h4 id="Automatic-Assignment-Operator"><a href="#Automatic-Assignment-Operator" class="headerlink" title="Automatic Assignment Operator"></a>Automatic Assignment Operator</h4><p>If an assignment operator is not provided, the C++ compiler provides n automatic assignment operator.</p><p>The automatic assignment operator will copy the contents of all member variables.</p><p>Only when we have externally allocated resources, Such as memory.Or we want multiple objects to point to the same thing, do we need to define a custom assignment operator.</p><h4 id="Custom-Assignment-Operator"><a href="#Custom-Assignment-Operator" class="headerlink" title="Custom Assignment Operator"></a>Custom Assignment Operator</h4><p>A custom assignment operator is:</p><ul><li>Is a public member function of the class</li><li>Has a function name operator=.</li><li>Has a return value of a reference of a class’ type.</li><li>Has exactly one argument </li></ul><ul><li>The argument must be const reference of the class’ type.</li></ul><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cube &amp; Cube::<span class="keyword">operator</span>=(<span class="keyword">const</span> Cube &amp; obj)</span><br></pre></td></tr></table></figure><p>In C++, an instance of a variable can be stored directly in memory, accessed by pointer,or accessed by reference.</p><h4 id="Direct-Storage"><a href="#Direct-Storage" class="headerlink" title="Direct Storage"></a>Direct Storage</h4><p>By default, variables are stored directly in memory.</p><ul><li>The type of a variable has no modifiers.</li><li>The object takes up exactly its size in memory.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cube c; <span class="comment">// Stores a Cube in memory</span></span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">// Stores an integer in memory</span></span><br><span class="line">uiuc::HSLAPixel p;<span class="comment">// Stores pixel in memory</span></span><br></pre></td></tr></table></figure><h4 id="Storage-by-Pointer"><a href="#Storage-by-Pointer" class="headerlink" title="Storage by Pointer"></a>Storage by Pointer</h4><ul><li>The type of a variable is modified with a asterisk(*).</li><li>A pointer takes a “memory address width” of memory (ex: 64 bits on a 64-bit system).</li><li>The pointer “points” to the allocated space of the object.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cube *c; <span class="comment">// Points a Cube in memory</span></span><br><span class="line"><span class="keyword">int</span> *i; <span class="comment">// Points an integer in memory</span></span><br><span class="line">uiuc::HSLAPixel *p;<span class="comment">// Points to a pixel in memory</span></span><br></pre></td></tr></table></figure><h4 id="Storage-by-Reference"><a href="#Storage-by-Reference" class="headerlink" title="Storage by Reference"></a>Storage by Reference</h4><ul><li>A reference is an alias to existing memory and is denoted in the type with an ampersand(&amp;).</li><li>A reference does not store memory itself, it is only an alias to another variable.</li><li>The alias must be assigned when the variable is initialized.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cube &amp;c = cube; <span class="comment">// Alias to the variable 'cube'</span></span><br><span class="line"><span class="keyword">int</span> &amp;i = count; <span class="comment">// Alias to the variable 'i'</span></span><br><span class="line">uiuc::HSLAPixel &amp;p; <span class="comment">// Illegal! Must alias something when variable is initialized</span></span><br></pre></td></tr></table></figure><h4 id="Pass-by"><a href="#Pass-by" class="headerlink" title="Pass by"></a>Pass by</h4><p>Identical to storage, arguments can be passed to functions in three different ways:</p><ul><li>Pass by value(default)</li><li>Pass by pointer(modified with *)</li><li>Pass by reference(modified with &amp;, acts as an alias)</li></ul><h4 id="Class-Destructor"><a href="#Class-Destructor" class="headerlink" title="Class Destructor"></a>Class Destructor</h4><p>When a instance of a class is cleaned up, the class destructor is the last call in class’s lifecycle.</p><h4 id="Automatic-Default-Destructor"><a href="#Automatic-Default-Destructor" class="headerlink" title="Automatic  Default Destructor"></a>Automatic  Default Destructor</h4><p>An automatic default destructor is added to your class if no other destructor is defined.</p><p>The only action of the automatic default desctructor is to call the default destructor of all member objects.</p><p>A destructor should never be called directly. Instead, it is automatically called when the object’s memory is being reclaimed by the system:</p><ul><li>If the object is on the stack, when the function returns.</li><li>If the object is on the heap, when delete is used.</li></ul><h4 id="Custom-Destructor"><a href="#Custom-Destructor" class="headerlink" title="Custom Destructor"></a>Custom Destructor</h4><p>To add custom behavior to the end-of-life of he function, a custom destructor can be defined as:</p><ul><li>A custom destructor is a member function.</li><li>The function’s destructor is the name of the class, preceded by the tilde~</li><li>All destructors have zero arguments and no return type.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cube::~Cube();</span><br></pre></td></tr></table></figure><p>A custom destructor is essential when an object allocates an external resource that must be closed or freed when the object is destroyed. Example:</p><ul><li>Heap memory</li><li>Open files</li><li>Shared memory</li></ul><h4 id="Segmentation-fault"><a href="#Segmentation-fault" class="headerlink" title="Segmentation fault"></a>Segmentation fault</h4><p>In summary, remember that if you use “new,” you will also need to “delete,” and after you delete, you should set to nullptr.</p><h4 id="template-type"><a href="#template-type" class="headerlink" title="template type"></a>template type</h4><p>A template type is a special type that can take on different types when the type is initialized.</p><p>std::vector\<char> </char></p><p>std::vector\<int></int></p><p>std::vector\<a href="uiuc::Cube" target="_blank" rel="noopener">uiuc::Cube</a></p><h4 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h4><p>std::vector standard library class that provides the functionality of dynamically growing array with a “templated” type. Key ideas:</p><p>Defined in: #include \<vector></vector></p><p>Initialization: std::vector\<t> V:</t></p><p>Add to (back) of array:  ::push_back(T):</p><p>Access specific element: ::operator[](unsigned pos);</p><p>Number of elements: ::size();</p><h4 id="Template-type"><a href="#Template-type" class="headerlink" title="Template type"></a>Template type</h4><p>When initializing a “templated” type, the template type goes inside of &lt;&gt; at the end of the type name:</p><p>std::vector\<char> v1;</char></p><p>std::vector\<int> v2;</int></p><p>std::vector\<a href="uiuc::Cube" target="_blank" rel="noopener">uiuc::Cube</a>v3;</p><p>Consider the Tower of Hanoi problem, where multiple cubes must be transfered to a new location in such a way that a larger cube can not be placed on top of smaller cube</p><h4 id="Hanoi"><a href="#Hanoi" class="headerlink" title="Hanoi"></a>Hanoi</h4><p>A new class must be created to represent each of the stack in the Tower of Hanoi game:</p><h4 id="Building-the-Stack-Class"><a href="#Building-the-Stack-Class" class="headerlink" title="Building the Stack Class"></a>Building the Stack Class</h4><p>A single stack must contain:</p><ul><li>An vector of cubes</li><li>Operations to interact with the top of the stack</li></ul><p>Finally, the game is built from the components we have already built:</p><ul><li>A array of three stacks</li><li>The initial state has four cubes in the first stack</li></ul><h4 id="Moves-Planned"><a href="#Moves-Planned" class="headerlink" title="Moves Planned"></a>Moves Planned</h4><p>Move(source[0…3] -&gt; target)</p><ol><li>move(source[1…3]-&gt;Spare)</li><li>move(source[0]-&gt;Target)</li><li>move(spare[1…3]-&gt;Target)</li></ol><h4 id="Templated-Functions"><a href="#Templated-Functions" class="headerlink" title="Templated Functions"></a>Templated Functions</h4><p>A template variable is defined by declaring it before the beginning of a class or function:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(T a,T b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;b) &#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Compile-Time-Binding"><a href="#Compile-Time-Binding" class="headerlink" title="Compile-Time Binding"></a>Compile-Time Binding</h4><p>Templated variables are checked at compile time, which allows for errors to be caught before running the program:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a,T b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;b) &#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max(<span class="number">4</span>,<span class="number">7</span>); <span class="comment">// ok</span></span><br><span class="line">max(Cube(<span class="number">4</span>),Cube(<span class="number">7</span>)); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><h4 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h4><p>Inheritance allows for a class to inherit all member functions and data from a base class into a derived class.</p><h4 id="Generic-to-Specialized"><a href="#Generic-to-Specialized" class="headerlink" title="Generic to Specialized"></a>Generic to Specialized</h4><p>A base class is a generic form of a specialized, derived class.</p><p>Shape -&gt; Cube</p><h4 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h4><p>When a derived class is initialized, the derived class must construct the base class:</p><ul><li>Cube must construt Shape</li><li>By default, uses default constructor</li><li>Custom constructor can be used with an initialization list</li></ul><h4 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h4><p>When a base class is inherited, the derived class:</p><ul><li>Can access all public members of the base class</li><li>Can not access private members of the base class</li></ul><h4 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer list"></a>Initializer list</h4><p>The syntax to initialize the base class is called the initializer list and can be used for several purposes:</p><ul><li>Initialize a base  class</li><li>Initialize the current class using another constructor</li><li>Initialize the default values of member variables</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Primitive-Type&quot;&gt;&lt;a href=&quot;#Primitive-Type&quot; class=&quot;headerlink&quot; title=&quot;Primitive Type&quot;&gt;&lt;/a&gt;Primitive Type&lt;/h4&gt;&lt;p&gt;There are just six common primitive types in C++:&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
